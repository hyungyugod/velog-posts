# 📌 1. VPN과 터널링 원리

## 1-1. 핵심 개념
- **정의**: VPN은 공용 인터넷 위에 **암호화된 터널**을 만들고, 터널 끝의 **VPN 서버**가 외부와 통신을 대리하는 구조이다.
- **구성요소**: 터널링(캡슐화), 암호화/복호화, 인증, 라우팅, 서버(가상/물리).

## 1-2. 동작 원리
- **캡슐화(Encapsulation)**: 원래 패킷을 다른 패킷으로 감싸 전송한다. 즉, 내부 페이로드를 외부 IP 헤더로 재포장한다.
- **경로**: 내 기기 →(암호화/캡슐화)→ VPN 서버 →(복호화/대리 통신)→ 목적지.
- **IP 시점 변화**: 웹사이트는 내 IP가 아니라 **VPN 서버의 IP**를 본다.

## 1-3. 가상 서버(가상화) 원리
- 물리 서버 위에 **VM/컨테이너**로 여러 지역의 VPN 인스턴스를 띄운다.
- 상용 서비스는 전 세계 데이터센터에 물리/클라우드 혼합으로 배치한다.

## 1-4. 설계 원칙
- **보안성**: 공용망에서도 패킷 도청 방지(암호화).
- **접근성**: 원격에서 사내/자가망 안전 접속.
- **확장성**: 프로토콜 추상화(IPsec, TLS/OpenVPN, WireGuard).

## 1-5. 결론
- VPN = “암호화된 가상 통로 + 대리 통신자(서버)”. 보안과 접근성을 제공하나, 속도/업체 신뢰가 품질을 좌우한다.


# 📌 2. URL 구조(URI 구성요소)

## 2-1. 분해 예시
```
foo://localhost:8080/over/there?name=ferret#nose
```
- **scheme**: `foo`
- **authority**: `//localhost:8080`
- **path**: `/over/there`
- **query**: `?name=ferret`
- **fragment**: `#nose` (클라이언트 내 스크롤 위치, 서버에 전송되지 않음)

## 2-2. 설계 원칙
- **프로토콜 독립 식별**: 자원 접근 방식을 scheme으로 분리.
- **구조적 주소화**: 위치(authority)와 대상(path), 조건(query), 부분(fragment)로 계층화.

## 2-3. 결론
- 정답 매핑: scheme→authority→path→query→fragment = 1-2-3-4-5 순. 예시 문제의 답은 **43125**.


# 📌 3. 자바 — 오버로딩 vs 오버라이딩, 제네릭/소거, 업캐스팅

## 3-1. 두 가지 타입 관점
- **정적 타입**: 컴파일러가 아는 타입(예: `Object`, `Number`).
- **실제 타입**: 런타임 객체의 진짜 클래스(예: `Integer`).

## 3-2. 오버로딩(정적 바인딩) vs 오버라이딩(동적 바인딩)
- **오버로딩**: 컴파일 타임에 **인수의 정적 타입**으로 최적 시그니처를 결정 → 호출 비용 0.
- **오버라이딩**: 런타임에 **수신 객체의 실제 타입**으로 구현 선택 → 다형성 보장.

## 3-3. 제네릭과 타입 소거
- 바이트코드에서 제네릭 `T`는 **상한으로 소거**된다(상한 미지정 시 $Object$).
- 따라서 `new Printer().print(value)`에서 `value`의 **정적 타입이 $T \to Object$**로 보이면 `print(Object)`가 선택된다.
- 예제 결론: 출력 **B0** (상한을 `Number`로 주면 **C0**, `Integer`로 캐스팅하면 **A0**).

### 예시 코드
```java
class Printer {
  void print(Integer a){ System.out.print("A"+a); }
  void print(Object a){ System.out.print("B"+a); }
  void print(Number a){ System.out.print("C"+a); }
}
class Box<T>{
  T v;
  void f(){ new Printer().print(v); } // v의 정적 타입은 소거 후 Object
}
```

## 3-4. 설계 원칙
- **예측 가능성**: 오버로딩은 컴파일 시 결정(정적 바인딩).
- **다형성**: 오버라이딩은 런타임 결정(동적 디스패치).
- **하위 호환/성능**: 제네릭은 소거로 구현.

## 3-5. 결론
- “오버로딩은 문법, 오버라이딩은 객체의 행동.”  
- “$T$의 상한이 오버로딩 선택을 좌우한다.”


# 📌 4. 자바 — 업캐스팅과 필드/메서드 바인딩 차이

## 4-1. 핵심 규칙
- **필드(변수)**: **정적 바인딩** — 참조 변수의 **정적 타입** 기준.
- **메서드(행동)**: **동적 바인딩** — **실제 객체 타입** 기준.

## 4-2. 메모리 모델(예시)
```java
class Base { int x=3; int getX(){ return x*2; } }
class Derivate extends Base { int x=7; int getX(){ return x*3; } }

Base a = new Derivate();
Derivate b = new Derivate();

// 평가
a.getX()  // Derivate.getX() → 7*3 = 21 (동적 바인딩, this.x)
a.x       // Base.x = 3       (정적 바인딩)
b.getX()  // 21
b.x       // 7
// 합계: 52
```

- `this.x`는 현재 클래스 필드, `super.x`는 부모 필드.
- `static` 메서드는 클래스 레벨이라 **오버라이딩 대상이 아님**(숨김만 됨).

## 4-3. 설계 원칙
- **데이터는 선언 타입이 책임**, **행동은 객체가 책임**.
- 성능(필드 정적 접근)과 다형성(메서드 동적 접근)의 균형.

## 4-4. 결론
- 업캐스팅: “부모 눈으로 보되, 행동은 실제 객체가 결정.”  
- `super`는 기반 부분을 명시적으로 접근하는 통로.


# 📌 5. UML 관계 — 연관/일반화/의존

## 5-1. 구분
- **연관(Association)**: has-a, 실선. 부품 교체 가능, 결합도 낮음.
- **일반화(Generalization)**: is-a, 속 빈 삼각형. 상속/다형성.
- **의존(Dependency)**: uses-a, 점선 화살표. 일시 사용, 영향 최소화.

## 5-2. 설계 원칙과 결론
- 관계는 **결합 강도**를 단계화하여 변경 비용을 줄이려는 표현.  
- 문제 매핑: (1) 연관, (2) 일반화, (3) 의존.


# 📌 6. 문자열 리터럴 vs new String

## 6-1. 구조
- `"A"`: **String Pool**에 저장 — 같은 리터럴 재사용(같은 참조).
- `new String("A")`: **Heap에 새 객체** 생성 — 값 같아도 참조 다름.

## 6-2. 비교
- `==` → 참조 비교, `.equals()` → 내용 비교.

### 예시
```java
String a = "A";
String b = "A";
String c = new String("A");

System.out.println(a==b); // true
System.out.println(a==c); // false
System.out.println(a.equals(c)); // true
```

## 6-3. 설계 원칙과 결론
- **불변(Immutable)** + **풀 공유**로 메모리 효율/스레드 안전성 확보.
- 값은 같아도 참조는 다를 수 있다.


# 📌 7. 파이썬 타입 분기와 튜플

## 7-1. 코드 요약
```python
def func(value):
    if type(value) == type(100):
        return 100
    elif type(value) == type(""):
        return len(value)
    else:
        return 20

a = '100.0'    # str
b = 100.0      # float
c = (100,200)  # tuple
print(func(a) + func(b) + func(c))  # 45
```

## 7-2. 원리
- `(100, 200)`은 **tuple**. 요소가 쉼표로 구분되면 튜플.
- `type()` 비교는 상속 고려 안 함. 보통은 `isinstance(obj, cls)` 사용이 더 안전.

## 7-3. 결론
- 출력: $5 + 20 + 20 = 45$.
- 튜플은 불변, 리스트 대비 변경 불가성으로 안전한 다중 반환/키로 활용 가능.


# 📌 8. 총괄 설계 철학 요약

## 8-1. 공통 원리
- **분리와 계층화**: URL, VPN, UML 모두 역할을 분리해 결합도를 낮춘다.
- **정적 예측성과 동적 유연성의 균형**: 자바의 오버로딩/오버라이딩, 필드/메서드 바인딩 구분.
- **공유와 불변**: String Pool, 튜플의 불변성 → 안전성과 효율.

## 8-2. 결론
- “**데이터는 구조로, 행동은 맥락으로, 연결은 계층으로** 설계한다.”  
  예측 가능성(정적)과 유연성(동적)의 균형이 좋은 설계의 핵심이다.
