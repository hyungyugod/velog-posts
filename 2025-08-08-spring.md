# 📌 0. 스프링 + 리액트 연계 보스 사이트 방문자수 집계
### 📌 0-1. 테이블구조와 집계 방식
- 스케줄러가 매일 하루 방문자의 ip수(중복 없이)를 조회하여 Visitor_statistic 테이블에 등록한다.
```java
@Data
@Builder
public class VisitorStatistic {
    private int visitorStatisticId; // 방문자 통계 ID
    private int dailyVisitorSum; // 일일 방문자 합계
    private LocalDateTime regDate; // 등록 시간
    private LocalDateTime editDate; // 수정 시간
}
```
- 프론트에서 통계데이터를 요청하면 아래 처럼 현재 날짜를 기준으로 최근 데이터를 모아 DTO에 넣어서 반환한다.
```java
@Data
@Builder
public class VisitorStatsDto {
    private Map<String, Integer> monthlyStats;  // 지난 1년간 월별 통계 (년-월 : 방문자수)
    private Map<String, Integer> yearlyStats;   // 최근 5년간 연별 통계 (년 : 방문자수)
    private Map<String, Integer> dailyStats;    // 최근 7일간 날짜별 통계 (월-일 : 방문자수)
    private int totalVisitors;                  // 총 방문자수
}
```

### 📌 0-2. 일별 방문자수 -> 최근 연, 월, 일별 조회 서비스
- 우선 전체 데이터를 가져온다.
- LocalDateTime의 isAfter 메서드는 넣은 날짜 이후라면 true를 반환한다. 이를 이용해 oneYearAgo, fiveYearsAgo, sevenDaysAgo를 모두 이용하여 전체 데이터를 순환하면서 해당 날짜에 맞는 데이터만 우선 거른다.
- 이후 string으로 키값을 설정하고 map에 getOrDefault를 활용하여 새로운 키값을 만들어서 방문자수를 누적한다. 이때 키값은 예를들어 12월이면 2025-12월이된다.
- 키포인트는 mapper에서 날짜를 과거에서 현재 순으로 즉 오름차순으로 가져와서 LinkedHashMap으로 순서를 유지하여 데이터를 꺼낼때 과거부터 꺼내서 현재가 맨 오른쪽으로 오게 하는데에 있다.
```java
@Autowired
    private VisitorMapper visitorMapper;    
    
    @Override
    public VisitorStatsDto getVisitorStats() {
        // 전체 방문자 통계 데이터 조회
        List<VisitorStatistic> allData = visitorMapper.getAllVisitorStatistics();
        int totalVisitors = visitorMapper.getTotalVisitorCount();
        
        // 현재 시간 기준으로 필터링 날짜 계산
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime oneYearAgo = now.minusMonths(11);
        LocalDateTime fiveYearsAgo = now.minusYears(4);
        LocalDateTime sevenDaysAgo = now.minusDays(7);
        
        // 통계용 Map 초기화
        Map<String, Integer> monthlyStats = new LinkedHashMap<>();
        Map<String, Integer> yearlyStats = new LinkedHashMap<>();
        Map<String, Integer> dailyStats = new LinkedHashMap<>();
        
        // 전체 데이터를 순회하면서 통계 계산
        for (VisitorStatistic statistic : allData) {          
            LocalDateTime regDate = statistic.getRegDate();
            
            if (regDate != null) {
                // 연별 통계 (최근 5년 데이터만)
                if (regDate.isAfter(fiveYearsAgo)) {
                    String yearKey = String.valueOf(regDate.getYear());
                    yearlyStats.put(yearKey, yearlyStats.getOrDefault(yearKey, 0) + statistic.getDailyVisitorSum());
                }
                
                // 월별 통계 (최근 1년 데이터만)
                if (regDate.isAfter(oneYearAgo)) {
                    String monthKey = String.format("%d-%02d", regDate.getYear(), regDate.getMonthValue());
                    monthlyStats.put(monthKey, monthlyStats.getOrDefault(monthKey, 0) + statistic.getDailyVisitorSum());
                }
                
                // 날짜별 통계 (최근 7일 데이터만)
                if (regDate.isAfter(sevenDaysAgo)) {
                    String dayKey = String.format("%02d-%02d", regDate.getMonthValue(), regDate.getDayOfMonth());
                    dailyStats.put(dayKey, dailyStats.getOrDefault(dayKey, 0) + statistic.getDailyVisitorSum());
                }
            }        
        }
        
        // DTO 빌더 패턴으로 생성
        return VisitorStatsDto.builder()
            .monthlyStats(monthlyStats)
            .yearlyStats(yearlyStats)
            .dailyStats(dailyStats)
            .totalVisitors(totalVisitors)
            .build();
    }
```
- mapper는 아래와 같다.
```java
@Mapper
public interface VisitorMapper {    
    
    @Insert("INSERT INTO visitor_statistic (daily_visitor_sum, reg_date, edit_date) " +
            "VALUES (#{dailyVisitorSum}, #{regDate}, #{editDate})")    
    int insertVisitorStatistic(VisitorStatistic visitorStatistic);    
    
    // 전체 방문자 통계 데이터 조회 (날짜 오름차순 정렬: 과거 -> 현재)
    @Select("SELECT visitor_statistic_id, daily_visitor_sum, reg_date, edit_date FROM visitor_statistic ORDER BY reg_date ASC")
    List<VisitorStatistic> getAllVisitorStatistics();
    
    // 오늘 날짜의 통계가 있는지 확인
    @Select("SELECT COUNT(*) FROM visitor_statistic WHERE DATE(reg_date) = CURDATE()")
    int getTodayStatisticCount();

      // 오늘 날짜의 통계 업데이트
    @Update("UPDATE visitor_statistic SET daily_visitor_sum = daily_visitor_sum + #{increment}, edit_date = NOW() " +
            "WHERE DATE(reg_date) = CURDATE()")
    int updateTodayStatistic(int increment);
}
```

### 📌 0-3. 방문자수 프론트엔드 설계
- 리액트에서 중요한 점은 chartData를 드롭박스에 따라 동적으로 생성하여 스타일과 data = item.yearlyStats처럼 map까지 item으로 담아서 useMemo를 통해 리턴하는 것이다.
- 이후 data에 data={chartData.chartData}로 미리 정리된 키, 값, 디자인을 한번에 넘겨서 공통 디자인 처리와 옵션처리만 추가로 하고 방문자를 띄우는 것이다.
- 데이터를 받는 과정은 fetch헬퍼와 redux헬퍼를 이용해 chunk와 액션함수들을 미리 설정해두고 미리 지정해둔 상태값에 맞춰서 백엔드에서 데이터를 보낸다.
- 드롭다운 옵션은 일반 context Api를 통해 관리하면 된다.
```js
import React, { memo, useCallback, useEffect, useMemo, useState } from "react";
import styled from "styled-components";
import { useDispatch, useSelector } from "react-redux";
import Spinner from "../components/Spinner";
import { getVisitorCount } from "../slices/VisitorCountSlice";

import {
  Chart,
  CategoryScale,
  LinearScale,
  Title,
  Tooltip,
  Legend,
  BarElement,
} from 'chart.js';

import { Bar } from 'react-chartjs-2';

// Chart.js에서 import한 Chart컴포넌트 내에서 import 요소들을 등록한다.
Chart.register(CategoryScale, LinearScale, Title, Tooltip, Legend, BarElement);

const VisitorCountChartContainer = styled.div`
  padding: 20px;
  flex: 1 1 calc(50% - 20px);
  min-height: 400px;
  height: 100%;
`;

const ChartContainer = styled.div`
  height: 300px;
  width: 100%;
`;

const ChartHeader = styled.div`
  display: flex;
  gap: 20px;
  align-items: center;
  margin-bottom: 20px;
`;

const ChartTitle = styled.h2`
  margin: 0;
`;

const StatsSelect = styled.select`
  padding: 8px 12px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background-color: white;
  font-size: 14px;
  cursor: pointer;

  &:focus {
    outline: none;
    border-color: #007bff;
  }
`;

const VisitorCountChart = memo(() => {
  const { loading, status, message, item } = useSelector((state) => state.VisitorCountSlice);
  
  const dispatch = useDispatch();
  
  // 통계 타입 상태 - 기본값을 daily로 변경
  const [statsType, setStatsType] = useState('daily');

  useEffect(() => {
    dispatch(getVisitorCount());
  }, [dispatch]);

  // 선택된 통계 타입에 따라 차트 데이터 생성
  const chartData = useMemo(() => {
    if (!item) return null;

    let data, title, backgroundColor, borderColor;

    switch (statsType) {
      case 'daily':
        data = item.dailyStats;
        title = "최근 7일 방문자 통계";
        backgroundColor = "rgba(75, 192, 192, 0.5)";
        borderColor = "rgba(75, 192, 192, 1)";
        break;
      case 'monthly':
        data = item.monthlyStats;
        title = "월별 방문자 통계 (최근 1년)";
        backgroundColor = "rgba(54, 162, 235, 0.5)";
        borderColor = "rgba(54, 162, 235, 1)";
        break;
      case 'yearly':
        data = item.yearlyStats;
        title = "연별 방문자 통계";
        backgroundColor = "rgba(255, 99, 132, 0.5)";
        borderColor = "rgba(255, 99, 132, 1)";
        break;
      default:
        return null;
    }

    if (!data) return null;

    const keys = Object.keys(data);
    const values = Object.values(data);

    return {
      chartData: {
        labels: keys,
        datasets: [
          {
            label: "방문자 수",
            data: values,
            backgroundColor: backgroundColor,
            borderColor: borderColor,
            borderWidth: 1,
          },
        ],
      },
      title: title
    };
  }, [item, statsType]);

  const handleStatsTypeChange = useCallback((e) => {
    setStatsType(e.target.value);
  }, []);

  return (
    <VisitorCountChartContainer>
      <ChartHeader>
        <ChartTitle>방문자수</ChartTitle>          
        <StatsSelect value={statsType} onChange={handleStatsTypeChange}>
          <option value="daily">최근 7일</option>
          <option value="monthly">월별</option>
          <option value="yearly">연별</option>
        </StatsSelect>
      </ChartHeader>
      <Spinner loading={loading} />

      {chartData && (
        <ChartContainer>
          <Bar
            data={chartData.chartData}
            options={{
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  position: "bottom",
                },
                title: {
                  display: true,
                  text: chartData.title,
                  font: {
                    size: 18,
                    color: "#000",
                  },
                },
              },
              scales: {
                y: {
                  beginAtZero: true,
                  ticks: {
                    stepSize: 1,
                  },
                },
              },
            }}
          />
        </ChartContainer>
      )}
    </VisitorCountChartContainer>
  );
});

export default VisitorCountChart;
```
- 아래는 프론트의 받는 청크와 슬라이스 등록로직이고 그 아래는 백엔드에서 요청을 받는 로직이다.
- 요청은 브라우저에서 프론트로 localhost:3000으로 보내지만 프론트에서 이 요청을 프록시를 통해 localhost:8080으로 토스한다.
```js
import reduxHelper from '../helpers/ReduxHelper';

const API_URL = '/api/visitor/count';

export const getVisitorCount = reduxHelper.get("VisitorCountSlice/getVisitorCount", API_URL);

const VisitorCountSlice = reduxHelper.getDefaultSlice("VisitorCountSlice", [getVisitorCount]);

export default VisitorCountSlice.reducer;
```
```java
@RestController
@RequestMapping("/api/visitor")
@Slf4j
@RequiredArgsConstructor
public class VisitorRestController {

    private final VisitorService visitorService;
    private final RestHelper restHelper;

    @GetMapping("/count")
    public Map<String, Object> getVisitorCount() {
        VisitorStatsDto data = visitorService.getVisitorStats();
        return restHelper.sendJson(data);
    }
}
```