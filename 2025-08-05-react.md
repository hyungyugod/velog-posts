# 📌 0. reudx 활용
### 📌0-1. reduxHelper
- redux에서 ajax를 위한 slice 생성을 돕는 헬퍼이다.
- 기본 상태를 정의해주고(백엔드 응답 구조에 맞춰) createAsyncThunk에서 자동으로 실행해주는 pending, fulfilled, rejected 액션함수(리듀서) 등록까지 해준다.
- pending(pendere - > pendulum 등 매달려 있다는 어원) : 아직 끝나지 않은, 실행 중인 이라는 뜻이다.
- 그러니까 ajax 중에는 상태를 현재 상태 그대로 두고 로딩바만 띄운다.
- 이후 성공하면 새로온 응답을 현재 상태로 업데이트하고 로딩바를 닫는다.
- 실패하면 기본 구조를 덮어쓰고 status와 message만 기존에서 변경한다.
- 구조 상 같은 상태를 공유할 ajax 청크는 같이 extraReducers 배열에 전달하여 getDefaultSlice로 상태를 만들어두어야한다.
```js
import {createSlice} from "@reduxjs/toolkit";

const pending = (state, {meta, payload}) => {
    return {...state, loading: true};
};

const fulfilled = (state, {meta, payload}) => {
    return {...payload, loading: false};
};

const rejected = (state, {meta, payload}) => {
    return {
        ...state,
        loading: false,
        status: payload.status || 0,
        message: payload.message || "unknown Error",
    };
};

const reduxHelper = {
    getDefaultSlice: (slideName, extraReducers = [], callback = {}, reducers = {}) => {
        return createSlice ({
            name: slideName,

            initialState: {
                status: 200,
                message: "OK",
                item: null,
                timstamp: null,
                loading: false,
            },

            reducers: reducers,

            extraReducers: (builder) => {
                extraReducers.forEach((v, i) => {
                    builder.addCase(v.pending, pending)
                            .addCase(v.fulfilled, callback[v.fulfilled] || fulfilled)
                            .addCase(v.rejected, rejected);
                });
            },
        });
    },
};
```

### 📌0-2. slice 만든 후에 store 연결
- createAsyncThunk로 비동기 요청을 보내주는 함수를 이 redux context에 포함시키면서(리덕스의 slice(슬라이스)에 이 함수를 등록해서, → 상태(state) 관리와 연결시킨다.) 기능을 담은 객체를 만든다 (이 과정에서 “슬라이스”라는 객체가 만들어지고, → 이 객체는 비동기 로직과 상태를 함께 갖는다.).
- Thunk = 어떤 작업을 미루고 싶을 때, 그 작업을 함수로 감싸서 전달하는 것 (실제로 필요할 때만 연산 실행)
- 원래 think의 과거형은 thought인데 1960년대 미국 컴퓨터 과학자들이 컴파일러 개발을 하면서 농담처럼 "thunk"라는 단어를 만들어 썼다. 의도: "내가 (곧) 생각할 거야!" → "아직 생각은 안 했고, 나중에 생각할 거야." = 아직 계산(실행)하지 않고, 나중에 실행할 거야 라는 뜻이다.
- 청크를 만들면 pending, fulfilled, rejected라는 리듀서가 내부에 내장되는데 이 리듀서들을 미리 정의해두면 청크로 ajax를 사용할때 자동으로 상태를 변환할 수 있게된다.
- 원래 슬라이스 만들때 reducer안에 직접 리듀서 함수들을 정의해두어야하지만 외부의 함수에 반영할 케이스들은 extraReducers에 따로 등록해두는 것이다.
- addCase(v.pending, pending) 이 뜻은 v.pending의 상태가 변할 때 pending 이 액션함수를 실행하는 리듀서를 만들라는 뜻이다.
```js
import {createAsyncThunk} from "@reduxjs/toolkit";
import fetchHelper from "../helpers/FetchHelper";
import reduxHelper from "../helpers/ReduxHelper";

const API_URL = "/traffic_acc";

export const getList = createAsyncThunk("TrafficAccSlice/getList", async (payload, {rejectWithValue}) => {
    let result = null;

    const params = {};

    try {
        result = await fetchHelper.get(API_URL, payload);
    }catch (err) {
        result = rejectWithValue(err);
    }

    return result;
});

const TrafficAccSlice = reduxHelper.getDefaultSlice("TrafficAccSlice", [getList]);

export default TrafficAccSlice.reducer;
```
- 슬라이스를 만들면 TrafficAccSlice.reducer로 슬라이스에서 리듀서 기능만 뽑아서 store에 등록해둔다. 그러면 TrafficAccSlice에서 정의되었던 리듀서가 context에 등록된다.
```js
const store = configureStore(
    {
        reducer: {
            CounterSlice,
            GradeSlice,
            TrafficAccSlice
        }
    }
);
```

### 📌0-3. 이를 활용한 사고 데이터 조회 방법 2가지
- 우선 첫번째 경우는 드롭다운의 값을 상태로 관리하면서 해당 드롭다운 값이 바뀔때마다 dispatch(getList({ year })); 를 실행하여 year를 파라미터로 get요청을 보낸다.
- `<select value={year} onChange={e => setYear(Number(e.target.value))}>` 드롭다운에 옆처럼 체인지 이벤트를 걸어서 값이 바뀐후에 그 바뀐 값을 dispatch 함수를 통해 세팅한다.
- {[...Array(14)].map((_, i)} 이건 되고 new Array(14)는 map으로 구조분해가 안되는 이유는 ...으로 분해하고 채우면 값을 undefined로 채워주지만 new Array는 그냥 빈값이어서 그렇다.
- react에서 드롭다운은 그냥 JSX 태그 사이에서 js 문법으로 동적 생성하면 된다.
- 목록 값도 그냥 반복돌면서 값을 삽입하여 리턴한다.
```js
const TrafficAccTypeB = memo(() => {
    // hook을 통해 slice가 관리하는 상태값 가져오기
    // --> 화면 출력에 필요한 항목만 선택적으로 구조분해 한다.
    const { loading, status, message, item } = useSelector((state) => state.TrafficAccSlice);

    // 검색년도 : 2005~2018년 사이의 데이터만 조회
    const [year, setYear] = useState(2018);

    // dispatch 함수 생성
    const dispatch = useDispatch();

    // 컴포넌트가 마운트되거나 year 값이 변경될 때마다 getList 액션함수를 디스패치하여 데이터를 가져온다.
    useEffect(() => {
        if (!year) return; // year가 유효하지 않으면 실행하지 않음
        dispatch(getList({ year }));
    }, [year]);

    return (
        <TrafficAccTypeBContainer>
            <h2>TrafficAcc Type A - 백엔드로부터 매번 데이터 받아오기</h2>

            <Spinner loading={loading} />

            {status !== 200 && (
                <div className="error-info">
                    <h1>{status} Error</h1>
                    <p>{message}</p>
                </div>
            )}

            <div className="search-form">
                <select value={year} onChange={e => setYear(Number(e.target.value))}>
                    {[...Array(14)].map((_, i) => {
                        const yearValue = 2005 + i;
                        return (
                            <option key={yearValue} value={yearValue}>
                                {yearValue}
                            </option>
                        );
                    })}
                </select>
            </div>

            <Table>
                <thead>
                    <tr>
                        <th>번호</th>
                        <th>년도</th>
                        <th>월</th>
                        <th>교통사고수</th>
                        <th>사망자 수</th>
                        <th>부상자 수</th>
                    </tr>
                </thead>
                <tbody>
                    {item && item.map((v, i) => {
                        return (
                            <tr key={i}>
                                <td>{v.id}</td>
                                <td>{v.year}</td>
                                <td>{v.month}</td>
                                <td>{v.accident.toLocaleString()}</td>
                                <td>{v.death.toLocaleString()}</td>
                                <td>{v.injury.toLocaleString()}</td>
                            </tr>
                        );
                    })}
                </tbody>
            </Table>
        </TrafficAccTypeBContainer>
    );
});

export default TrafficAccTypeB;
```
- 두번째 방법에서 달라진 점은 처음에는 dispatch(getList({}));로 전체데이터를 받아오고 원래 있었던 상태변수인 item에서 드롭다운 바뀔때 해당 연도만 가져옴.
- useEffect가 아니라 useMemo를 사용해야 값을 리턴받을 수 있으며 값이 안바뀌면 캐싱해두었던 값을 재사용함.
- 해당 부분까지만 다르고 아래에서 trafficData를 직접 쓴다는 것만 다르므로 아래 로직은 생략한다.
```js
const TrafficAccTypeB = memo(() => {
    // hook을 통해 slice가 관리하는 상태값 가져오기
    // --> 화면 출력에 필요한 항목만 선택적으로 구조분해 한다.
    const { loading, status, message, item } = useSelector((state) => state.TrafficAccSlice);

    // 검색년도 : 2005~2018년 사이의 데이터만 조회
    const [year, setYear] = useState(2018);

    // dispatch 함수 생성
    const dispatch = useDispatch();

    // 컴포넌트가 마운트되면 데이터 조회를 위한 액션함수를 디스패치 함 -> 컴포넌트 마운트시에만 실행됨
    useEffect(() => {
        // 전달되는 payload값이 없으므로 slice에서 전체 데이터를 요청한다.
        dispatch(getList({}));
    }, []);

    // 선택한 년도에 해당하는 교통사고 데이터만 필터링
    // --> useMemo를 사용하여 성능 최적화
    const trafficData = useMemo(() => {
        if (!item || item.length === 0) return [];
        return item.filter((v) => v.year === year);
    }, [item, year]);
```

# 📌 1. redux로 crud 구현
### 📌 1-1. reduxHelper 확장
- reduxHelper에 getDefaultSlice 메서드 아래로 (get, post, put, delete)청크를 만드는 메서드를 추가한다.
- 
```js
    get: async (alias, url, callback = (payload) => {return {url: url, params: payload}}) => {
        return createAsyncThunk(alias, async (payload, {rejectWithValue}) => {
            let result = null;
            const {url, params} = callback(payload);

            try {
                result = await fetchHelper.get(url, params);
            } catch (err) {
                result = rejectWithValue(err);
            }

            return result;
        })
    },

    post: async (alias, url, callback = (payload) => {return {url: url, params: payload}}) => {
        return createAsyncThunk(alias, async (payload, {rejectWithValue}) => {
            let result = null;
            const {url, params} = callback(payload);

            try {
                result = await fetchHelper.post(url, params);
            } catch (err) {
                result = rejectWithValue(err);
            }

            return result;
        })
    },

    put: async (alias, url, callback = (payload) => {return {url: url, params: payload}}) => {
        return createAsyncThunk(alias, async (payload, {rejectWithValue}) => {
            let result = null;
            const {url, params} = callback(payload);

            try {
                result = await fetchHelper.put(url, params);
            } catch (err) {
                result = rejectWithValue(err);
            }

            return result;
        })
    },

    delete: async (alias, url, callback = (payload) => {return {url: url, params: payload}}) => {
        return createAsyncThunk(alias, async (payload, {rejectWithValue}) => {
            let result = null;
            const {url, params} = callback(payload);

            try {
                result = await fetchHelper.delete(url, params);
            } catch (err) {
                result = rejectWithValue(err);
            }

            return result;
        })
    },
```
- 청크들을 위 메서드를 이용하여 만들어두고 해당 청크가 작동할때 실행할 리듀서들을 같은 상태 내에서 한번에 생성한다.
- 이 리듀서들의 정보를 가지고 있는 것이 슬라이스가 된다. 이 슬라이스 내부의 리듀서들을 코드에서 가져와서 얼마든지 사용할 수 있게된다.
```js
import { createAsyncThunk } from '@reduxjs/toolkit';
import fetchHelper from '../helpers/FetchHelper';
import reduxHelper from '../helpers/ReduxHelper';

const API_URL = '/professors';

export const getList = await reduxHelper.get("ProfessorSlice/getList", API_URL);
export const getItem = await reduxHelper.get("ProfessorSlice/getItem", API_URL);
export const postItem = await reduxHelper.post("ProfessorSlice/postItem", API_URL);
export const putItem = await reduxHelper.put("ProfessorSlice/putItem", API_URL);
export const deleteItem = await reduxHelper.delete("ProfessorSlice/deleteItem", API_URL);

const ProfessorSlice = reduxHelper.getDefaultSlice("ProfessorSlice", [getList, getItem, postItem, putItem, deleteItem]);

export default ProfessorSlice.reducer;
```

### 📌1-2. 백엔드에서 리스트 가져오기
- `const { loading, status, message, item } = useSelector((state) => state.ProfessorSlice);` 이렇게 상태값들을 가져온다.
- 그리고 useDispatch()를 통해 현재 context에 맞는 액션 함수들을 사용할 수 있도록하는 dispatch함수를 가져온다. (연결, 후처리 해줌)
- const [name, setName] = React.useState("");로 이름 상태값을 지정하고 이름이 변경될 때마다 dispatch(getList({ name }));를 호출하여 ajax를 실행, 그리고 청크 실행에 잇다른 리듀서들을 자동실행하여 ajax의 응답을 반환하게 된다.
- 이때 받아온 값을 내부 상태에 item: null;에 저장하게 된다. 즉 받아와서 상태가 변하는 것이다. 우리는 그 상태값에 연결된 전역객체들을 useSelector로 가져와뒀으므로 여기서 값을 핸들링하면 된다.
- `<tr key={i}>` 이렇게 map으로 반복돌면서 테이블에 리스트를 랜더링할때는 tr값에 고유값을 붙여주어야한다.
- 그리고 name 상태변수는 폼이 제출될때 검색되어있던 교수이름으로 갱신한다.
- if (Array.isArray(item) && item.length > 0)를 통해 만약 item이 있다면 dispatch 자체를 실행하지 않는다. -> 새로고침해도 리스트를 다시 안받아옴
```js
const List = memo(() => {
    // 리덕스 상태값을 가져오기
    const { loading, status, message, item } = useSelector((state) => state.ProfessorSlice);

    // 리덕스 액션함수를 가져오기
    const dispatch = useDispatch();

    // 교수 이름 검색어를 위한 상태값
    const [name, setName] = React.useState("");

    useEffect(() => {
        if (Array.isArray(item) && item.length > 0) {
            return;
        }
        dispatch(getList({ name }));
    }, [name]);

    const hidingErrorImg = (e) => {
        e.target.onerror = null;
        e.target.style.display = "none";
    };

    return (
        <ListContainer>
            <Spinner loading={loading} />
            <ErrorView status={status} message={message} />

            <form className="search-form" onSubmit={(e) => {
                e.preventDefault();
                setName(e.target.name.value);
            }}>
                <input type="search" name="name" placeholder="교수이름 검색..." />
                <Buttons>
                    <button type="submit">검색</button>
                    <Link to="/add">교수추가</Link>
                </Buttons>
            </form>

            <Table>
                <thead>
                    <tr>
                        <th></th>
                        <th>번호</th>
                        <th>이름</th>
                        <th>아이디</th>
                        <th>직급</th>
                        <th>입사일</th>
                        <th>급여</th>
                        <th>보너스</th>
                        <th>이메일</th>
                        <th>연락처</th>
                        <th>상태</th>
                        <th>소속학과</th>
                    </tr>
                </thead>
                <tbody>
                    {item && item.map((v, i) => {
                        return (
                            <tr key={i}>
                                <td>
                                    <img src={v.photo_url} onError={hidingErrorImg} />
                                </td>
                                <td>{v.id}</td>
                                <td>
                                    <Link to={`/view/${v.id}`}>{v.name}</Link>
                                </td>
                                <td>{v.user_id}</td>
                                <td>{v.position}</td>
                                <td>{dayjs(v.hiredate).format("YYYY-MM-DD")}</td>
                                <td>{v.sal?.toLocaleString()}</td>
                                <td>{v.comm?.toLocaleString()}</td>
                                <td>{v.email && <a href={`mailto:${v.email}`}>{v.email}</a>}</td>
                                <td>{v.phone && <a href={`tel:${v.phone}`}>{v.phone}</a>}</td>
                                <td>{v.status}</td>
                                <td>{v.department_id}</td>
                            </tr>
                        );
                    })}
                </tbody>
            </Table>
        </ListContainer>
    );
});

export default List;
```

### 📌1-3. 삭제/ 수정 시에 사용할 슬라이스 수정
- 삭제요청을 보낸다음 페이지를 띄울때 페이지가 한번은 채워져있어야하므로 상태요청에서의 fulfilled 함수를 수정하여 현재 상태에서 내가 삭제한 목록들을 뺀 목록으로 상태를 업데이트 하도록 해야한다.
- 왜냐하면 삭제요청은 백엔드에서 목록을 리턴하지 않으므로 받아온 값으로 엎어치면 item이 null이된다. 그러므로 삭제시에만 fulfilled가 실행될때 상태를 따로 설정해서 넣도록 수정해주어야한다.
- 우선 위에서 .addCase(v.fulfilled, callback[v.fulfilled] || fulfilled) 이렇게 엑스트라 리듀서를 추가했으므로 삭제 3번째 파라미터로 callback 함수를 넣어 삭제 부분만 callback[v.fulfilled]이게 존재하도록 하여 이를 실행하게 한다.
- 이때 v.fulfilled는 실제로 "ProfessorSlice/deleteItem/fulfilled" 이렇게 설정해둔 액션타입문자열이 들어가므로 [deleteItem.fulfilled] 여기도 이렇게 정의하여 "ProfessorSlice/deleteItem/fulfilled": (state, action) => { ... } 이렇게 리듀서함수를 등록할 수 있도록 해두어야한다. 즉 대괄호를 쓰는 것은 액션 타입을 객체의 key로 쓸 수 있게 계산된 속성명으로 넣는 것이다.
- 내가 요청 보낼 때 보냈던 id와 meta.arg가 일치한다.
- Redux Toolkit의 createAsyncThunk로 비동기 액션을 만들 때 dispatch로 넘긴 첫 번째 인자(id 등)가 meta.arg에 자동 저장된다.
- 비동기 작업 중에 요청 시점의 "원본 인자"를 추적해야 할 때가 많기 때문에 이러한 기능을 넣어두었다.
```js
const ProfessorSlice = reduxHelper.getDefaultSlice("ProfessorSlice", [getList, getItem, postItem, putItem, deleteItem], {
    [deleteItem.fulfilled]: (state, {meta, payload}) => {
        const id = meta.arg;

        return {
            ...state,
            loading: false,
            item: state.item.filter(item => item.id !== id)
        };
    }
});
```
- 여기서 삭제나 수정은 파라미터를 body에 넣는 식으로는 잘 하지 않고 관례에 어긋나기 때문에 body에 넣을 params는 비워두고 요청할 url 자체를 path 파라미터로 만들어서 보낸다.
- fetchHelper내에서 get요청만 쿼리스트링으로 합치고 나머지 요청은 전부 body에 넣어서 보내게 되어있음.
```js
export const putItem = await reduxHelper.put("ProfessorSlice/putItem", API_URL, (payload) => {
    const {id, ...data} = payload;
    return {
        url: id ? `${API_URL}/${id}` : API_URL,
        params: data
    }
});

export const deleteItem = await reduxHelper.delete("ProfessorSlice/deleteItem", API_URL, (id) => {
    return {
        url: `${API_URL}/${id}`,
        params: {}
    }
});
```

### 📌1-4. view
- await dispatch(deleteItem(professorItem?.id));에서 ?은 옵셔널 체이닝으로 professorItem이 null이나 undefined일 때 에러가 발생하지 않도록 .id에 "안전하게" 접근하기 위해 ?를 쓴 것이다
```js
const ProfessorView = memo(() => {
    // Path 파라미터 가져오기
    const { id } = useParams();

    // 페이지 이동을 위한 navigate 함수 가져오기
    const navigate = useNavigate();

    // 리덕스 상태값을 가져오기
    const { loading, status, message, item } = useSelector((state) => state.ProfessorSlice);

    // 리덕스 액션함수를 가져오기
    const dispatch = useDispatch();

    // 리덕스 상태값과 id값이 확인되면 필요한 데이터 추출
    const professorItem = useMemo(() => {
        if (!id || !item || Object.keys(item).length === 0) return null;
        return item.find((v) => v.id === parseInt(id));
    }, [item, id]);

    return (
        <ProfessorViewContainer>
            <Spinner loading={loading} />
            <ErrorView status={status} message={message} />

            <TableView>
                <tbody>
                    <tr>
                        <th>번호</th>
                        <td>{professorItem?.id}</td>
                    </tr>
                    <tr>
                        <th>이름</th>
                        <td>{professorItem?.name}</td>
                    </tr>
                    <tr>
                        <th>아이디</th>
                        <td>{professorItem?.user_id}</td>
                    </tr>
                    <tr>
                        <th>직급</th>
                        <td>{professorItem?.position}</td>
                    </tr>
                    <tr>
                        <th>입사일</th>
                        <td>{dayjs(professorItem?.hireDate).format("YYYY-MM-DD")}</td>
                    </tr>
                    <tr>
                        <th>급여(만원)</th>
                        <td>{professorItem?.sal?.toLocaleString()} 만원</td>
                    </tr>
                    <tr>
                        <th>보너스(만원)</th>
                        <td>{professorItem?.comm?.toLocaleString()} 만원</td>
                    </tr>
                    <tr>
                        <th>이메일</th>
                        <td>{professorItem?.email && (<a href={`mailto:${professorItem.email}`}>{professorItem.email}</a>)}</td>
                    </tr>
                    <tr>
                        <th>연락처</th>
                        <td>{professorItem?.phone && (<a href={`tel:${professorItem.phone}`}>{professorItem.phone}</a>)}</td>
                    </tr>
                    <tr>
                        <th>상태</th>
                        <td>{professorItem?.status}</td>
                    </tr>
                    <tr>
                        <th>소속학과</th>
                        <td>{professorItem?.department_id}</td>
                    </tr>
                </tbody>
            </TableView>

            <Buttons>
                <Link to="/">목록보기</Link>
                <Link to="/add">교수추가</Link>
                <Link to={`/edit/${professorItem?.id}`}>수정하기</Link>
                <a
                    href="#"
                    onClick={async (e) => {
                        e.preventDefault();
                        if (window.confirm("정말 삭제하시겠습니까?")) {
                            // 입력, 삭제, 수정시 비동기로 호출해야 함
                            await dispatch(deleteItem(professorItem?.id));
                            // 삭제 후 목록 페이지로 이동
                            alert("교수 정보가 삭제되었습니다.");
                            navigate("/");
                        }
                    }}
                >
                    삭제하기
                </a>
            </Buttons>
        </ProfessorViewContainer>
    );
});

export default ProfessorView;
```

### 📌1-5. 슬라이스 등록에 수정 postItem.fulfilled 수정
- 수정 사항을 상태에 반영하기 위해 수정 이후 백엔드가 돌려준 추가된 값을 item에 넣어서 상태를 업데이트한다.
```js
const ProfessorSlice = reduxHelper.getDefaultSlice("ProfessorSlice", [getList, getItem, postItem, putItem, deleteItem], {
    [postItem.fulfilled]: (state, {meta, payload}) => {
        return {
            ...state,
            loading: false,
            item: [...state.item, payload.item]
        };
    },
    [deleteItem.fulfilled]: (state, {meta, payload}) => {
        const id = meta.arg;

        return {
            ...state,
            loading: false,
            item: state.item.filter(item => item.id !== id)
        };
    }
});
```

### 📌1-6. add 페이지 구현
`<form onSubmit={onHandleSubmit}>` 폼에 submit 이벤트로 화면에 있는 정보를 긁어서 fetchHelper를 통해 body에 담아 보내면 백엔드는 그것을 받아서 업데이트 한 후에 추가한 정보를 다시 돌려준다. 그러면 리듀서가 fulfilled 상태가 되면서 액션함수가 실행되어 돌려받은 추가정보로 상태를 다시 업데이트한다. 페이지가 다시 로드되면 그 업데이트된 상태값을 가져와서 페이지를 다시 채워둔다.
- [dispatch, navigate]: 이 함수들은 실제로는 리액트 훅(useDispatch, useNavigate)에서 반환되는 값이기 때문에, "참조가 변할 수도 있다"고 간주한다. 하여 useCallback의 의존성 배열에 추가한다. 여러 변수가 발생할 수 있기 때문에
- useCallback, useEffect, useMemo의 의존성 배열에는 콜백 내부에서 사용하는 "모든 외부 변수/함수"를 반드시 넣는다! 라는 관례가 있다.
```js
const ProfessorAdd = memo(() => {
    const { loading, status, message } = useSelector((state) => state.ProfessorSlice);
    const navigate = useNavigate();
    const dispatch = useDispatch();

    const onHandleSubmit = useCallback((e) => {
        e.preventDefault();
        const formData = new FormData(e.target);

        (async () => {
            try {
                await dispatch(postItem(formData));
            } catch (err) {
                console.error("Error adding professor:", err);
                alert("교수 추가 중 오류가 발생했습니다.");
                return;
            }

            navigate("/");
        })();
    }, [dispatch, navigate]);

    return (
        <ProfessorAddContainer>
            <Spinner loading={loading} />
            <ErrorView status={status} message={message} />
            <form onSubmit={onHandleSubmit}>
                <TableInput>
                    <tbody>
                        <tr>
                            <th>교수이름</th>
                            <td>
                                <input type="text" name="name" placeholder="교수 이름을 입력하세요" />
                            </td>
                        </tr>
                        <tr>
                            <th>아이디</th>
                            <td>
                                <input type="text" name="user_id" placeholder="아이디를 입력하세요" />
                            </td>
                        </tr>
                        <tr>
                            <th>직급</th>
                            <td>
                                <select name="position">
                                    <option value="교수">교수</option>
                                    <option value="부교수">부교수</option>
                                    <option value="조교수">조교수</option>
                                    <option value="강사">강사</option>
                                </select>
                            </td>
                        </tr>
                        <tr>
                            <th>입사일</th>
                            <td>
                                <input type="date" name="hiredate" placeholder="입사일을 선택하세요" />
                            </td>
                        </tr>
                        <tr>
                            <th>급여(만원)</th>
                            <td>
                                <input type="number" name="sal" placeholder="급여를 입력하세요" />
                            </td>
                        </tr>
                        <tr>
                            <th>보직수당(만원)</th>
                            <td>
                                <input type="number" name="comm" placeholder="보직수당을 입력하세요" />
                            </td>
                        </tr>
                        <tr>
                            <th>이메일</th>
                            <td>
                                <input type="email" name="email" placeholder="이메일을 입력하세요" />
                            </td>
                        </tr>
                        <tr>
                            <th>연락처</th>
                            <td>
                                <input type="tel" name="phone" placeholder="연락처를 입력하세요" />
                            </td>
                        </tr>
                        <tr>
                            <th>상태</th>
                            <td>
                                <select name="status">
                                    <option value="재직">재직</option>
                                    <option value="휴직">휴직</option>
                                    <option value="퇴직">퇴직</option>
                                </select>
                            </td>
                        </tr>
                        <tr>
                            <th>소속학과</th>
                            <td>
                                <select name="department_id">
                                    <option value="101">컴퓨터공학과</option>
                                    <option value="102">전자공학과</option>
                                    <option value="103">기계공학과</option>
                                </select>
                            </td>
                        </tr>
                    </tbody>
                </TableInput>
                <Buttons>
                    <button type="submit">추가</button>
                    <Link to="/">취소</Link>
                </Buttons>
            </form>
        </ProfessorAddContainer>
    );
});

export default ProfessorAdd;
```