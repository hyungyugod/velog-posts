# 📌 0. redux crud 활용 
### 📌 0-1. redux에서 ajax 매커니즘 재정리
- 이전 정리에서 청크와 리듀서에 대해 정리를 모호하게 해서 한번 재정리하려고 한다.
- 우선 리듀서는 슬라이스 내부에 등록하며 슬라이스는 하나의 상태와 그 상태를 변경하는 리듀서들을 관리한다.
- 그리고 슬라이스는 스토어에 저장하여 슬라이스 context를 리액트에서 사용할 수 있도록 등록한다.
- 청크는 redux에서 ajax의 상태를 관리할 수 있도록 ajax 단위를 감싸주는 장치이고 청크로 만들면 redux context는 ajax의 pending, fulfilled, rejected의 상태를 추적 관찰할 수 있게된다.
- 슬라이스에서 상태를 직접 변경하는 함수를 만드려면 reducers에 직접 액션 함수를 등록하고 다른 곳에서 이를 직접 코딩하여 사용하면 된다.
- 만약 변하는 상태를 context에서 관찰하고 그 상황에 맞게 자동으로 액션함수를 발동시키게 하고 싶다면 이는 extraReducers에 상태, 액션함수 형태로 등록한다.
- 등록하면 해당 상태가 바뀌었을때 같이 등록한 액션함수를 redux context를 관리하는 컨트롤타워에서 자동으로 실행해준다.
- 아래의 예에서는 청크로 등록해 관찰할 수 있게된 ajax의 pending, fulfilled, rejected 상태에 변화 즉 해당 상태가 되었을 때 같이 등록한 미리 정의해둔 pending, fulfilled, rejected라는 함수가 실행되는 것이다. 
- 액션함수 이름을 꼭 pending, fulfilled, rejected 이렇게 할 필요없고 원래는 그냥 화살표 함수로 바로 써도 되지만 여기선 그냥 이렇게 하였다.
- 아래는 청크를 만드는 코드이다.
```js
get: async (alias, url, callback = (payload) => {return {url: url, params: payload}}) => {
        return createAsyncThunk(alias, async (payload, {rejectWithValue}) => {
            let result = null;
            const {url, params} = callback(payload);

            try {
                result = await fetchHelper.get(url, params);
            } catch (err) {
                result = rejectWithValue(err);
            }

            return result;
        })
    },
```
- 아래는 청크의 상태변화를 관찰하여 작동하는 액션함수를 extraReducers에 등록하는 코드이다.
```js
getDefaultSlice: (slideName, extraReducers = [], callback = {}, reducers = {}) => {
        return createSlice ({
            name: slideName,
            
            initialState: {
                status: 200,
                message: "OK",
                item: null,
                timstamp: null,
                loading: false,
            },

            reducers: reducers,

            extraReducers: (builder) => {
                extraReducers.forEach((v, i) => {
                    builder.addCase(v.pending, pending)
                            .addCase(v.fulfilled, callback[v.fulfilled] || fulfilled)
                            .addCase(v.rejected, rejected);
                });
            },
        });
    },
```


### 📌 0-2. 수정
- 가운데가 수정 코드이다. 수정의 상태변화를 관찰해서 작동하는 함수를 재정의하는데 이때 굳이 상태값 형식과 같은 객체를 리턴하지 않고 그냥 바꾸고 싶은 상태값만 바꾸어주어도 무방하다.
- 이때 받아온 수정값을 기준으로 기존의 상태에 들어있던 모든 객체를 순회하면서 수정된 사항만 수정된 사항으로 바꾸어준다.
```js
const ProfessorSlice = reduxHelper.getDefaultSlice("ProfessorSlice", [getList, getItem, postItem, putItem, deleteItem], {
    [postItem.fulfilled]: (state, {meta, payload}) => {
        return {
            ...state,
            loading: false,
            item: [...state.item, payload.item]
        };
    },
    [putItem.fulfilled]: (state, {meta, payload}) => {
        const updateItem = payload.item;

        state.item = state.item.map(professor => professor.id === updateItem.id ? updateItem : professor);

        state.loading = false;
    },
    [deleteItem.fulfilled]: (state, {meta, payload}) => {
        const id = meta.arg;

        return {
            ...state,
            loading: false,
            item: state.item.filter(item => item.id !== id)
        };
    }
});
```
- 기존 입력값은 defaultValue={professorItem?.phone}로 defaultValue를 사용해서 입력해두고 폼데이터가 제출되었을때 실행할 함수를 useCallback으로 감싸서 정의해둔다.
- 그리고 이를 onSubmit 이벤트에서 활용한다.
```js
const ProfessorEditContainer = styled.div``;

const ProfessorEdit = memo(() => {
    /** Path 변수값 가져오기 */
    const { id } = useParams();

    /** 페이지 강제 이동 함수 생성 */
    const navigate = useNavigate();

    /** 리덕스 상태값 가져오기 */
    const { loading, status, message, item } = useSelector((state) => state.ProfessorSlice);

    /** 리덕스 관련 함수 생성 */
    const dispatch = useDispatch();

    /** 수정할 항목을 id로 탐색 */
    const professorItem = useMemo(() => {
        if (!item || Object.keys(item).length === 0) return null;
        return item.find((v) => v.id === parseInt(id));
    }, [item, id]);

    const onHandleSubmit = useCallback((e) => {
        e.preventDefault();

        const formData = new FormData(e.target);
        formData.append("id", id); // id를 추가해서 수정 요청으로 처리

        (async () => {
            try {
                await dispatch(putItem(formData));
            } catch (err) {
                console.error("Error adding professor:", err);
                alert("교수 추가 중 오류가 발생했습니다.");
                return;
            }

            navigate(`/view/${id}`);
        })();
    }, [dispatch, id, navigate]);

    return (
        <ProfessorEditContainer>
            <Spinner loading={loading} />
            <ErrorView status={status} message={message} />
            {/* 서버에서 받은 사진 url로 입력폼 받음 => 업로드로 사진 url은 기존값 그대로 유지시킴 */}
            <input type="hidden" name="photo_url" value={professorItem?.photo_url || ""} />

            <TableInput>
                <tbody>
                    <tr>
                        <th>교수이름</th>
                        <td>
                            <input type="text" name="name" placeholder="교수 이름을 입력하세요" defaultValue={professorItem?.name} />
                        </td>
                    </tr>
                    <tr>
                        <th>아이디</th>
                        <td>
                            <input type="text" name="user_id" placeholder="아이디를 입력하세요" defaultValue={professorItem?.user_id} />
                        </td>
                    </tr>
                    <tr>
                        <th>직급</th>
                        <td>
                            <select name="position" defaultValue={professorItem?.position}>
                                <option value="조교수">조교수</option>
                                <option value="부교수">부교수</option>
                                <option value="정교수">정교수</option>
                            </select>
                        </td>
                    </tr>
                    <tr>
                        <th>입사일자</th>
                        <td>
                            <input type="date" name="hiredate" placeholder="입사일을 선택하세요" defaultValue={dayjs(professorItem?.hiredate).format("YYYY-MM-DD")} />
                        </td>
                    </tr>
                    <tr>
                        <th>급여(만원)</th>
                        <td>
                            <input type="number" name="sal" placeholder="급여를 입력하세요" defaultValue={professorItem?.sal} />
                        </td>
                    </tr>
                    <tr>
                        <th>보직수당(만원)</th>
                        <td>
                            <input type="number" name="comm" placeholder="보직수당을 입력하세요" defaultValue={professorItem?.comm} />
                        </td>
                    </tr>
                    <tr>
                        <th>이메일</th>
                        <td>
                            <input type="email" name="email" placeholder="이메일을 입력하세요" defaultValue={professorItem?.email} />
                        </td>
                    </tr>
                    <tr>
                        <th>연락처</th>
                        <td>
                            <input type="tel" name="phone" placeholder="연락처를 입력하세요" defaultValue={professorItem?.phone} />
                        </td>
                    </tr>
                    <tr>
                        <th>재직여부</th>
                        <td>
                            <select name="status" defaultValue={professorItem?.status}>
                                <option value="재직">재직</option>
                                <option value="퇴직">퇴직</option>
                                <option value="휴직">휴직</option>
                            </select>
                        </td>
                    </tr>
                    <tr>
                        <th>학과명</th>
                        <td>
                            {/* 학과 정보를 위해서는 department를 위한 Slice를 추가하고, 셀렉트로부터 받아야 데이터도 도전적으로 구성해야 함 */}
                            <select name="department_id" defaultValue={professorItem?.department_id}>
                                <option value="201">컴퓨터공학과</option>
                                <option value="202">멀티미디어학과</option>
                                <option value="203">정보통신공학과</option>
                                <option value="103">기계공학과</option>
                            </select>
                        </td>
                    </tr>
                </tbody>
            </TableInput>
            <Buttons>
                <button type="submit">수정하기</button>
                <Link to="/"><button type="button">취소</button></Link>
            </Buttons>
        </ProfessorEditContainer>
    );
});

export default ProfessorEdit;
```

# 📌 1. dashboard
### 📌 1-1. 발생했던 import 관련 문제
- redux context를 활용하기 위해서 두개의 훅을 가져와야하고 슬라이스 파일에 정의해둔 청크를 가져와야한다.
- 청크도 redux에서 상태변화를 관찰하는 대상이니 슬라이스 파일에 포함하는 것이 논리적으로 어색하지는 않은 것 같다.
```js
import { useDispatch, useSelector } from "react-redux";
import {getList} from "../slices/TitanicSlice";
```

### 📌 1-2. graph 중간 집계 단계
- 공통적으로 item이 이미 존재하면 가져오지 않고 존재하지 않으면 백엔드에서 정보를 받아온다.
- reduce는 {}가 acc로 들어가고 여기에 item이 cur로 들어가서 연산을하고 acc를 리턴하면 이걸 다시 받아서 acc로 쓰고 거기에 다음 item을 cur로 넣은 뒤에 반복하는 구조이다.
- 결과적으로 item 내부의 내용들이 전부 각각 내부 함수의 처리를 거쳐서 {}여기 즉 acc에 쌓여서 리턴되게 된다.
- 여기서는 탑승자의 연령대별 명수를 담은 acc가 리턴되고 정렬된 연령대와 연령대별 사람수가 담긴 배열이 각각 keys와 values로 const result = {keys, values}; 이와같이 리턴된다.
```js
// 탑승자 구성
const Graph1 = memo(() => {
  const {loading, status, message, item} = useSelector((state) => state.TitanicSlice);

  const dispatch = useDispatch();

  useEffect(() => {
    if(item && Array.isArray(item) && item.length > 0) {
      return;
    }
    dispatch(getList());
  }, [dispatch]);

  const {keys, values} = useMemo(() => {
    if (!item){
      return {keys: null, values: null};
    }

    const ageData = item.reduce((acc, cur) => {
      const ageLevel = `${parseInt(cur.age / 10) * 10}대`;

      if(acc[ageLevel] == undefined) {
        acc[ageLevel] = 1;
      } else {
        acc[ageLevel]++;
      }

      return acc;
    }, {});

    const keys = Object.keys(ageData).sort();

    const values = keys.map(v => ageData[v]);

    const result = {keys, values};

    return result;
  }, [item]);

  return (
    <Graph1Container>
      <Spinner loading={loading} />
      <ErrorView status={status} message={message} />

      {keys && <div>keys: {JSON.stringify(keys)}</div>}
      {values && <div>values: {JSON.stringify(values)}</div>}
    </Graph1Container>
  );
});
```
- 두번째 그래프도 같은 로직인데 이번에는 item에서 연령대별로 생존자 사망자를 boolean 값인 survived을 사용하여 나타낸다.
- 이후 연령, 생존자 수, 사망자수를 각각 배열에 담아 리턴한다. (map을 활용해 아래에서 만들어진 객체를 분리하여 또 배열을 만든다.)
```js
const {keys, values} = useMemo(() => {
    if (!item){
      return {keys: [], survived: [], dead: []};
    }

    const ageData = item.reduce((acc, cur) => {
      const ageLevel = `${parseInt(cur.age / 10) * 10}대`;

      if(acc[ageLevel] == undefined) {
        acc[ageLevel] = {survived: 0, dead: 0};
      }

      if (cur.survived) {
        acc[ageLevel].survived++;
      } else {
        acc[ageLevel].dead++;
      }

      return acc;
    }, {});
```
- 세번째 그래프는 탑승자의 성별 정보만 담아서 리턴하는 구조이다.
```js
const sex = useMemo(() => {
    if (!item){
      return [0, 0];
    }

    const maleData = item.reduce((acc, cur) => {
      acc[cur.sex == 'male' ? 0 : 1]++;
      return acc;
    }, [0, 0]);

    return maleData;
    }, {});
```
- 4번째 그래프는 성별별 생존 여부를 담아 리턴한다.
```js
/** 성별 생존 여부 */
  const { survived, dead } = useMemo(() => {
    if (!item) {
      return { survived: [0, 0], dead: [0, 0] };
    }

    const maleData = item.reduce((acc, cur) => {
      const idx = cur.sex == 'male' ? 0 : 1;
      const key = cur.survived ? 'survived' : 'dead';
      acc[key][idx]++;
      return acc;
    }, { survived: [0, 0], dead: [0, 0] });

    return maleData;
  }, [item]);
```
- 5번째 그래프는 객실 등급별 탑승객수, 생존, 사망을 담아서 리턴한다.
```js
 /** 객실등급(1,2,3)별 탑승객, 생존, 사망 집계 */
  const {passengers, survived, dead} = useMemo(() => {
    if (!item) {
      return {passengers: [0, 0, 0], survived: [0, 0, 0], dead: [0, 0, 0]};
    }

    const pclassData = item.reduce((acc, cur) => {
      const pclass = cur.pclass;
      acc.passengers[pclass-1]++;

      if (cur.survived) {
        acc.survived[pclass-1]++;
      } else {
        acc.dead[pclass-1]++;
      }

      return acc;
    }, {passengers: [0, 0, 0], survived: [0, 0, 0], dead: [0, 0, 0]});

    return pclassData;
  }, [item]);
```
- 아래는 그래프 구조이다. CategoryScale부터 Legend까지는 웬만하면 넣고 추가로 그래프에 맞는 element만 BarElement이렇게 추가한다.
- 이후 추가한 모든 요소를 Chart에 등록하여 사용할 수 있게 한다.
```js
import {
  Chart,
  CategoryScale,
  LinearScale,
  Title,
  Tooltip,
  Legend,
  BarElement,
} from 'chart.js';

import { Bar } from 'react-chartjs-2';

// Chart.js에서 import한 Chart컴포넌트 내에서 import 요소들을 등록한다.
Chart.register(CategoryScale, LinearScale, Title, Tooltip, Legend, BarElement);
```
- 앞서 만들었던 key를 일반 라벨에 넣고 데이터들을 데이터셋의 data에 넣은 후 설정만 조정하면 표를 완성할 수 있다.
```js
 return (
    <Graph2Container>
      <Spinner loading={loading} />
      <ErrorView status={status} message={message} />

      {keys && survived && dead && (
        <Bar
          data={{
            labels: keys, // x축
            datasets: [
              {
                label: "생존",
                data: survived,
                backgroundColor: "rgba(255, 99, 132, 0.5)",
                borderColor: "rgba(255, 99, 132, 1)",
                borderWidth: 1,
              },
              {
                label: "사망",
                data: dead,
                backgroundColor: "rgba(54, 162, 235, 0.5)",
                borderColor: "rgba(54, 162, 235, 1)",
                borderWidth: 1,
              },
            ],
          }}
          options={{
            responsive: true,
            maintainAspectRatio: false, // 세로 높이를 조절할 수 있다 (false일 경우 부모요소 높이에 맞춤)
            plugins: {
              legend: {
                position: "bottom", // 범례의 위치
              },
              title: {
                // 제목 설정
                display: true,
                text: "연령별 생존 현황",
                font: {
                  size: 18,
                  color: "#000",
                },
              },
            },
          }}
        />
      )}
    </Graph2Container>
  );
});
```