# 다익스트라 알고리즘 (Dijkstra's Algorithm)
- 최선의 경로를 찾기 위한 알고리즘이다. 
- 너비 우선 탐색이 경로 자체만을 고려한다면 다익스트라 알고리즘은 경로에 부과된 가중치까지 고려한다.
- 기본적으로는 노선별로 가장 짧은 길을 모두 알아봐서 선택된 길만 모아 전체의 가장 짧은 길을 찾는다.


## 1. 기본 용어들
- 가중 그래프 : 가중치를 가지는 그래프를 의미한다.
- 균일 그래프 : 가중치가 없는 그래프를 의미한다.
- 벨만-포드 알고리즘 : 음의 가중치를 고려하지 못하는 다익스트라 알고리즘과 다르게 음의 가중치를 고려할 수 있다.

## 2. 다익스트라 알고리즘의 구조
### 2-1. 초기화
- 시작 정점의 거리를 0으로 설정.
- 나머지 정점은 무한(∞) 으로 설정. (나중에 min계산의 해야하므로로)

### 2-2. 출발점에서 제일 가까운 정점 찾기
- 출발점과 직접 연결된 정점들의 거리를 갱신.
- 가장 거리가 짧은 정점을 선택.
- 해당 정점을 거쳐 갈 수 있는 경로 갱신

### 2-3. 선택한 정점을 거쳐 다른 정점으로 가는 거리 계산
- dist[v]=min(dist[v],dist[u]+cost(u,v)) min 연산으로 (출발점 - 정점 거리를 업데이트) 
- 기존 거리(dist[v])보다 새로운 거리(dist[u] + cost(u, v))가 짧으면 업데이트.
- 가장 짧은 경로를 가진 정점 선택 → 위 과정 반복

### 2-4. 이어서
- 방문하지 않은 정점 중 최단 거리를 가진 정점 선택. (최단거리를 가진 정점부터 차례대로 검사, 너무 긴 길은 지워가면서 경우를 줄여감.)
- 위 과정을 반복하며 점진적으로 최단 경로 확정.
- 시간 복잡도 O((V+E)log(V))

### 2-5. 시간 복잡도 관련 정리
- 각 정점의 초기 거리 설정 O(V)
- 거리 배열을 초기화하고, 시작 정점의 거리를 0으로 설정.
- 우선순위 큐에서 최단 거리 정점 선택 O(VlogV))

- 모든 정점을 한 번씩 큐에서 꺼내야 하므로 최대 V번 수행.
- 힙에서 최소 원소를 추출하는 연산이므로 각 추출 연산의 시간 복잡도는 O(logV).
- 인접한 정점들의 거리 갱신 O(ElogV))

- 각 정점이 인접한 정점들을 탐색하면서, 우선순위 큐에 새로운 거리 정보를 업데이트해야 한다.
- 인접한 간선의 개수는 최대 E번 갱신이 이루어질 수 있음.
- 힙에서의 업데이트(삽입/삭제)는 O(logV) 시간이 걸림.

## 3. 간선의 가중치가 음수인 경우
- 다익스트라 알고리즘은 너비 우선 탐색처럼 가까운 길을 우선 탐색하지만 깊이 우선 탐색처럼 짧은 길을 갱신하면서 쭉 내려가면서 탐색하는데 만약 그보다 지나온 층에 출발점으로부터의 길이가 더 짧은 정점이 있으면 돌아가서 다시 탐색한다.
- 하여 한번 지나온 길은 무조건 최단거리이다. (만약 a에서 b를 거쳐 c까지 갔다가 a에서 d로 갔다면 a-d의 거리가 적어도 a-b의 거리가 a-d의 거리보다는 길었다는 뜻이기 때문)
- 그런데 간선에 음수가 할당되어있으면 이 규칙이 깨지므로 알고리즘이 깨지게 된다.
- 벨만 포드 알고리즘은 모든 간선을 반복적으로 탐색하므로 상관이 없다. 다만(O(log(VE)이다.)) 

## 4. 코드로 구현
- 해시테이블 3개를 사용하여 구현한다. (그래프, 가격, 부모 해시테이블)
- 최소 heap(우선순위 큐) 구조는 완전 이진 트리의 구조로서 가장 작은 값이 상위 노드에 위치하여 대기열에서 가장 작은 것부터 뽑아낼 수 있다. 구조를 회전하여 안정적으로 유지한다.

```python
import heapq

def dijkstra(graph, start):
    # 가격 테이블 (초기화: 무한대)
    costs = {node: float('inf') for node in graph}
    costs[start] = 0  # 시작점의 비용은 0

    # 부모 테이블 (경로 추적)
    parents = {node: None for node in graph}

    # 우선순위 큐 (힙) 사용 -> (비용, 노드) 저장
    heap = [(0, start)]
    
    while heap:
        current_cost, node = heapq.heappop(heap)  # 힙 내부에서 자동으로 가장 작은 값을 가진 노드를 선택하고 힙을 재정렬한다.
        
        for neighbor, weight in graph[node].items():
            new_cost = current_cost + weight  # 새로운 거리 계산

            if new_cost < costs[neighbor]:  # 기존보다 더 짧은 거리라면 갱신
                costs[neighbor] = new_cost
                parents[neighbor] = node    # 부모 코드 갱신 바로 직전 부모를 저장해둠으로서 타고타서 이동경로를 알 수 있다.
                heapq.heappush(heap, (new_cost, neighbor))  # 힙에 추가
                
    return costs, parents

# 그래프 (Hash Table 1)
graph = {
    'A': {'B': 4, 'C': 1},
    'B': {'D': 5},
    'C': {'B': 2, 'D': 8},
    'D': {}
}

# 실행
start_node = 'A'
costs, parents = dijkstra(graph, start_node)

# 결과 출력
print("최단 거리 테이블:", costs)
print("부모 테이블:", parents)
```