# 📌 1. numpy 기본
### 📌 1-1 넘파이 벡터 생성(numpy.ndarray객체)
```py
# 같은 타입으로 생성해야한다.
a = np.array([1, 2, 3, 4, 5])
b = np.array(["fly","sky"])

# 빈벡터 생성
x = np.empty(3)
x[0] = 1;

# 뽑아보기 -> 만약 비어있는 값이 있으면 메모리주소가 나옴 e-100은 10의 -100승
for i in range(3):
  print(x[i])
```

### 📌 1-2. 배열 생성과 채우기
```py
# 배열 생성하면서 동시에 채우기
a = np.arange(5) # 이러면 5칸 연속 숫자 [0 1 2 3 4]
b = np.arange(1,5,2) # range 함수와 동일하다. [1 3]

# 균일 간격의 숫자 배열 생성
c = np.linspace(0, 1, 5) # 0부터 1까지 5개원소를 채워서 반환[0. 0.25 0.5  0.75 1.] -> 기본적으로 마지막 값 포함 endpoint=False를 주면 마지막값 포함 안됨

# 함수, 값을 반복해서 벡터 만들기
d = np.repeat(1,5) # 1을 5번 반복 [1 1 1 1 1]
e = np.repeat([1,2,3], 4) # 각 숫자 4번씩 반복 [1 1 1 1 2 2 2 2 3 3 3 3] 
f = np.repeat([1,2,3],[1,2,3]) # 각 숫자 반복횟수 커스텀 [1 2 2 3 3 3]

# 벡터 전체를 반복
g = np.tile([1,2],5) # 1을 5번 반복 [1 2 1 2 1 2 1 2 1 2] -> 타일까는 것에서 유래 
```

### 📌 1-3. 백터 재생성과 슬라이싱
```py
# 벡터 길이 연산
g = np.tile([1,2],5)
len(g) # 10

g.shape # shape 속성은 해당 배열의 각 차원 크기를 반환한다.

g.size # 전체 요소 수

# 벡터 슬라이싱에 연산자 사용
g[0:5:2] # 일반적인 슬라이싱
g[g > 1] # 1보다 큰 g의 원소들만 모아 배열로 반환

# 연산자로 홀수번째 요소 출력
a = np.arange(30)
# b = a[np.arange(1,11) % 2 == 1] # np.arange(1,11) → [1 2 3 4 5 6 7 8 9 10] (길이 10) // % 2 == 1 → [ True False True False True False True False True False] (길이 10) 이 불리언 배열은 길이가 10뿐인데, a는 길이가 30임 → 모양 불일치로 IndexError.
# 두칸씩 건너뛰기
a = np.arange(30)
b = a[1::2] 
print(b)

# 마스킹하기 (boolean 배열이 a와 길이가 같아야함.)
mask = np.arange(30) % 2 == 1 # boolean 배열
c = a[mask]
```

### 📌 1-4. 필터링을 통한 벡터변경
```py
# 조건을 만족하는 위치 탐색
# array는 ndarray 즉 n-demension array의 줄임말이고 동일한 자료형을 연속적으로 배치하여 빠른 벡터화 연산을 수행할 수 있는 numpy의 배열구조이다.
a = np.array([1,3,5,7,8,10])
result = a > 7
print(result) # [False False False False  True  True]

result = np.where(a > 7)
print(result) # (array([4, 5]),) -> 차원별로 만족하는 위치의 인덱스를 반환함.
```

### 📌 1-5. 다양한 벡터연산 함수들
```py
# 다양한 벡터 함수
a = np.array([1,3,5,7,8,10])
sum_a = np.sum(a)
mean_a = np.mean(a)
std_a = np.std(a)
var_a = np.var(a)
min_a = np.min(a)
max_a = np.max(a)

# np.nan 은 빈칸을 명시적으로 나타낼때 사용하며 np.isnan()으로 검사한다.
# np.nan이 아닌 값들만을 집계하기 위한 nanmean같은 무시함수도 있다.
np.nanmean(a)
a_filtered = a[~np.isnan(a)] # 이를 활용하여 nan이 아닌 값들만 따로 저장할 수 있다.

# np.concatenate(), np.column_stack(), np.row_stack()
a = np.array([1,2,3])
b = np.array([4,5,6])
c = np.concatenate([a,b]) # [1 2 3 4 5 6]

d = np.column_stack([a,b]) # [[1 4]
                          #  [2 5]
                          #  [3 6]]
e = np.row_stack([a,b]) # [[1,2,3],
                        # [4,5,6]]

# np.resize()
a = np.array([[1,2,3],[4,5,6]]) # 2행 3열인 행렬
b = np.resize(a, (6,2)) # 6행 2열로 resize인데 원본에 있는 원소가 6까지 밖에 없으므로 다쓰면 재사용한다.
```

# 📌 2. 문제 풀이
### 📌 2-1. 모든 원소에 5 더한 배열 반환하기
```py
a = np.array([1,2,3,4,5])
a + 5
```

### 📌 2-2. 홀수번째 요소만 추출하기
```py
a = np.array([12,21,35,48,5])
a[::2]
```

### 📌 2-3. 최대값찾기
```py
a = np.array([12,21,35,48,5])
np.max(a)
```

### 📌 2-4. 중복제거 -> ndarray로 반환
```py
a = np.array([1,2,3,2,4,5,4,6])
np.unique(a)
```

### 📌 2-5. 번갈아 포함된 배열 만들기 -> 구조분해할당 사용
```py
a = np.array([1,2,3,4,5])
b = np.array([6,7,8,9])
c = np.empty(a.size + b.size, dtype = a.dtype)

c[0::2] = a
c[1::2] = b
c
```

### 📌 2-6. NumPy는 배열 간 연산에서, 길이가 같으면 같은 인덱스 원소끼리 연산을 함.
- a[:-1]는 마지막 원소 제외
```py
a = np.array([1,2,3,4,5])
b = np.array([6,7,8,9])
c = a[:-1] + b
print(c)
```