# 📌 0. 정보처리기사 필기 도타비 1회
### 📌 1. 분산 시스템을 위한 마스터-슬레이브(Master-Slave) 아키텍처
- 마스터-슬레이브 아키텍처: 하나의 마스터(Master)가 전체 시스템의 "조정자(coordinator)" 역할을 수행하고, 여러 개의 슬레이브(Slave)가 실제 작업(worker)이나 데이터 수집 등 특정 역할을 분담하여 수행하는 중앙집중적 통제 구조를 의미함.
- 마스터 프로세스는 일반적으로 연산, 통신, 조정을 책임진다. 즉 시스템 전체의 흐름을 제어한다
- 슬레이브 프로세스는 데이터 수집 기능을 수행할 수 있다.
- 이때 슬레이브 프로세스는 마스터로부터 지시받은 작업만 수행하며 보통 복잡한 판단을 하지 않고, 지정된 기능(연산, 데이터 수집, 로깅 등)만 수행한다.
- 이후 결과나 수집 데이터를 마스터에게 보고한다.

### 📌 2. HIPO는 상향식 소프트웨어 개발을 위한 문서화 도구이다?
- **HIPO(Hierarchical Input Process Output)**는 “입력–처리–출력”의 계층적 구조로 소프트웨어의 전체 설계와 흐름을 문서화하는 도구이자 방법론이다.
- HIPO의 본질은 문서화 도구이면서, 전체 시스템을 계층적으로(위에서 아래로) 설계한다는 점에 있다.
- HIPO는 상향식이 아니라 하향식 개발 방법론에 기반을 둔다.
- 즉, 시스템 전체를 먼저 설계하고, 이를 점점 세부적 모듈/프로세스로 분해하는 방식이다.
- 보통 계층도 그릴때 위에부터 그리잖아~

### 📌 3. CASE(Computer-Aided Software Engineering)의 원천 기술
- 일괄처리 기술이라는 건 없다. 일괄처리 기술은 여러 데이터를 모아서 한번에 처리하는 전통적 처리방식이다.
- CASE는 자동화, 모델링, 협업, 반복적 지원이 핵심이라, 단순히 데이터 처리 방식을 의미하는 일괄처리와 구분된다.
- 구조적 기법(Structured Technique): 소프트웨어 개발을 구조적으로, 즉 단계별로 체계적으로 진행하게 하는 방법론
- 프로토타이핑 기술(Prototyping Technique): 실제 완제품이 아닌 **시제품(Prototype, 프로토타입)**을 빠르게 만들어 사용자의 요구사항을 파악하거나, 시스템의 동작 방식을 미리 검증할 수 있도록 하는 기법.
- 정보 저장소 기술(Repository Technology): CASE 도구에서 사용되는 각종 정보(모델, 코드, 설계문서, 테스트 결과 등)를 중앙 저장소에 통합해서 버전관리, 공유, 추적, 일관성을 자동으로 관리할 수 있게 함.

### 📌 4. 소프트웨어 품질분석 동적도구
- 동적 분석 도구: 소프트웨어 실행 중 **실제 동작(실행 시간, 런타임)**을 관찰하여 결함, 성능 저하, 자원 누수, 보안 취약점 등을 찾아내는 도구
- Valgrind (대표적 오픈소스 동적 분석 도구): Valgrind는 리눅스/유닉스 환경에서 사용되는메모리 오류/누수 탐지, 스레드 오류, 캐시 성능 분석 등을 지원하는 대표적인 동적 분석 프레임워크
- valance라는 것도 동적도구에 나오긴 했다.

| 도구명                                | 주요 언어                      | 주요 기능                         | 특징/설명                                                     |
| ---------------------------------- | -------------------------- | ----------------------------- | --------------------------------------------------------- |
| **SonarQube**                      | Java, C, C++, JS, Python 등 | 코드 품질, 버그, 취약점, 코드스멜, 커버리지    | 기업/오픈소스에서 가장 널리 사용, 웹 기반 대시보드 제공                          |
| **Lint (lint, cpplint, flake8 등)** | C, C++, Python 등           | 문법 오류, 스타일 검사                 | 언어별 다양한 파생: `lint`(C), `cpplint`(C++), `flake8`(Python) 등 |
| **FindBugs / SpotBugs**            | Java                       | 버그 패턴, 잠재 오류, 나쁜 코드 구조        | Java 프로젝트 표준 도구. SpotBugs는 FindBugs의 확장판                  |
| **Checkstyle**                     | Java                       | 코드 스타일, 규칙 위반, 일관성            | Java 코드의 코드 스타일 표준화 도구                                    |
| **PMD**                            | Java, Apex 등               | 코드 결함, 스타일, 중복, 불필요 코드        | 커스텀 룰 설정 가능, Java에서 자주 사용                                 |
| **Coverity**                       | C, C++, Java 등             | 버그, 결함, 보안 취약점                | 상용 도구, 대규모 산업용으로 널리 사용                                    |
| **Clang Static Analyzer**          | C, C++                     | 잠재 버그, 메모리 누수, 논리 오류          | LLVM 기반, 오픈소스, 고급 분석 기능                                   |
| **ESLint**                         | JavaScript, TypeScript     | 문법 오류, 스타일, Best Practice 검사  | JS/TS 개발에서 표준 도구, IDE 연동                                  |
| **PyLint**                         | Python                     | 문법, 스타일, Best Practice, 잠재 오류 | Python 대표적 정적 분석 도구                                       |
| **ReSharper**                      | C#, VB.NET 등               | 코드 품질, 리팩토링, 규칙 검사            | Visual Studio 확장, MS 환경에 강함                               |
| **FxCop**                          | .NET                       | 코드 표준, 규칙 위반                  | Microsoft .NET 환경 전용                                      |
| **RuboCop**                        | Ruby                       | 스타일, 코드 규칙, Best Practice     | Ruby 언어에서 표준 도구                                           |

### 📌 5. 버블정렬 pass 1
- pass 1이란, 배열의 맨 앞에서부터 맨 끝까지 인접 원소끼리 차례로 비교해서 필요하면 자리(값)를 **서로 교환(swap)**하는 작업을 “처음으로 한 바퀴 도는 것”을 의미
- pass 1이 끝나면 가장 큰 값(8)이 배열의 맨 끝으로 이동한다

### 📌 6. 최악의 경우 검색 효율이 가장 나쁜 트리구조
- 균형인수는 높이차를 의미한다.
- 이때 편향 허용, 균형 조건(흑높이)이 있음 이 말은 편향은 있을 수 있지만, 각 경로(루트→리프)마다 ‘검정 노드 수’는 항상 같아야 한다는 의미이다.

| 트리 구조           | 최악의 경우 트리 높이 | 최악의 경우 검색 시간 복잡도 | 균형 유지 여부      | 비고                           |
| --------------- | ------------ | ---------------- | ------------- | ---------------------------- |
| **이진탐색트리(BST)** | O(n)         | O(n)             | ❌ (불균형 가능)    | 편향 트리(예: 오름차순 삽입) 시, 리스트와 동일 |
| **AVL 트리**      | O(log n)     | O(log n)         | ✅ (엄격한 균형 유지) | 모든 노드의 균형인수 -1, 0, 1         |
| **2-3 트리**      | O(log n)     | O(log n)         | ✅ (강한 균형 유지)  | 노드 당 2\~3개 자식, 항상 균형         |
| **레드-블랙 트리**    | O(log n)     | O(log n)         | ✅ (느슨한 균형 유지) | 편향 허용, 균형 조건(흑높이)이 있음        |


### 📌 7. 힙정렬에 대하여
1. 입력 배열을 완전 이진트리로 변환 → 힙 구조(Heapify)로 만든다.
2. 루트 노드(최댓값/최솟값)를 꺼내 배열 끝에 저장
3. 남은 노드로 다시 힙을 재정렬(Heapify)
4. 이 과정을 원소가 다 정렬될 때까지 반복
- 힙구조 구성(Heapify): O(n)
- 각 원소를 꺼낼 때마다 O(log n)
- n개 원소를 꺼내야 하므로, 전체 시간복잡도는 O(n log n)
- 힙정렬의 최악 수행 시간도 O(n log n)

### 📌 8. 관계대수 표현
```
π_이름 (σ학과＝’교육'(학생))
```
- 위의 식은 아래와 같다.
- SELECT 이름 FROM 학생 WHERE 학과＝'교육；

### 📌 9. sql에서 INTERSECT 문
- INTERSECT: 두 개의 SELECT 쿼리 결과에서 “공통으로 존재하는 행(레코드)”만을 추출하는 SQL 연산자
- 집합론에서의 ‘교집합’ 개념과 동일하며 두 SELECT 결과에 모두 등장하는 **동일한 값(전체 컬럼 기준)**만 반환한다.

### 📌 10. 타임스탬프기법
- 타임스탬프기법: 동시성 제어를 위한 직렬화 기법으로 트랜잭션 간의 처리 순서를 미리 정하는 방법

### 📌 11. 정규화(normalization)
- 데이터베이스 설계에서 “중복을 최소화하고(배제하고), 삽입, 삭제, 갱신 이상의 발생을 방지하기 위해 릴레이션을 “작고 의미 있는 관계로 분해”하는 것이 목적

### 📌 12. 내용결합도
-  모듈이 다른 모듈의 내부 구현(내용)까지 직접 접근하거나 수정하는 경우 발생하는, 가장 높은(즉, 최악의) 결합도를 의미한다.
-  모듈 A가 모듈 B의 “내부 변수, 내부 함수, 자료구조” 등에 직접 접근·수정하는 경우 → B의 내부 변경이 곧바로 A에 영향을 주고, 독립성이 완전히 깨짐
-  참조란 접근이나 수정을 의미하지 않는다.