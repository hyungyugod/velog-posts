# 📌 0. 정보처리기사 2023 2회 기출오답
### 📌 0-1. UML의 구성요소 
- 사물(Thing), 관계(Relation) 다이어그램(Diagram)

### 📌 0-2. 요구사항 분석 프로세스
- 요구사항 협상: 요구 사항 우선순위들을 이해관계자들이 의견을 나누어 최종 요구사항을 만든다.
- 요구사항 명세는 요구사항 분석 이후의 작업으로 분석한 내용을 문서화하는 단계이다. 즉 분석 이후의 단계이므로 당연히 분석 프로세스에 포함되지 않는다.

### 📌 0-3. 요구사항 분류
- 시스템 요구사항은 프로그래밍 언어만 사용하지 않고 기술적이고 정확한 표현을 사용한다. 

### 📌 0-4. CASE도구는 조작법이 어렵다.
- IDE는 CASE 도구의 한 종류(구현 단계 특화)로 볼 수 있다. 하지만 보통 “CASE 도구”라고 하면 분석설계테스트까지 지원하는 더 통합적이고 자동화된 도구를 의미한다.
- 소프트웨어 개발의 여러 단계를 한꺼번에 지원하여 기능이 너무 많고 자동화, 문서화, 코드 생성 등 다양한 기능을 세밀하게 설정하려다 보니 처음 사용하는 사람이 직관적으로 다루기 어렵다.
- 또한 전문적인 지식이 필요하고 표준이나 방법론이 다양하다.

### 📌 0-5. TP-monitor (Transaction Processing Monitor), 그 외 미들웨어
- 여러 사용자가 동시에 데이터베이스에 접근할 때(온라인환경 등), 트랜잭션(거래, 작업)이 안전하고 효율적으로 처리되도록 중간에서 관리·감독하는 소프트웨어이다.
- 같이 나온 다른 미들웨어들
- RFC(Remote Function Call): 다른 컴퓨터(원격지)에 있는 함수(프로그램)를 마치 내 컴퓨터에 있는 것처럼 호출할 수 있게 해주는 통신 방식. 응용 프로그램의 프로시저(어떤 일을 처리하도록 미리 만들어둔 작은 프로그램 조각 - 거의 함수랑 같은 의미로 쓰임)를 이용하여 원격 프로시저를 호출하기 위함.
- MOM(Message Oriented Middleware):시스템들(서버, 프로그램 등)이 **메시지(데이터 덩어리)**를 주고받을 수 있도록 중간에서 전달·저장·관리해주는 미들웨어, 서로 직접 연결되지 않아도 “메시지 큐”를 통해 비동기적으로 메시지 전달
- WAS(Web Application Server): 웹에서 사용자가 보내는 요청(예: 로그인, 데이터 저장 등)을 처리하는 애플리케이션(웹 프로그램) 실행 환경. 톰캣(Tomcat)처럼 웹 요청을 받아 JSP/Servlet 구동, Spring, Django 등 웹 애플리케이션 실행하는 전용 서버를 의미한다.

### 📌 0-6. 개체-관계 다이어그램(ERD, Entity-Relationship Diagram)
- 정보공학 방법론에서 데이터 구조를 설계할 때 활용한다.
- 데이터 구조를 시각적으로 설계: Entity(개체), Relationship(관계), Attribute(속성) 세 가지 요소로 구성됨.

### 📌 0-7. 소프트웨어 설계방식
- process oriented(절차지향) - “어떤 작업을 어떤 순서로 할지”에 집중, 데이터와 데이터 처리 과정을 분리해서 생각
- object oriented(객체지향) - 데이터와 그 데이터를 처리하는 방법(함수)을 하나의 객체로 묶어서 생각, 프로그램을 “여러 개의 객체”가 서로 협력해서 완성
- top-down: 하향식 방법 (전체 → 부분)
- bottom-up: 상향식 방법 (부분 → 전체)

### 📌 0-8. 유스케이스 다이어그램의 구성요소
- 시스템범위: 관련 유스케이스를 사각형으로 묶어서 표현한다.
- 주 액터: 상호작용을 통해 이득(benefit)을 얻는 대상 -> 즉 자신이 필요로 하는 목적이나 결과를 얻는 사람, 조직, 다른 시스템 등이다.

### 📌 0-9. CASE도구의 원천기술 - 프로토타이핑
- 프로토타이핑 : 데이터 흐름이나 더미 데이터로 테스트들을 미리 해볼 수 있게 한다.

### 📌 0-10. 응집도 낮은 순 (우논시절통순기)
- 우연적 응집 (Coincidental Cohesion) - 관련 없는 작업들이 그냥 한 모듈에 모여 있음
- 논리적 응집 (Logical Cohesion) - 논리적으로 비슷하지만, 서로 다른 기능(예: 입력/출력/에러처리 등)이 한 모듈에 모임
- 시간적 응집 (Temporal Cohesion) - 특정 시점(초기화, 종료 등)에 같이 실행되는 작업들이 모여 있음
- 절차적 응집 (Procedural Cohesion) - 특정 순서대로 차례로 수행되는 기능들이 한 모듈에 모임
- 통신적 응집 (Communicational Cohesion) - 같은 데이터를 사용하거나, 같은 자료를 접근하는 기능들이 한 모듈에 모임
- 순차적 응집 (Sequential Cohesion) - 앞 작업의 결과를 다음 작업이 바로 사용하는, 데이터가 순차적으로 흐르는 기능들이 한 모듈에 모임
- 기능적 응집 (Functional Cohesion) - 오직 하나의 기능만을 수행하는 작업들로만 구성 (최고)

### 📌 0-11. 럼바우 분석절차에서 객체 모델링은 정보 모델링으로도 불린다.
- 객체 모델링은 시스템에서 다루는 정보를 구조화(객체, 속성, 관계)하기 때문에 정보 모델링이라고도 불린다.

### 📌 0-12. Migration
- 데이터, 시스템, 또는 프로그램을 한 환경(시스템, 플랫폼, 데이터베이스, 서버 등)에서 다른 환경으로 옮기는 작업을 뜻한다.
- 데이터 마이그레이션(DB), 시스템 마이그레이션(예: Windows 서버 → Linux 서버), 애플리케이션 마이그레이션 등이 있음.

### 📌 0-13. 블랙박스 테스트 - Equivalence Partitioning 
- 입력 조건에 유효한 값과 무효한 값을 균등하게 하여 테스트한다 이 말은 아래와 같다.
- “유효한 값(정상 입력)과 무효한 값(오류 입력)을 각각 그룹으로 나눠 그룹별로 대표값만 골라서 테스트하는 기법이다.”

### 📌 0-14 Backtracking 알고리즘, Approximation(근사 알고리즘)
- Backtracking은 탐색 도중 조건에 맞지 않으면 즉시 되돌아가서(Backtrack) 다른 경로를 시도하는 알고리즘이다.
- 모든 경우를 다 시도하는 게 아니라, 중간에 불필요한 경로는 빨리 포기(가지치기)해서 시간을 아낄 수 있음
- Approximation(근사 알고리즘): 최적(가장 좋은) 해답을 구하기 어렵거나(시간이 오래 걸릴 때), 완벽한 정답 대신, 비교적 괜찮은(근사적인) 해답을 빠르고 쉽게 찾는 알고리즘

### 📌 0-15. 인접 행렬 표현에서는 세로축(행)이 출발 노드, 가로축(열)이 도착 노드에 해당한다.
- 만약 3행에 해당하는 값을 묻는다면 3행에서 출발해서 도착한 번호만 1을 입력하고 나머지는 0을 입력해서 답을 내면된다.

### 📌 0-16. 블랙박스 테스트와 화이트박스 테스트
- 블랙박스 테스트

| 테스트 기법                           | 간단 설명                                   |
| -------------------------------- | --------------------------------------- |
| 동등분할(Equivalence Partitioning)   | 입력값을 비슷한 그룹(동등 클래스)으로 나누고, 대표값만 테스트     |
| 경계값 분석(Boundary Value Analysis)  | 입력값의 경계(최대/최소 등) 주변을 집중적으로 테스트          |
| 원인-효과 그래프(Cause-Effect Graphing) | 입력(원인)과 결과(효과) 관계를 그래프로 나타내어 테스트 케이스 도출 |
| 의사결정 테이블(Decision Table) 테스트     | 다양한 조건 조합과 결과를 표로 정리해 테스트               |
| 상태전이(State Transition) 테스트       | 상태 변화에 따른 동작(상태별 전이)을 테스트               |
| 오류 예측(Error Guessing)            | 경험을 바탕으로 자주 발생하는 오류 상황을 예측해 테스트         |
| 비교(Comparison) 테스트               | 동일한 입력값을 여러 시스템/버전에 넣고 결과를 비교해 올바름을 확인  |

- 화이트박스 테스트

| 테스트 기법                | 간단 설명                                 |
| --------------------- | ------------------------------------- |
| 문장(Statement) 커버리지    | 모든 코드의 문장이 한 번씩 실행되도록 테스트             |
| 분기(Branch) 커버리지       | if, switch 등 분기문의 모든 경로가 실행되도록 테스트    |
| 조건(Condition) 커버리지    | 각 조건식의 참/거짓이 모두 한 번씩 실행되도록 테스트        |
| 경로(Path) 커버리지         | 프로그램의 모든 가능한 경로를 따라 테스트               |
| 루프(Loop) 테스트          | 반복문이 0회, 1회, 여러 번 등 다양한 횟수로 동작하도록 테스트 |
| 데이터 흐름(Data Flow) 테스트 | 변수의 정의(할당)와 사용(참조)이 올바르게 연결되는지 테스트    |

### 📌 0-17. 소프트웨어 테스트 커버리지
- 커버리지(Coverage): 프로그램(코드)의 전체 중에서 테스트가 실제로 실행된 부분의 비율

| 커버리지 종류                       | 간단 설명                                                  | 예시(코드 기준)                       |
| ----------------------------- | ------------------------------------------------------ | ------------------------------- |
| 문장(Statement) 커버리지            | 코드의 \*\*각 문장(줄)\*\*이 최소 한 번 이상 실행되었는지 측정               | 모든 코드 줄이 실제 실행되는지               |
| 조건(Condition) 커버리지            | **조건식**(if, while 등)의 **각 조건**이 true/false 모두 실행됐는지 측정 | `if (A && B)`에서 A, B 각각 참/거짓 실행 |
| 결정/분기(Decision) 커버리지 (Branch) | if, switch 등 **분기문의 모든 경로**(true/false)가 실행됐는지 측정      | `if`에서 참, 거짓 모두 실행되는지           |

### 📌 0-18. CMMI(역량 성숙도 모델 통합, Capability Maturity Model Integration)에서의 프로세스 성숙도 5단계

| 단계(레벨)                       | 한글명         | 주요 특징(간단 설명)                                   |
| ---------------------------- | ----------- | ---------------------------------------------- |
| 1단계 (Initial)                | **초기(비정형)** | 프로세스가 **즉흥적, 비체계적**임. 개인 역량에 따라 결과가 달라짐        |
| 2단계 (Managed)                | **관리(반복)**  | 기본적인 **프로젝트 관리**가 적용됨. 계획, 진행, 통제가 가능함         |
| 3단계 (Defined)                | **정의(표준화)** | **조직 전체에 표준 프로세스**가 정립되고 문서화됨. 모든 프로젝트가 표준 따라감 |
| 4단계 (Quantitatively Managed) | **정량적 관리**  | 프로세스와 품질을 **수치(데이터)로 측정·통제**함. 문제를 수치로 파악 가능   |
| 5단계 (Optimizing)             | **최적화(혁신)** | **지속적 개선, 혁신**을 통해 프로세스를 꾸준히 최적화함. 조직 문화로 정착   |

### 📌 0-19. Cyclomatic Complexity(순환 복잡도)
- 프로그램의 복잡도(테스트 난이도, 유지보수 난이도 등)를 제어 흐름 그래프의 독립적인 경로 수로 측정한 값
- M = E - N + 2P, 단순 코드라면 분기 개수 + 1
- 이는 화이트 박스 테스트의 기초경로 검사를 통해 점검한다.


### 📌 0-20. 형상관리로 인한 가시성 확보
- 형상관리로 인해 개발 산출물의 변경 이력과 상태가 명확히 드러나서, 전체 진행 상황을 쉽게 파악(가시성 확보)할 수 있다.

### 📌 0-21. Clearing House
- Clearing House란 여러 기관 또는 시스템 간의 거래를 중립적으로 중개·정산·처리해주는 중개 기관(또는 시스템)
- 또한 이는 멜론 처럼 음악에 키를 부여, 관리하고 라이센스를 발급하는 것처럼 저작권을 보호해준다.

### 📌 0-22. 다치종속
- 한 속성에 의해 결정되는 값의 집합이 한 테이블에 너무 많을 때
- 아래에서 철수에 의해 너무많은 값의 집합이 결정될 수 있다.

| Student | Subject | Club |
| ------- | ------- | ---- |
| 철수      | 수학      | 축구   |
| 철수      | 영어      | 축구   |
| 철수      | 수학      | 합창   |
| 철수      | 영어      | 합창   |

### 📌 0-23. 데이터베이스의 키 중 유일성을 만족하지 않아도 되는 키는
- 외래키이다.
- 외래키는 참조 무결성만 지키면 되고, 여러 행이 같은 값을 가져도 되므로 유일성을 만족할 필요가 없다.
- 참조 무결성: 외래키 값이 참조하는 기본키 값은 반드시 존재해야 함
- 유일성: 유일성을 가진 속성은 각 행(row)이 서로 다른 값을 가짐 즉 “한 테이블에서 어떤 속성(컬럼, 키)의 값이 절대로 중복되지 않는 성질”을 뜻함.

### 📌 0-24. 관계해석과 관계 대수
- 관계 대수는 어떻게 얻을 것인지 명시하는 절차적 언어이다. (project하여 특정 열을 가져와라)
- 관계 해석은 무엇을 가져올 지만 딱 제시한다. 비절차적 언어이다. 
- 관계 대수에는 일반집합 연산자랑 관계 대수 고유(나머지) 연산이있다.
- 선택(Selection, σ): 조건을 만족하는 튜플(행)만 선택
- 투영(Projection, π): 원하는 속성(열)만 선택
- 조인(Join, ⨝): 두 릴레이션을 조건에 따라 연결해서 새 릴레이션 생성
- 디비전(Division, ÷):특정 조건을 모두 만족하는 튜플만 추출 (특정 상황에 사용)
- 위는 고유 연산
- 아래는 일반연산이다.
- 합집합(Union, ∪), 차집합(Difference, -), 교집합(Intersection, ∩), 카티션 프로덕트(Cartesian Product, ×)

| 구분        | 관계 대수(Relational Algebra)      | 관계 해석(Relational Calculus)    |
| --------- | ------------------------------ | ----------------------------- |
| **질의 방식** | **절차적(명령형)**: 어떻게 처리할지 명시      | **비절차적(선언형)**: 원하는 조건만 명시     |
| **표현**    | 연산자(σ, π, ∪ 등)로 연산 과정을 단계별로 표현 | 수학적 논리(조건)로 “무엇”을 추출할지 표현     |
| **종류**    | 선택, 투영, 조인, 합집합, 차집합, 곱, 디비전 등 | 튜플 관계 해석(TRC), 도메인 관계 해석(DRC) |
| **예시**    | “이렇게 이렇게 하면 얻어진다”              | “이 조건을 만족하는 결과를 보여줘”          |

| 연산자                 | 기호/표현                        | 간단 설명               | 예시 (설명)  |                                |
| ------------------- | ---------------------------- | ------------------- | -------- | ------------------------------ |
| **선택(Selection)**   | 조건문 (WHERE 역할)               | 조건을 만족하는 튜플만 추출     | \`{ t    | t ∈ 학생 ∧ t.학년 = 2 }\`          |
| **투영(Projection)**  | 필요한 속성만 명시                   | 원하는 속성(열)만 선택       | \`{ t.이름 | t ∈ 학생 ∧ t.학년 = 2 }\`          |
| **존재(Existential)** | `∃` (존재한다)                   | 어떤 값이 “존재”하는지 조건 표현 | \`{ t    | ∃ s (s ∈ 수강 ∧ s.학번 = t.학번) }\` |
| **전체(Universal)**   | `∀` (모든)                     | 모든 값이 조건을 만족할 때     | \`{ t    | ∀ s (조건) }\`                   |
| **논리 연산자**          | ∧(and), ∨(or), ¬(not), →(if) | 논리적인 조건 연결          | \`{ t    | t.학년 = 2 ∧ t.성별 = '여' }\`      |

### 📌 0-25. 개념 스키마는 모든 사용자의 입장에서 필요한 데이터베이스의 구조를 정의한다.
- 개념 스키마는 데이터베이스 전체의 논리적 구조와 제약조건을 정의한 설계도(모델)이다.
- 이는 각 사용자들이 필요로 하는 모든 db구조를 한번에 표현한다.
- DBA에 의해 구성되며 데이터베이스 당 하나만 존재한다.

### 📌 0-26. 분석된 요구사항에서 업무처리의 실체와 그들의 관계를 설계
- 개념 모델링

### 📌 0-27. 삽입이상, 갱신이상, 삭제이상
- 삽입이상: 학생을 추가하려면 강의 정보도 반드시 입력해야 할 때
- 갱신이상: 같은 학생 정보가 여러 군데에 중복되어, 한 곳만 수정하면 데이터가 불일치
- 삭제이상: 학생의 마지막 강의 정보를 삭제하면, 그 학생 정보까지 모두 사라지는 경우

| 이상 종류    | 간단 설명                                                        |
| -------- | ------------------------------------------------------------ |
| **삽입이상** | 새로운 데이터를 넣을 때, 불필요한 정보까지 같이 입력해야 하거나, 일부 정보를 아예 못 넣는 문제      |
| **갱신이상** | 데이터 일부만 수정해야 하는데, 여러 군데를 일일이 다 수정해야 하거나, 일부만 바뀌어서 데이터 불일치 발생 |
| **삭제이상** | 데이터를 삭제할 때, 필요했던 다른 정보까지 같이 사라져버리는 문제                        |


### 📌 0-28. OSI 7계층에서 네트워크상의 단말기 간 신뢰성있는 데이터 송수신을 제공할 수 있도록 지원하는 계층
- Network Layer: “어떤 길로 갈지”를 결정할 뿐, 신뢰성 있는 송수신 보장은 X
- IP 프로토콜
- 네트워크 계층은 “패킷을 목적지까지 잘 전달”하는 “길 안내자”
- Transport Layer: 종단 간(End-to-End) 데이터의 “신뢰성 있는” 전달 - 전송 제어, 흐름제어, 오류제어, 재전송 등을 담당 즉, 프로그램(프로세스)끼리 안전한 데이터 통신 보장
- TCP, UDP
- 전송계층은 “단말기끼리, 프로그램끼리 데이터를 정확하고 신뢰성 있게 주고받는 것까지 책임”

### 📌 0-29. 운영체제(OS)에서 메모리(공간) 할당 방식

| 용어        | 한글 명칭        | 간단 설명                              |
| --------- | ------------ | ---------------------------------- |
| First Fit | **최초 적합 기법** | 빈 공간(홀)을 앞에서부터 차례로 찾아, 처음 맞는 곳에 할당 |
| Best Fit  | **최적 적합 기법** | 빈 공간 중에서 요청 크기에 “가장 딱 맞는” 곳에 할당    |
| Worst Fit | **최악 적합 기법** | 빈 공간 중에서 가장 큰 곳(남는 게 많은 곳)에 할당     |

### 📌 0-30. 라우팅 프로토콜
- 라우팅 프로토콜: 라우터(네트워크 장비)들이 서로 연결 경로(라우팅 경로)를 자동으로 계산·관리하기 위해 사용하는 통신 규칙(프로토콜)
- OSPF(Open Shortest Path First): 최단경로, 링크 상태 기반의 내부 라우팅 프로토콜, 대규모 네트워크에 적합
- BGP(Border Gateway Protocol): 인터넷에서 사용, AS(자율 시스템) 간의 외부 라우팅 프로토콜
- IGRP(Interior Gateway Routing Protocol): 벡터거리 기반의 시스코(Cisco) 독자 내부 라우팅 프로토콜
- RIP(Routing Information Protocol): 벡터거리 기반의 대표적인 내부 라우팅 프로토콜(단순, 오래됨) -> 15홉 미만
- 하나의 네트위크 장비(라우터 등)를 거치는 과정 1홉 a->b = 1홉 

### 📌 0-31. ^과 &
- &은 한 문자에 붙는 단항연산자로 쓰이면 &a처럼 a의 주소를 나타내게 된다. (우선 순위가 높다.) 만약 이항 연산자라면 비트 and 연산자로 쓰인다.
- ^은 비트연산에서 배타적 논리합을 의미한다.

### 📌 0-32. stdlib.h

| 함수명         | 간단 설명                            |
| ----------- | -------------------------------- |
| `malloc()`  | 동적 메모리 할당(메모리 공간 생성)             |
| `calloc()`  | 동적 메모리 할당(초기화까지 수행)              |
| `realloc()` | 동적 메모리 재할당(크기 변경)                |
| `free()`    | 동적 메모리 해제                        |
| `atoi()`    | 문자열을 정수(int)로 변환                 |
| `atof()`    | 문자열을 실수(double)로 변환              |
| `atol()`    | 문자열을 long 타입으로 변환                |
| `strtod()`  | 문자열을 double로 변환                  |
| `strtol()`  | 문자열을 long(또는 다른 진수)로 변환          |
| `strtoul()` | 문자열을 unsigned long(또는 다른 진수)로 변환 |
| `rand()`    | 난수(무작위 숫자) 생성                    |
| `srand()`   | 난수 시드(seed) 초기화                  |
| `abs()`     | 정수의 절대값 반환                       |
| `exit()`    | 프로그램 강제 종료                       |
| `system()`  | 외부 프로그램이나 명령어 실행                 |
| `bsearch()` | 이진 탐색(정렬된 배열에서 빠른 검색)            |
| `qsort()`   | 퀵 정렬(배열 정렬)                      |
| `div()`     | 두 정수 나누기(몫과 나머지를 모두 구조체로 반환)     |

### 📌 0-33. IPv4
- 인터넷에서 컴퓨터나 장치의 주소(아이피)를 지정하는 4번째 버전의 인터넷 프로토콜(Internet Protocol version 4)
- 8비트씩 4부분으로 구성되어있다.
- 각자리는 10진수로 표현한다.
- ABCDE의 5개의 클래스가 있다.

### 📌 0-34. C언어 구조체
- 구조체 선언에서 비트필드는 가장 큰 정수 타입 크기가 기준이 된다.
- 모든 비트필드들이 한 기본 단위에 모여서 할당됨 이때 최대한 그 기본 단위 안에 묶여서 메모리에 할당됨.
- 기본 단위가 뭐냐에 따라서 패딩의 크기가 달라질 수 있음.
- 만약 기준 단위의 크기를 벗어나면 기준 단위만큼 크기가 확장됨.
- 기본단위 = 묶음단위 = 가장 큰 '정수타입' 단위
- char = 1바이트(8bit) short = 2바이트(16bit), int = 4바이트(32bit)이다.
- 패딩(정렬) 규칙: 대부분의 컴파일러(특히 4, 8바이트 정렬을 하는 경우)는 구조체의 전체 크기를 가장 큰 멤버 타입(여기선 int, 4바이트)의 배수로 맞춘다.
```c
struct MixedBitField {
    unsigned char a : 3;
    unsigned char b : 5;

    unsigned short c : 4;
    unsigned short d : 7;
    unsigned short e : 5;

    unsigned int f : 10;
    unsigned int g : 22;
};
```
- 위처럼 많을 경우 실제론
- 비트필드 멤버가 서로 다른 타입이면 각 타입별로 새 기본 단위로 시작한다.
- 같은 타입이 연달아 있으면 한 기본 단위에 최대한 묶인다.
- 정리하면 비트필드는 타입이 다르면 서로 다른 단위에서 시작하고, 구조체의 전체 크기는 가장 큰 타입의 배수로 패딩이 추가되어 4바이트가 된다.

### 📌 0-35. if(fn(a)&&fn(b))
- if(fn(a)&&fn(b))에서 처음 연산이 거짓이면 &&연산의 특성상 뒤의 함수는 실행되지도 않음.
- 즉 둘다 무언가를 출력하고 있다면 앞의 함수의 출력값만 출력됨.

### 📌 0-36. 대칭키와 비대칭키
- 비대칭키는 개인적이라 본인이 비밀키, 공개키 발급 그래서 키의 개수는 사람 수만큼임. 
- 대칭키는 관계마다 키를 따로 설정해야하므로 관계수만큼 키 수가 늘어남. 즉 관리해야할 키 수가 많음

| 분류          | 방식(이름)             | 대표 알고리즘                                     | 특징/설명                                      |
| ----------- | ------------------ | ------------------------------------------- | ------------------------------------------ |
| **대칭키 방식**  | 비밀키 암호(Symmetric)  | DES, 3DES, AES, SEED, RC4, RC5, RC6         | 암호화·복호화에 **하나의 키(공통 키)** 사용, 빠름, 키 분배가 어려움 |
| **비대칭키 방식** | 공개키 암호(Asymmetric) | RSA, DSA, ECC, ElGamal, DH (Diffie-Hellman) | **공개키와 개인키** 두 개의 키 사용, 느리지만 키 분배가 쉬움      |

### 📌 0-37. MQTT
- **MQTT(Message Queuing Telemetry Transport)**는 IoT와 같이 짧고 간단한 메세지를 자주 보내도록 대역폭이 제한되어 개발된 발행구독 기반의 경량 메세지 전송 프로토콜이다.

### 📌 0-37. sniffing
- 네트워크 상에 전송되는 트래픽을 훔쳐보는 행위로 자신에게 와야할 정보가 아닌 정보를 자신이 받도록 가로채는 것
- snooping(스누핑): 더 넓은 범위의 감시/엿보기/관찰을 뜻함 네트워크뿐 아니라 시스템 내부, 캐시, 문서, 장치 접근 등 다양한 분야에서 “누가, 어떻게 접근하는지”를 감시·모니터링하는 개념
- 네트워크 패킷을 몰래 캡처·도청하는 건 sniffing을 타겟한 선지이다.

### 📌 0-38. 접근통제 모델
- 누가(주체, 사용자) 어떤 자원(객체, 데이터, 시스템 등)에 어떻게(권한, 허용/차단 등) 접근할 수 있는지 정책적으로 결정하고 관리하는 체계
- 주요 접근 통제 모델 종류

| 모델명                                   | 한글 명칭       | 설명(핵심)                                    | 대표 예시           |
| ------------------------------------- | ----------- | ----------------------------------------- | --------------- |
| DAC (Discretionary Access Control)    | 임의적 접근 통제   | **소유자(Owner)가 권한을 마음대로 부여/회수**할 수 있는 방식   | 파일시스템 권한 관리     |
| MAC (Mandatory Access Control)        | 강제적 접근 통제   | **관리자/정책**이 강제적으로 등급, 규칙에 따라 접근을 제어       | 군사, 정부 시스템      |
| RBAC (Role-Based Access Control)      | 역할 기반 접근 통제 | **역할(Role)에 따라 권한을 부여/관리**하는 방식           | 기업 정보시스템, ERP 등 |
| ABAC (Attribute-Based Access Control) | 속성 기반 접근 통제 | **주체/객체의 속성(attribute)과 정책에 따라 접근 권한 결정** | 클라우드, 유연한 환경    |

| 모델명                        | 설명                                | 대표 특징                       |
| -------------------------- | --------------------------------- | --------------------------- |
| **벨-라파둘라(Bell-LaPadula)**  | **기밀성** 강조 (읽기, 쓰기 권한 계층화)        | "No Read Up, No Write Down" |
| **비바(Biba) 모델**            | **무결성** 강조 (수정·입력에 대한 엄격한 통제)     | "No Write Up, No Read Down" |
| **클락-윌슨(Clark-Wilson) 모델** | **상업 환경 무결성**에 초점, 정제된 데이터만 처리 허용 | 트랜잭션을 통한 무결성 유지             |

### 📌 0-39. TCP Wrapper
- TCP Wrapper는 리눅스/유닉스에서 외부 네트워크 접근을 hosts.allow/hosts.deny 파일로 제어하는 호스트 기반 접근제어 도구이다.
- 리눅스 같은 운영체제의 ip서버에서 네트워크 접근을 필터링하기 위해 사용한다.
- ip서버: “IP 주소를 갖고 동작하는 서버” 또는 “네트워크(인터넷)에 연결된 서버(서비스)”를 의미
- TCP(Transmission Control Protocol): 네트워크에서 신뢰성 있게 데이터를 전송하는 대표적인 프로토콜 OSI 7계층의 **전송계층(4계층)**에서 동작

### 📌 0-40. ZigBee, Grayware
- 저속, 저비용, 저전력의 무선망을 위한 기술로 주로 무선 개인 영역 통신망(wpan) 기반의 홈 네트워크 및 무선 센서망에서 사용되는 기술을 의미한다.
- 무선 개인 영역 통신망(WPAN, Wireless Personal Area Network): 사람 주변(수 m~수십 m 이내)의 소형 무선 장치끼리 연결하는 네트워크 (예시: 스마트홈 기기, 리모컨, 무선 센서 등)
- Grayware(그레이웨어): 명백한 악성코드(바이러스, 트로이목마, 랜섬웨어 등)는 아니지만, 사용자에게 불편을 주거나 원치 않는 행위를 하는 소프트웨어를 의미한다.
- 정상과 악성의 ‘회색지대(Gray Zone)’에 있어서 그레이웨어(Grayware)라고 부름.
- 대표적인 예시는 아래와 같다.
- 애드웨어(Adware): 광고를 과도하게 띄워서 사용자를 불편하게 하는 프로그램
- 스파이웨어(Spyware): 사용자 동의 없이 정보 수집, 추적
- 툴바, 번들 프로그램: 원치 않게 설치되어 시스템을 느리게 하거나, 불필요한 기능 추가


### 📌 0-41. RSA (Rivest–Shamir–Adleman)
- 공개키 기반의 서명 알고리즘 중 가장먼저 실용화되고 보편화되어있다.
- 아주 큰 소수 두 개를 곱해서 “공개키/개인키 쌍”을 만듦 소인수분해(큰 수를 소수 두 개로 쪼개는 것)의 어려움을 이용해 암호 강도(보안성)를 확보
- SSL, 공동인증서에 이용된다
- SSL(보안 소켓 계층, Secure Sockets Layer): 인터넷에서 데이터를 암호화해 안전하게 주고받기 위한 프로토콜 (현재는 SSL의 발전형인 TLS가 더 널리 사용됨)


### 📌 0-42. 방화벽이 알려지지 않은 공격에 약한 이유
- *방화벽(Firewall)**은 네트워크에서 들어오거나 나가는 **데이터(패킷)의 “특정 규칙(정책)”**을 기준으로 허용/차단을 결정하는 보안 장치이다.
- 이 “규칙”이란 IP 주소, 포트 번호, 프로토콜, 그리고 이미 알려진(정의된) 공격 패턴 등 “사전에 설정된 것”을 기반으로 동작함.
- 하여 알려지지 않은 패턴에는 당연히 취약할 수밖에 없음

### 📌 0-43. sqoop
- 하둡과 관계형 데이터 베이스간에 데이터를 전송할 수 있도록 설계된 도구

### 📌 0-44. BN (Intent-Based Networking)
- **IBN(의도 기반 네트워킹, Intent-Based Networking)**은 관리자의 “의도(Intent)”—즉, 네트워크에 바라는 목표/정책을 사람이 아닌 시스템이 자동으로 해석, 적용, 운영하는 네트워크 기술을 의미한다.
- 같이 나온 선지 
- ISDN (Integrated Services Digital Network): 종합 정보 통신망 즉, 음성, 데이터, 영상 등 다양한 서비스를 하나의 디지털 회선으로 전송할 수 있게 한 통신 기술
- HSM(Hardware Security Module): 암호화, 인증, 전자서명 등 보안 작업을 전용 하드웨어(물리적 장치)에서 처리하는 보안 장치를 의미