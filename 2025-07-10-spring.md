# 📌 0. 보스 클론 프로젝트
### 📌 0-1. 로그인 한 상황에서도 로그인 페이지에 접근 가능한 문제
- 로그인 페이지에 접근했는데 이미 세션이 있으면 메인페이지로 리다이렉트한다. 
- 즉 이미 로그인이 되어있으면 메인페이지로 이동시켜준다.
```java
/**
 * 로그인 페이지로 이동, referer가 있다면 해당 URL로 리다이렉트할 수 있도록 처리
 * @param request
 * @param model
 * @return
 */
@GetMapping("/login")
public String loginPage(HttpServletRequest request, Model model) throws Exception {
    if (request.getSession().getAttribute("memberInfo") != null) {
        return "redirect:/main"; // 이미 로그인된 경우 메인 페이지로
    }

    String referrer = request.getHeader("Referer"); // 대문자 "Referer" 사용이 맞음
    if (referrer == null || referrer.contains("/login")) {
    referrer = "/main"; // 기본값 명시
    }   

    model.addAttribute("referrer", referrer); // 리다이렉트할 URL을 모델에 추가
    return "login/index";
}
```

### 📌 0-2. api 문제 자동화 -> swagger
- 원래는 REST API의 명세(Documentation) 표준 포맷이자, 명세 문서를 자동 생성해주는 도구였으나 지금은 Swagger라는 이름이 "OpenAPI Specification(OAS)"으로 바뀌면서 REST API의 구조, 파라미터, 응답, 예외 등 모든 것을 문서화하는 표준 포맷으로 자리잡았다.
- implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.6.0' 라이브러리를 추가하면 스프링에서 기능을 사용할 수 있고 Swagger UI와 **OpenAPI 3.x 명세 문서(JSON/YAML)**를 자동 생성해준다.
- Swagger(OpenAPI) 어노테이션은 API 코드에 문서화 정보를 직접 추가할 수 있도록 해준다.
- @Tag: API 그룹/도메인별 묶음
- @Operation: 개별 API 메서드(설명, summary, 파라미터 등)
- @ApiResponses: 응답 코드별 설명
```java
@Controller
@RequiredArgsConstructor
@Tag(name = "로그인 컨트롤러", description = "로그인 페이지를 표시하고, 이미 로그인된 사용자를 메인 페이지로 리다이렉트하는 기능을 제공한다.")
public class LoginController {
    /**
     * 로그인 페이지로 이동, referer가 있다면 해당 URL로 리다이렉트할 수 있도록 처리
     * @param request HttpServletRequest 객체
     * @param model Model 객체
     * @return 로그인 페이지 뷰 이름
     */
    @Operation(
        summary = "로그인 페이지 조회",
        description = "로그인 페이지를 표시합니다. 이미 로그인된 사용자는 메인 페이지로 리다이렉트된다. " +
                    "이전 페이지 정보(Referer)가 있으면 로그인 후 해당 페이지로 돌아갈 수 있도록 처리한다.",
        parameters = {
            @Parameter(name = "request", description = "클라이언트가 요청한 HTTP 요청 객체", required = true, hidden = true),
            @Parameter(name = "model", description = "뷰에 데이터를 전달하기 위한 모델 객체", required = true, hidden = true)
        }
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "로그인 페이지 정상 표시"),
        @ApiResponse(responseCode = "302", description = "이미 로그인된 사용자, 메인 페이지로 리다이렉트"),
        @ApiResponse(responseCode = "500", description = "서버 내부 오류")
    })
    @GetMapping("/login")
    public String loginPage(
        HttpServletRequest request, Model model) throws Exception {
        if (request.getSession().getAttribute("memberInfo") != null) {
            return "redirect:/main"; // 이미 로그인된 경우 메인 페이지로
        }

        String referrer = request.getHeader("Referer"); // 대문자 "Referer" 사용이 맞음
        if (referrer == null || referrer.contains("/login")) {
        referrer = "/main"; // 기본값 명시
        }   

        model.addAttribute("referrer", referrer); // 리다이렉트할 URL을 모델에 추가
        return "login/index";
    }
}
```

### 📌 0-3. 기존 비밀번호 초기화 로직 분리 
- 원래 컨트롤러는 검증과 서비스 호출, 응답 반환 정도만 해야하지만 너무 많은 비즈니스 로직을 컨트롤러에서 담당하고 있어 우선 해당 컨트롤러를 분리하기로 했다.
- 그러는 과정에서 managers를 만들고 기존에 흐트러져있던 클래스들을 패키지로 묶어내었다.
- 이때 자동으로 패키지 import가 수정되지만 다른 사람의 컴퓨터에서 해당 경로를 못찾으면 한번 그 파일을 직접 찾아가 클릭하면 바로 오류가 해결된다.
```java
@PostMapping("/api/reset-pw")
    public ResponseEntity<ResponseDTO> resetPw(@RequestBody Map<String, String> params) throws Exception {
        String email = params.get("email");
        ResponseDTO response;

        // 이메일 빈값 검사
        if (email == null || email.trim().isEmpty()) {
            throw new InvalidFormatException("이메일을 입력하세요.");
        }

        // 이메일 형식 검사
        String emailPattern = "^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$";
        if (!Pattern.matches(emailPattern, email)) {
            throw new InvalidFormatException("올바른 이메일 형식이 아닙니다.");
        }

        // 입력된 이메일로 User 객체 생성
        User inputUser = new User();
        inputUser.setUserEmail(email);

        // 회원 정보 조회
        User user = loginService.findByEmail(inputUser);
        
        if (user == null) {
            throw new UnauthorizedException("입력하신 정보와 일치하는 계정이 없습니다. 다시 시도해주시거나 사이트 운영자에게 문의해주세요.");
        }

        // 임시 비밀번호 생성(8자리: 영문, 숫자, 특수문자 포함)
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        String nums = "0123456789";
        SecureRandom  rnd = new SecureRandom();
        String newPassword = null;

        while (true) {
            StringBuilder sb = new StringBuilder();
            // 영문자 1개 무조건 포함
            sb.append(chars.charAt(rnd.nextInt(chars.length())));
            // 숫자 1개 무조건 포함
            sb.append(nums.charAt(rnd.nextInt(nums.length())));

            // 나머지 6자리는 영문/숫자 섞어서 랜덤 생성
            String all = chars + nums;
            for (int i = 0; i < 6; i++) {
                sb.append(all.charAt(rnd.nextInt(all.length())));
            }

            // 섞기 (영문, 숫자가 1번째, 2번째에 몰리지 않게)
            List<Character> pwChars = new ArrayList<>();

            for (char c : sb.toString().toCharArray()) pwChars.add(c);

            Collections.shuffle(pwChars);

            StringBuilder resultPw = new StringBuilder();

            for (char c : pwChars) resultPw.append(c);

            newPassword = resultPw.toString();

            // 정규식 조건 체크
            if (newPassword.matches("^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]{8}$")) {
                break;
            }
            // 조건 불만족 시 while로 다시 생성
        }

        if (newPassword == null || newPassword.isEmpty()) {
            throw new InternalServerErrorException("임시 비밀번호 생성에 실패했습니다. 다시 시도해주세요.");
        }

        // 임시 비밀번호로 비밀번호 재설정
        loginService.resetPw(user.getUserId(), newPassword);

        // 메일 템플릿 파일 직접 읽기
        String template;
        
        ClassPathResource resource = new ClassPathResource("mail_templates/reset_pw.html"); // mail_templates 디렉토리에서 템플릿 파일을 읽어옴        
        byte[] bytes = Files.readAllBytes(resource.getFile().toPath()); // 파일을 바이트 배열로 읽음
        template = new String(bytes, "UTF-8");

        // 템플릿 치환
        template = template.replace("{{userEmail}}", user.getUserEmail());
        template = template.replace("{{password}}", newPassword);

        // 메일 발송
        String subject = "[클론보스]" + user.getUserEmail() + "님의 비밀번호가 재설정되었습니다.";
        
        MimeMessage message = javaMailSender.createMimeMessage();
        MimeMessageHelper helper = new MimeMessageHelper(message, false, "UTF-8");
        helper.setSubject(subject); // 메일 제목 설정
        helper.setText(template, true); // 메일 내용 설정

        helper.setTo(user.getUserEmail()); // 사용자의 이메일 주소로 발송
        helper.setFrom(new InternetAddress(senderEmail, senderName, "UTF-8"));  // 미리 설정해둔 이메일과 이름 세팅
        javaMailSender.send(message); // 메일 발송

        // 응답 결과 생성
        response = ResponseDTO.builder()
                .success(true)
                .message("임시 비밀번호가 이메일로 발송되었습니다.")
                .timestamp(LocalDateTime.now())
                .build();
        return ResponseEntity.ok(response);
    }
```
- 위의 컨트롤러를 아래처럼 정리하였다.
```java
@PostMapping("/api/reset-pw")
    public ResponseEntity<ResponseDTO> resetPw(@RequestBody Map<String, String> params) throws Exception {
        String email = params.get("email");
        ResponseDTO response;

        // 이메일 빈값 검사
        if (email == null || email.trim().isEmpty()) {
            throw new InvalidFormatException("이메일을 입력하세요.");
        }

        // 이메일 형식 검사
        String emailPattern = "^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$";
        if (!Pattern.matches(emailPattern, email)) {
            throw new InvalidFormatException("올바른 이메일 형식이 아닙니다.");
        }

        // 입력된 이메일로 User 객체 생성
        User inputUser = new User();
        inputUser.setUserEmail(email);

        // 회원 정보 조회
        User user = loginService.findByEmail(inputUser);
        
        if (user == null) {
            throw new UnauthorizedException("입력하신 정보와 일치하는 계정이 없습니다. 다시 시도해주시거나 사이트 운영자에게 문의해주세요.");
        }

        // 임시 비밀번호 생성 후 비밀번호 재설정 -> 메일 발송
        loginService.resetPw(user);

        // 응답 결과 생성
        response = ResponseDTO.builder()
                .success(true)
                .message("임시 비밀번호가 이메일로 발송되었습니다.")
                .timestamp(LocalDateTime.now())
                .build();
        return ResponseEntity.ok(response);
    }
```
- 임시비밀번호 생성, 비밀번호 재설정, 그리고 재설정된 비밀번호를 메일로 발송하는 기능까지를 모두 loginService.resetPw(user); 에서 하도록 수정하였다.
- 그리고 이로인한 비즈니스로직은 서비스에서 담당하므로 아래와 같다.
```java
/**
 * 비밀번호 재설정 메서드 구현체
 * @param user User 객체, 비밀번호를 재설정할 사용자 정보 포함
 * @throws Exception 비밀번호 재설정 실패 시 예외 발생
 */
@Override
public void resetPw(User user) throws Exception {

    //임시비밀번호 생성
    String newPassword = passwordManager.generateNewPassword();

    if (newPassword == null || newPassword.isEmpty()) {
        throw new InternalServerErrorException("임시 비밀번호 생성에 실패했습니다. 다시 시도해주세요.");
    }

    // 비밀번호 재설정
    userMapper.resetPw(user.getUserId(), newPassword);

    // 비밀번호 재설정 후 재설정된 이메일을 가지고 이메일 전송
    emailManager.newPasswordEmailSend(user, newPassword);
}
```
- 유저 객체를 받아 임시비밀번호 생성 -> 비밀번호 재설정 -> 이메일 전송의 한 흐름을 주도하며 각각 기능을 담당하는 매니저를 호출한다.
- 매니저 메서드를 static으로 만드려다가 확장성을 고려하여 객체를 생성하는 형태로 만들었다.
- 아래는 차례로 비밀번호 생성, 메일 전송 로직이다.
```java
@Component
public class PasswordManager {
    
    /**
     * 임시 비밀번호 생성 메소드
     * 비밀번호 찾기 기능에서 사용
     * @return 8자리 임시 비밀번호 (영문, 숫자, 특수문자 포함)
     */
    public String generateNewPassword() throws Exception {
        // 임시 비밀번호 생성(8자리: 영문, 숫자, 특수문자 포함)
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        String nums = "0123456789";
        SecureRandom  rnd = new SecureRandom();
        String newPassword = null;

        while (true) {
            StringBuilder sb = new StringBuilder();
            // 영문자 1개 무조건 포함
            sb.append(chars.charAt(rnd.nextInt(chars.length())));
            // 숫자 1개 무조건 포함
            sb.append(nums.charAt(rnd.nextInt(nums.length())));

            // 나머지 6자리는 영문/숫자 섞어서 랜덤 생성
            String all = chars + nums;
            for (int i = 0; i < 6; i++) {
                sb.append(all.charAt(rnd.nextInt(all.length())));
            }

            // 섞기 (영문, 숫자가 1번째, 2번째에 몰리지 않게)
            List<Character> pwChars = new ArrayList<>();

            for (char c : sb.toString().toCharArray()) pwChars.add(c);

            Collections.shuffle(pwChars);

            StringBuilder resultPw = new StringBuilder();

            for (char c : pwChars) resultPw.append(c);

            newPassword = resultPw.toString();

            // 정규식 조건 체크
            if (newPassword.matches("^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]{8}$")) {
                break;
            }
            // 조건 불만족 시 while로 다시 생성
        }
        return newPassword;
    }
}
```
- 아래는 이메일 메니저이다.
- @Component를 안붙이면 일일히 new 로 객체를 생성해야 하므로 @Component를 붙여 스프링 빈으로 관리해주는 것이 좋다.
```java
@Component
@RequiredArgsConstructor
public class EmailManager {

    @Value("${mailhelper.sender.email}")
    private String senderEmail; // 발신자 이메일

    @Value("${mailhelper.sender.name}")
    private String senderName; // 발신자 이름

    private final JavaMailSender javaMailSender;

    /**
     * 새로운 비밀번호를 이메일로 전송하는 메서드
     * @param user User 객체, 비밀번호를 재설정할 사용자 정보 포함
     * @param newPassword 새로 생성된 비밀번호
     * @throws Exception 이메일 전송 중 발생할 수 있는 예외
     */
    public void newPasswordEmailSend(User user, String newPassword) throws Exception {

        // 메일 템플릿 파일 직접 읽기
        ClassPathResource resource = new ClassPathResource("mail_templates/reset_pw.html"); // mail_templates 디렉토리에서 템플릿 파일을 읽어옴        
        byte[] bytes = Files.readAllBytes(resource.getFile().toPath()); // 파일을 바이트 배열로 읽음
        String template = new String(bytes, "UTF-8");

        // 템플릿 치환
        template = template.replace("{{userEmail}}", user.getUserEmail());
        template = template.replace("{{password}}", newPassword);

        // 메일 발송
        String subject = "[클론보스]" + user.getUserEmail() + "님의 비밀번호가 재설정되었습니다.";
        
        MimeMessage message = javaMailSender.createMimeMessage();
        MimeMessageHelper helper = new MimeMessageHelper(message, false, "UTF-8");
        helper.setSubject(subject); // 메일 제목 설정
        helper.setText(template, true); // 메일 내용 설정

        helper.setTo(user.getUserEmail()); // 사용자의 이메일 주소로 발송
        helper.setFrom(new InternetAddress(senderEmail, senderName, "UTF-8"));  // 미리 설정해둔 이메일과 이름 세팅
        javaMailSender.send(message); // 메일 발송
    }
}
```

### 📌 0-4. 기존 업데이트 로직 분리
- EditController에서 파일을 업로드하던 로직이 조금 복잡해서 기존 컨트롤러에서 서비스로 로직을 옮겨 분리하였다.
```java
@PostMapping("/api/profile/update")
    public ResponseEntity<ResponseDTO> updateProfile(
            HttpSession session, 
            @SessionAttribute("memberInfo") User member,
            @RequestParam(value = "profileImg", required = false) MultipartFile profileImg,
            @RequestParam(value = "deleteProfileImg", required = false) Boolean deleteProfileImg,
            @RequestParam(value = "profileImgChange", required = false) Boolean profileImgChange,
            @RequestParam Map<String, String> editedMap // 모든 수정된 input/select/checkbox 값이 모여있음.
    ) throws Exception {

        // 필수 항목 유효성 검사
        String name = editedMap.get("name");
        String phone = editedMap.get("phone");
        String gender = editedMap.get("gender");
        String birthYear = editedMap.get("birthYear");
        String birthMonth = editedMap.get("birthMonth");
        String birthDay = editedMap.get("birthDay");

        if (name == null || name.trim().isEmpty()
                || phone == null || phone.trim().isEmpty()
                || gender == null || gender.trim().isEmpty()
                || birthYear == null || birthYear.trim().isEmpty()
                || birthMonth == null || birthMonth.trim().isEmpty()
                || birthDay == null || birthDay.trim().isEmpty()) {
            throw new InvalidFormatException("필수 입력 항목이 누락되었습니다.");
        }

        // 이름 형식 검사 (한글 2글자 이상)
        if (!name.matches("^[가-힣]{2,}$")) {
            throw new InvalidFormatException("이름은 한글 2글자 이상이어야 합니다.");
        }

        // 010-xxxx-xxxx 또는 010xxxxxxxx 모두 허용
        String phonePattern1 = "^01(?:0|1|[6-9])(?:\\d{3}|\\d{4})\\d{4}$";
        String phonePattern2 = "^01(?:0|1|[6-9])[-]?(?:\\d{3}|\\d{4})[-]?\\d{4}$";
        if (!phone.matches(phonePattern1) && !phone.matches(phonePattern2)) {
            throw new InvalidFormatException("연락처 형식이 잘못되었습니다. 010-xxxx-xxxx 또는 010xxxxxxxx 형식이어야 합니다.");
        }

        // date 형식 검사 (YYYY-MM-DD)
        int year = Integer.parseInt(birthYear);
        int month = Integer.parseInt(birthMonth);
        int day = Integer.parseInt(birthDay);

        if (month < 1 || month > 12 || day < 1 || day > 31) {
            throw new InvalidFormatException("생년월일 형식이 잘못되었습니다.");
        }

        LocalDate birthDate = LocalDate.of(year, month, day);
        LocalDate today = LocalDate.now();

        if (birthDate.isAfter(today)) {
            throw new InvalidFormatException("생년월일은 미래 날짜를 입력할 수 없습니다.");
        }

        // 비밀번호 변경 시 일치 여부 확인
        String newPassword = editedMap.get("newPassword");
        String confirmPassword = editedMap.get("confirmPassword");

        if ((newPassword != null && !newPassword.isEmpty()) || (confirmPassword != null && !confirmPassword.isEmpty())) { // 비밀번호 변경이 요청된 경우 - 둘 중 하나라도 입력되어 있으면 요청한 것으로 본다.
            if (newPassword == null || newPassword.isEmpty() || confirmPassword == null || confirmPassword.isEmpty()) { // 둘 중 하나 빼먹은 경우
                throw new InvalidFormatException("비밀번호와 비밀번호 확인을 모두 입력해야 합니다.");
            }
            if (!newPassword.equals(confirmPassword)) { // 두 값이 다른 경우
                throw new InvalidFormatException("비밀번호와 비밀번호 확인이 일치하지 않습니다.");
            }

            if (!newPassword.matches("^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]{8,20}$")) {
                throw new InvalidFormatException("비밀번호는 영문자와 숫자를 포함하여 8자 이상 20자 이하로 입력해야 합니다.");
            }
        }

        // 기존 회원 정보 조회
        User userProfile = editService.getUserProfile(member);

        // 프로필 이미지 처리 (업로드 > 삭제 > 변경 없음 순)
        if (profileImg != null && !profileImg.isEmpty()) { // 프로필 이미지가 업로드되어있다면

            String originalFileName = profileImg.getOriginalFilename();
                
            if (originalFileName != null) {
                String lower = originalFileName.toLowerCase();
                if (!(lower.endsWith(".jpg") || lower.endsWith(".jpeg") || lower.endsWith(".png"))) {
                    throw new InvalidFormatException("프로필 이미지는 이미지 파일(jpg, jpeg, png)만 업로드할 수 있습니다.");
                }
            }

                // MIME 타입 검사
                String contentType = profileImg.getContentType();
                if (contentType == null ||
                    !(contentType.equalsIgnoreCase("image/jpeg") ||
                    contentType.equalsIgnoreCase("image/png"))) {
                    throw new InvalidFormatException("프로필 이미지는 이미지 파일(jpg, jpeg, png)만 업로드할 수 있습니다.");
                }
            
                // 이미지 파일인지 확인
                BufferedImage img = ImageIO.read(profileImg.getInputStream());

                if (img == null) {
                    throw new InvalidFormatException("프로필 이미지가 올바른 이미지 파일이 아닙니다.");
                }
    
                // 기존 이미지 삭제 (있으면)
                String originalImgUrl = userProfile.getUserProfileImg();

                if (originalImgUrl != null && !originalImgUrl.isEmpty()) {

                    String relativePath = originalImgUrl.replace("/files", "");
                    String realFilePath = uploadDir + relativePath;
                    File file = new File(realFilePath); // 기존 이미지까지의 경로 뚫어둠

                    if (file.exists()) 
                        file.delete();
                }

                // 새 파일 저장 + DB 업데이트
                editService.saveProfileImage(member, profileImg); // 새 이미지 저장 및 DB update


            } else if (Boolean.TRUE.equals(deleteProfileImg)) { // deleteProfileImg이 true라면 <- 문자열로 오지만 위에서 bollean으로 자동변환됨.
                // 기존 이미지 삭제 (있으면)
                String originalImgUrl = userProfile.getUserProfileImg();

                if (originalImgUrl != null && !originalImgUrl.isEmpty()) {

                    String relativePath = originalImgUrl.replace("/files", "");
                    String realFilePath = uploadDir + relativePath;
                    File file = new File(realFilePath);

                    if (file.exists()) 
                        file.delete();
                }

                // DB에서 URL null 처리 = 삭제처리
                editService.deleteProfileImage(member);
            }
            // else profileImgChange === false면 아무 변화 없음

        // 비밀번호 변경 처리
        if (newPassword != null && !newPassword.isEmpty()) {
            editService.changeUserPassword(member, newPassword);
        }

        // 나머지 프로필 정보 업데이트
        editService.updateUserProfile(member, editedMap);

        // 세션 정보 업데이트   
        // 세션에 저장된 회원 정보는 로그인 시점의 정보이므로, 수정 후 다시 조회하여 업데이트해야한다.
        User updatedUser = editService.getUserProfile(member);
        session.setAttribute("memberInfo", updatedUser);

        return ResponseEntity.ok(ResponseDTO.builder()
                .success(true)
                .message("프로필이 성공적으로 수정되었습니다.")
                .timestamp(LocalDateTime.now())
                .build());
    }
```
- 서비스에서 오직 이미지를 삭제하기 위한 모든 로직을 수행한다.
- 기존 컴퓨터에 있는 이미지를 삭제하고 db에 있는 이미지까지 삭제하는 로직을 한 곳에 모았다.
```java
@Override
    public void deleteProfileImage(User userInfo) throws Exception {
        // 기존 컴퓨터에 있는 이미지 삭제
        String originalImgUrl = userInfo.getUserProfileImg();

        if (originalImgUrl != null && !originalImgUrl.isEmpty()) {

            String relativePath = originalImgUrl.replace("/files", "");
            String realFilePath = uploadDir + relativePath;
            File file = new File(realFilePath);

            if (file.exists()) 
                file.delete();
        }
                
        int result = 0;

        // 프로필 이미지 삭제를 위한 DB 작업 수행
        result = userMapper.deleteProfileImage(userInfo);

        if (result == 0) {
            throw new InternalServerErrorException("프로필 이미지 삭제에 실패했습니다.");
        }
    }
```
- 새로운 파일을 삽입하는 로직을 추가하였다.
- 기존 컴퓨터에 있는 이미지를 삭제하고 db는 기존 이미지에 update를 진행한다.
```java
public void saveProfileImage(User user, MultipartFile profileImg) throws Exception {
        // 기존 이미지 삭제 (있으면)
        String originalImgUrl = user.getUserProfileImg();

        if (originalImgUrl != null && !originalImgUrl.isEmpty()) {

            String relativePath = originalImgUrl.replace("/files", "");
            String realFilePath = uploadDir + relativePath;
            File file = new File(realFilePath); // 기존 이미지까지의 경로 뚫어둠

            if (file.exists()) 
                file.delete();
        }

        // 파일명/확장자 추출 및 업로드 경로 생성
        String originalName = profileImg.getOriginalFilename(); // 원본 파일명
        if (originalName == null || originalName.isEmpty()) throw new InternalServerErrorException("파일이 비어있습니다.");

        String ext = originalName.substring(originalName.lastIndexOf("."));
        String uniqueName = UUID.randomUUID().toString().replace("-", "") + ext;

        // 날짜별 폴더로 구조화
        Calendar c = Calendar.getInstance();
        String folderPath = String.format("/%04d/%02d/%02d", c.get(Calendar.YEAR), c.get(Calendar.MONTH) + 1, c.get(Calendar.DAY_OF_MONTH));
        String saveDir = uploadDir + folderPath;

        File dir = new File(saveDir);
        if (!dir.exists()) 
            dir.mkdirs(); // 디렉토리가 없으면 생성

        String savedFilePath = saveDir + "/" + uniqueName;
        // 실제 파일 저장
        profileImg.transferTo(new File(savedFilePath));

        // 웹에서 접근할 url
        String fileUrl = uploadUrl + folderPath + "/" + uniqueName;

        User userInfo = new User();
        userInfo.setUserId(user.getUserId());
        userInfo.setUserProfileImg(fileUrl); // 프로필 이미지 URL 설정

        // DB에 프로필 이미지 URL 업데이트
        int updated = userMapper.updateProfileImgUrl(userInfo);

        // DB 업데이트 결과 확인
        if (updated == 0) {
            throw new InternalServerErrorException("DB에 프로필 이미지 URL 저장 실패");
        }
    }
```

### 📌 0-5. 서비스는 매퍼만 컨트롤러는 서비스에 넘겨줄 파라미터 생성만
- 모든 처리를 서비스로 옮겼다가 서비스는 파라미터를 들고 매퍼들을 이용해 조립하는 역할을 하고 컨트롤러가 그 파라미터들을 계산해서 넘겨줘야한다는 설명을 듣고 그대로 리팩토링하였다. 
- 그 과정에서 최대한 컨트롤러를 간소화하기 위해 정보 수정 로직을 수정하고 유효성 검사들을 모두 정리해서 유효성 검사 매니저를 코딩하였다. -> 기존에 있던 걸 정리하는 것은 코파일럿으로 하면 된다.
- 아래는 바뀐 정보수정 클래스이고 validationManager의 validateUser 메서드를 통해 받은 값을 모두 검증하여 검증된 값들만 updatedUser에 담아 반환한다.
- 이때 검증된 값들 중 null인 값들이 있는데 그건 그냥 null로 업데이트 하면 되는거라 그냥 이대로 유지하였다. 
- 이렇게 로직을 진행하면 컨트롤러가 매우 간단해지는데 아래는 바뀐 정보수정 컨트롤러이다. 모든 로직을 컨트롤러에서 수행하면서 컨트롤러에 쏠리는 코드의 양을 manager를 통해 줄였다.
- 또한 기존에 안쓰던 ProfileImgChange 태그를 삭제하여 코드를 좀 더 깔끔하게 고쳤다.
- 검증된 값들을 객체로 받아 그대로 업데이트 서비스로 넘기면 서비스가 알아서 매퍼를 호출하여 수정을 구현한다.
```java
@PostMapping("/api/profile/update")
    public ResponseEntity<ResponseDTO> updateProfile(
            HttpSession session, 
            @SessionAttribute("memberInfo") User member,
            @RequestParam(value = "profileImg", required = false) MultipartFile profileImg,
            @RequestParam(value = "deleteProfileImg", required = false) Boolean deleteProfileImg,
            @RequestParam Map<String, String> editedMap
    ) throws Exception {

        User userProfile = editService.getUserProfile(member);

        // ValidationManager를 사용하여 유효성 검사 및 User 객체 생성
        User updatedUser = validationManager.validateUser(editedMap, profileImg, userProfile.getUserId());

        // 프로필 이미지 처리
        if (profileImg != null && !profileImg.isEmpty()) {
            // 이미지 유효성 검사는 ValidationManager에서 완료했으므로 더 진행하지 않아도 된다.
            BufferedImage img = ImageIO.read(profileImg.getInputStream());

            // 기존 이미지 삭제 후 새 이미지 저장
            fileUploadManager.deleteProfileImageFromDisk(userProfile);
            String fileUrl = fileUploadManager.storeProfileImageAndReturnUrl(profileImg);
            updatedUser.setUserProfileImg(fileUrl);

        } else if (Boolean.TRUE.equals(deleteProfileImg)) {
            // 프로필 이미지 삭제
            fileUploadManager.deleteProfileImageFromDisk(userProfile);
            updatedUser.setUserProfileImg(null);
        }

        // 한 번에 모든 정보 업데이트
        editService.updateUserProfile(updatedUser);

        // 세션 정보 업데이트
        session.setAttribute("memberInfo", editService.getUserProfile(userProfile));

        return ResponseEntity.ok(ResponseDTO.builder()
                .success(true)
                .message("프로필이 성공적으로 수정되었습니다.")
                .timestamp(LocalDateTime.now())
                .build());
    }
```
- 아래는 새로 만든 validation manager이다.
- 그냥 기존의 검사 로직을 그대로 옮기고 유효성 검사를 수행하는 로직들에 대한 유효성 검사 로직을 따로 모은 메서드를 만들어서 모든 리팩토링이 이 파일안에서 일어날 수 있도록 하였다.
```java
@Component
public class ValidationManager {
    
    // ------------------------------------ 개별 유효성 검사 메서드들 ------------------------------------------------
    
    /**
     * 이메일 유효성 검사
     * @param email 검사할 이메일
     * @return 검증된 이메일
     * @throws InvalidFormatException 유효성 검사 실패 시
     */
    public String validateEmail(String email) throws InvalidFormatException {
        if (email == null || email.trim().isEmpty()) {
            throw new InvalidFormatException("이메일을 입력하세요.");
        }
        if (!email.matches("^[\\w.-]+@[\\w.-]+\\.[a-zA-Z]{2,}$")) {
            throw new InvalidFormatException("이메일 형식이 잘못되었습니다.");
        }
        return email.trim();
    }
    
    /**
     * 비밀번호 유효성 검사 (필수)
     * @param password 검사할 비밀번호
     * @return 검증된 비밀번호
     * @throws InvalidFormatException 유효성 검사 실패 시
     */
    public String validatePassword(String password) throws InvalidFormatException {
        if (password == null || password.trim().isEmpty()) {
            throw new InvalidFormatException("비밀번호를 입력하세요.");
        }
        if (password.length() < 8 || password.length() > 20 || !password.matches("^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]{8,20}$")) {
            throw new InvalidFormatException("비밀번호는 8자 이상 20자 이하의 영문+숫자 조합이어야 합니다.");
        }
        return password;
    }
    
    /**
     * 비밀번호 변경 유효성 검사 (선택, 값이 있을 때만)
     * @param newPassword 새 비밀번호
     * @param confirmPassword 비밀번호 확인
     * @return 검증된 비밀번호 (null 가능)
     * @throws InvalidFormatException 유효성 검사 실패 시
     */
    public String validatePasswordChange(String newPassword, String confirmPassword) throws InvalidFormatException {
        if ((newPassword != null && !newPassword.trim().isEmpty()) || (confirmPassword != null && !confirmPassword.trim().isEmpty())) {
            if (newPassword == null || newPassword.trim().isEmpty() || confirmPassword == null || confirmPassword.trim().isEmpty()) {
                throw new InvalidFormatException("비밀번호와 비밀번호 확인을 모두 입력해야 합니다.");
            }
            if (!newPassword.equals(confirmPassword)) {
                throw new InvalidFormatException("비밀번호와 비밀번호 확인이 일치하지 않습니다.");
            }
            if (!newPassword.matches("^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]{8,20}$")) {
                throw new InvalidFormatException("비밀번호는 영문자와 숫자를 포함하여 8자 이상 20자 이하로 입력해야 합니다.");
            }
            return newPassword;
        }
        return null;
    }
    
    /**
     * 이름 유효성 검사
     * @param name 검사할 이름
     * @return 검증된 이름
     * @throws InvalidFormatException 유효성 검사 실패 시
     */
    public String validateName(String name) throws InvalidFormatException {
        if (name == null || name.trim().isEmpty()) {
            throw new InvalidFormatException("이름을 입력하세요.");
        }
        if (!name.matches("^[가-힣]{2,}$")) {
            throw new InvalidFormatException("이름은 한글로 2자 이상이어야 합니다.");
        }
        return name.trim();
    }
    
    /**
     * 성별 유효성 검사
     * @param gender 검사할 성별
     * @return 검증된 성별
     * @throws InvalidFormatException 유효성 검사 실패 시
     */
    public String validateGender(String gender) throws InvalidFormatException {
        if (gender == null || gender.trim().isEmpty()) {
            throw new InvalidFormatException("성별을 선택하세요.");
        }
        return gender.trim();
    }
    
    /**
     * 연락처 유효성 검사
     * @param phone 검사할 연락처
     * @return 검증된 연락처
     * @throws InvalidFormatException 유효성 검사 실패 시
     */
    public String validatePhone(String phone) throws InvalidFormatException {
        if (phone == null || phone.trim().isEmpty()) {
            throw new InvalidFormatException("연락처를 입력하세요.");
        }
        if (!phone.matches("^01(?:0|1|[6-9])(?:\\d{3}|\\d{4})\\d{4}$") && 
            !phone.matches("^01(?:0|1|[6-9])[-]?(?:\\d{3}|\\d{4})[-]?\\d{4}$")) {
            throw new InvalidFormatException("연락처 형식이 잘못되었습니다. 010-xxxx-xxxx 또는 010xxxxxxxx 형식이어야 합니다.");
        }
        return phone.trim();
    }
    
    /**
     * 생년월일 유효성 검사
     * @param birthYear 생년
     * @param birthMonth 생월
     * @param birthDay 생일
     * @return 검증된 생년월일 (yyyy-MM-dd 형식)
     * @throws InvalidFormatException 유효성 검사 실패 시
     */
    public String validateBirthdate(String birthYear, String birthMonth, String birthDay) throws InvalidFormatException {
        if (birthYear == null || birthYear.trim().isEmpty() || 
            birthMonth == null || birthMonth.trim().isEmpty() || 
            birthDay == null || birthDay.trim().isEmpty()) {
            throw new InvalidFormatException("생년월일을 모두 입력하세요.");
        }

        try {
            int year = Integer.parseInt(birthYear.trim());
            int month = Integer.parseInt(birthMonth.trim());
            int day = Integer.parseInt(birthDay.trim());

            if (month < 1 || month > 12 || day < 1 || day > 31) {
                throw new InvalidFormatException("생년월일 형식이 잘못되었습니다.");
            }

            LocalDate birthDate = LocalDate.of(year, month, day);
            if (birthDate.isAfter(LocalDate.now())) {
                throw new InvalidFormatException("생년월일은 미래 날짜를 입력할 수 없습니다.");
            }
            return String.format("%s-%s-%s", birthYear.trim(), birthMonth.trim(), birthDay.trim());
        } catch (NumberFormatException e) {
            throw new InvalidFormatException("생년월일은 숫자로 입력해야 합니다.");
        }
    }
    
    /**
     * 우편번호 유효성 검사 (선택)
     * @param postcode 검사할 우편번호
     * @return 검증된 우편번호 (null 가능)
     * @throws InvalidFormatException 유효성 검사 실패 시
     */
    public String validatePostcode(String postcode) throws InvalidFormatException {
        if (postcode != null && !postcode.trim().isEmpty()) {
            if (!postcode.matches("^\\d{4,5}$")) {
                throw new InvalidFormatException("우편번호는 4-5자리 숫자여야 합니다.");
            }
            return postcode.trim();
        }
        return null;
    }
    
    /**
     * 주소 유효성 검사 (선택)
     * @param address 검사할 주소
     * @return 검증된 주소 (null 가능)
     */
    public String validateAddress(String address) {
        if (address != null && !address.trim().isEmpty()) {
            return address.trim();
        }
        return null;
    }
    
    /**
     * 상세주소 유효성 검사 (선택)
     * @param addressDetail 검사할 상세주소
     * @return 검증된 상세주소 (null 가능)
     */
    public String validateAddressDetail(String addressDetail) {
        if (addressDetail != null && !addressDetail.trim().isEmpty()) {
            return addressDetail.trim();
        }
        return null;
    }
    
    /**
     * 프로필 이미지 유효성 검사 (선택)
     * @param profileImg 검사할 프로필 이미지
     * @throws InvalidFormatException 유효성 검사 실패 시
     */
    public void validateProfileImage(MultipartFile profileImg) throws InvalidFormatException {
        if (profileImg != null && !profileImg.isEmpty()) {
            String originalFileName = profileImg.getOriginalFilename();
            if (originalFileName != null) {
                String lower = originalFileName.toLowerCase();
                if (!(lower.endsWith(".jpg") || lower.endsWith(".jpeg") || lower.endsWith(".png"))) {
                    throw new InvalidFormatException("프로필 이미지는 이미지 파일(jpg, jpeg, png)만 업로드할 수 있습니다.");
                }
            }

            String contentType = profileImg.getContentType();
            if (contentType == null || !(contentType.equalsIgnoreCase("image/jpeg") || contentType.equalsIgnoreCase("image/png"))) {
                throw new InvalidFormatException("프로필 이미지는 이미지 파일(jpg, jpeg, png)만 업로드할 수 있습니다.");
            }
        }
    }
    
    /**
     * 약관 동의 유효성 검사 및 변환
     * @param agreeSms SMS 수신 동의 문자열
     * @param agreeEmail 이메일 수신 동의 문자열  
     * @return [smsTerm, emailTerm] 배열
     */
    public boolean[] validateAgreements(String agreeSms, String agreeEmail) {
        boolean smsTerm = "true".equals(agreeSms) || "on".equals(agreeSms);
        boolean emailTerm = "true".equals(agreeEmail) || "on".equals(agreeEmail);
        return new boolean[]{smsTerm, emailTerm};
    }
    
    /**
     * 필수 약관 동의 유효성 검사 (회원가입용)
     * @param requiredTerm 필수 약관 동의 문자열
     * @throws InvalidFormatException 필수 약관 미동의 시
     */
    public void validateRequiredAgreement(String requiredTerm) throws InvalidFormatException {
        boolean isRequired = "true".equals(requiredTerm) || "on".equals(requiredTerm);
        if (!isRequired) {
            throw new InvalidFormatException("필수 약관에 동의해야 합니다.");
        }
    }
    
    // ------------------------------------- 통합 유효성 검사 메서드들 ------------------------------------------------
    
    /**
     * 프로필 수정용 사용자 정보 유효성 검사
     * @param editedMap 수정할 정보가 담긴 Map
     * @param profileImg 프로필 이미지 파일 (선택사항)
     * @param userId 수정할 사용자 ID
     * @return 검증된 User 객체
     * @throws InvalidFormatException 유효성 검사 실패 시
     */
    public User validateUser(Map<String, String> editedMap, MultipartFile profileImg, int userId) throws InvalidFormatException {
        User updatedUser = new User();
        updatedUser.setUserId(userId);

        // 필수 항목들
        updatedUser.setUserName(validateName(editedMap.get("name")));
        updatedUser.setUserPhone(validatePhone(editedMap.get("phone")));
        updatedUser.setUserGender(validateGender(editedMap.get("gender")));
        
        String birthdate = validateBirthdate(
            editedMap.get("birthYear"), 
            editedMap.get("birthMonth"), 
            editedMap.get("birthDay")
        );
        updatedUser.setUserBirthdate(birthdate);

        // 선택 항목들
        String postcode = validatePostcode(editedMap.get("postcode"));
        if (postcode != null) updatedUser.setUserPostcode(postcode);
        
        String address = validateAddress(editedMap.get("address"));
        if (address != null) updatedUser.setUserAddress(address);
        
        String addressDetail = validateAddressDetail(editedMap.get("addressDetail"));
        if (addressDetail != null) updatedUser.setUserSpecificAddress(addressDetail);

        // 비밀번호 변경 검사
        String newPassword = validatePasswordChange(editedMap.get("newPassword"), editedMap.get("confirmPassword"));
        if (newPassword != null) updatedUser.setUserPassword(newPassword);

        // 프로필 이미지 검사
        validateProfileImage(profileImg);

        // 동의 항목 설정
        if (editedMap.containsKey("agreeSms") || editedMap.containsKey("agreeEmail")) {
            boolean[] agreements = validateAgreements(editedMap.get("agreeSms"), editedMap.get("agreeEmail"));
            if (editedMap.containsKey("agreeSms")) updatedUser.setSmsTerm(agreements[0]);
            if (editedMap.containsKey("agreeEmail")) updatedUser.setEmailTerm(agreements[1]);
        }

        return updatedUser;
    }

    /**
     * 로그인용 이메일 유효성 검사 (보안을 위해 구체적인 오류 메시지 제공하지 않음)
     * @param email 검사할 이메일
     * @return 검증된 이메일
     * @throws InvalidFormatException 유효성 검사 실패 시
     */
    public String validateLoginEmail(String email) throws InvalidFormatException {
        if (email == null || email.trim().isEmpty()) {
            throw new InvalidFormatException("이메일을 입력하세요.");
        }
        if (!email.matches("^[\\w.-]+@[\\w.-]+\\.[a-zA-Z]{2,}$")) {
            throw new InvalidFormatException("잘못된 아이디 또는 비밀번호입니다.");
        }
        return email.trim();
    }

    /**
     * 로그인용 비밀번호 유효성 검사 (보안을 위해 구체적인 오류 메시지 제공하지 않음)
     * @param password 검사할 비밀번호
     * @return 검증된 비밀번호
     * @throws InvalidFormatException 유효성 검사 실패 시
     */
    public String validateLoginPassword(String password) throws InvalidFormatException {
        if (password == null || password.trim().isEmpty()) {
            throw new InvalidFormatException("비밀번호를 입력하세요.");
        }
        if (!password.matches("^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]{8,20}$")) {
            throw new InvalidFormatException("잘못된 아이디 또는 비밀번호입니다.");
        }
        return password;
    }

    /**
     * 아이디/비밀번호 찾기용 이메일 유효성 검사
     * @param email 검사할 이메일
     * @return 검증된 이메일
     * @throws InvalidFormatException 유효성 검사 실패 시
     */
    public String validateFindEmail(String email) throws InvalidFormatException {
        if (email == null || email.trim().isEmpty()) {
            throw new InvalidFormatException("이메일을 입력하세요.");
        }
        if (!email.matches("^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$")) {
            throw new InvalidFormatException("올바른 이메일 형식이 아닙니다.");
        }
        return email.trim();
    }

    /**
     * 아이디 찾기용 휴대폰 번호 유효성 검사
     * @param phone 검사할 휴대폰 번호
     * @return 검증된 휴대폰 번호
     * @throws InvalidFormatException 유효성 검사 실패 시
     */
    public String validateFindPhone(String phone) throws InvalidFormatException {
        if (phone == null || phone.trim().isEmpty()) {
            throw new InvalidFormatException("휴대폰 번호를 입력하세요.");
        }
        // 010-1234-5678, 01012345678 등 허용
        if (!phone.matches("^(\\d{2,3}-?\\d{3,4}-?\\d{4})$")) {
            throw new InvalidFormatException("올바른 휴대폰 번호 형식이 아닙니다. (예: 010-1234-5678 또는 01012345678)");
        }
        return phone.trim();
    }

    /**
     * 아이디 찾기용 이름 유효성 검사
     * @param name 검사할 이름
     * @return 검증된 이름
     * @throws InvalidFormatException 유효성 검사 실패 시
     */
    public String validateFindName(String name) throws InvalidFormatException {
        if (name == null || name.trim().isEmpty()) {
            throw new InvalidFormatException("이름을 입력하세요.");
        }
        return name.trim();
    }
}
```

### 📌 0-7. 기존에 총 주문량을 user에서 계산하던 것을 order mapper를 통해 계산
- 컨트롤러가 서비스의 역할이라고 생각했던 로직을 다 가져가니까 서비스의 일이 단일 매퍼호출이 되어버렸다. 그러다보니 서비스가 단일 매퍼를 호출할 바엔 매퍼의 sql을 줄이고 다양한 mapper들을 긁어와서 사용하는게 서비스의 소양을 다한다는 느낌이 들었다.
- 그래서 기존 매퍼를 단순화하고 다양한 곳의 mapper들을 끌어와서 서비스에서 사용하도록 하여 sql문을 단순화하는 작업을 진행하였다.
- 아래는 기존에 orders 테이블을 조인하여 처리하던 것이며 결국엔 이를 분리하여 우선 user만 전체를 가져오고 order total은 따로 가져오도록 정리하였다.
```java
/**
     * 유저의 정보와 유저의 주문 정보를 조인하여 조회
     * 유저가 주문한 총 금액이 없어도 left join을 사용하여 유저 정보를 가져와서 주문 정보를 0으로 띄워줌
     * @param input 세션에서 가져온 User 아이디가 포함된 User 객체
     * @return User 객체 (유저 정보와 누적 구매 금액 포함)          
     * @throws Exception
     */
    @Select(
        "SELECT " +
        "u.user_id, u.user_email, u.user_password, u.user_name, u.user_gender, u.user_phone, " +
        "u.user_birthdate, u.user_postcode, u.user_address, u.user_specific_address, u.user_profile_img, " +
        "u.required_term, u.sms_term, u.email_term, u.is_out, u.reg_date, u.edit_date, " +
        "IFNULL(SUM(o.order_price), 0) AS order_total_price " +
        "FROM users u " +
        "LEFT JOIN orders o ON u.user_id = o.user_id " +
        "WHERE u.user_id = #{userId} " +
        "GROUP BY u.user_id"
    )
    @ResultMap("UserMap")
    User selectUserWithOrderTotalPrice(User input) throws Exception;
```
- 아래처럼 주문총액을 따로 조회해서 user객체에 추가하는 식으로 하여 구성하였다.
```java
Override
    public User getUserInfo(User user) throws Exception {
        // 세션에서 가져온 User 아이디로 유저 정보 조회
        user = userMapper.selectOne(user);
        if (user == null) {
            throw new UnauthorizedException("사용자 정보가 없습니다. 로그인 후 다시 시도해주세요.");
        }
        
        // 별도로 주문 총액 조회
        Order orderInput = new Order();
        orderInput.setUserId(user.getUserId());
        int totalOrderPrice = orderMapper.selectTotalOrderPriceByUserId(orderInput);
        user.setOrderTotalPrice(totalOrderPrice);
        
        return user;
    }
```

### 📌 0-8. mapper, controller 정리
- 기존에 내가 만들었던 login, edit_profile과 팀원이 만들었던 join 기능을 담당하는 mapper와 controller를 user mapper와 user controller로 합쳤다.
- 합치는게 그렇게 오래 걸리지 않았고 다음에 전체적인 구조를 설계할때 도움이 되는 경험을 한 것 같다.

