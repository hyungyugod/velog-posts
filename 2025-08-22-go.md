# 📌 0. 에러처리
### 📌 0-1. go언어 에러처리 기본
- go는 다른 언어와 다르게 라인단위가 아니라 함수단위로 에러처리를 한다.
- Go에서 에러는 다음 시그니처를 가진 error라는 내장 인터페이스이다.
- 어떤 타입이든 Error() string 메서드를 구현하면 error 타입으로 사용될 수 있다.
```go
type error interface {
    Error() string
}
```
- 이때 errors 패키지는 error 인터페이스를 구현한 값을 쉽게 만들어주는 도우미이다.
```go
package main
import (
"errors"
"fmt"
)
// 두 수를 나누는 함수. 실패 시 error를 반환함.
func divide(a, b float64) (float64, error) {
    // 나누는 수가 0인 경우
    if b == 0 {
    // errors.New 함수로 새로운 에러 메시지를 생성하여 반환
    return 0, errors.New("0으로 나눌 수 없습니다")
}
    // 성공한 경우, 결과와 함께 nil을 반환 (에러가 없다는 의미)
    return a / b, nil
}
```

### 📌 0-2. panic과 recover
- 우선 defer를 앞에 붙인 함수는 예약라인으로 함수 호출의 마지막 부분에서 실행된다. 또 defer는 스택으로 가장 마지막에 부른게 가장 먼저 실행된다. 
- 즉 처음 라인을 읽을 땐 defer가 쌓이고 마지막에 쌓인 스택에서 하나씩 꺼내서 실행하는 것이다.
- panic은 현재 함수의 실행을 그 시점에서 멈춘다. 다만 defer된 함수들은 처리한다. 그리고 상위 호출로 제어를 넘긴다. 상위로 에러처리를 넘긴다는 것을 의미한다. 이때 끝까지 에러처리가 되지않으면 프로그램이 뻗는다.
- 이때 recover는 에러를 받는 역할을 한다. 즉 panic으로 중단된 프로그램의 제어를 다시 획득한다. 만약 넘겨진(전파된) panic을 상위함수에서 defer recover로 받는다면 이 또한 패닉 전파를 멈출 수 있다.
```go
package main

import "fmt"

func risky() {
    defer fmt.Println("risky의 defer 실행")
    panic("문제 발생!") // 여기서 패닉
}

func wrapper() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("recover로 패닉 잡음:", r)
        }
    }()
    risky()
    fmt.Println("이 부분은 실행될까?") // recover 덕분에 실행됨
}

func main() {
    wrapper()
    fmt.Println("main까지 정상 복귀")
}
```
- 위의 출력은 아래처럼 나온다. 즉 risky내에서 전파된 panic이 wrapper함수 내에서 recover로 인해 처리되고 이로인해 다시 wrapper함수가 이어서 실행된다.
```go
risky의 defer 실행
recover로 패닉 잡음: 문제 발생!
이 부분은 실행될까?
main까지 정상 복귀
```

# 📌 1. 고루틴
### 📌 1-1. 고루틴 기본
- Go 런타임이 관리하는 경량 실행 단위(lightweight thread)이다
- 여러 일을 동시에(또는 겉보기엔 동시에) 처리하는 동시성을 쉽게 구현
- Go 런타임 스케줄러가 고루틴을 OS 스레드 위에 올려 실행
- 동시성(Concurrency): 작업들을 겉보기엔 동시에 진행되게 스케줄링(빠르게 번갈아 실행).
- 병렬성(Parallelism): 실제로 동시에 실행(코어가 여러 개 필요).
- 예를 들어 js의 async/await는 싱글스레드로 작동하며 논블로킹 I/O + 이벤트 루프만으로 단일 스레드 비동기 처리를 가능하게 한다. 이때이는 병렬이 아니다.
- go의 고루틴에 대해 더 자세히 설명하자면
- OS 스레드: 커널이 생성/스케줄링/컨텍스트 전환을 관리
- 고루틴: Go 런타임이 생성/스케줄링/전환을 관리(유저 레벨)
- 시작 스택 크기
- 스레드: 초기 스택이 커서(일반적으로 MB 단위) 생성 비용/메모리 부담 큼.
- 고루틴: 수 KB 수준의 작은 스택으로 시작 → 필요 시 자동으로 커졌다 줄었다(stack growth/shrink).
- 고루틴은 “OS 스레드를 직접 늘리는 방식”이 아니라, Go 런타임이 소수의 스레드 위에 ‘많은 작업’을 얹어 번갈아 돌리는 방식이다.
- Go에서 함수를 비동기적으로 실행하는 것은 놀랍도록 간단함. 함수 호출 앞에 go 키워드만 붙이면 된다.
```go
func hello() {
    for i := 0; i < 5; i++ {
        time.Sleep(100 * time.Millisecond) // 0.1초 대기
        fmt.Println("Hello from Goroutine!")
    }
}
func main() {
    // 고루틴을 사용한 함수 호출 (비동기 방식)
    go hello() // hello() 함수를 새로운 고루틴에서 실행
    fmt.Println("Hello from main function!")
    // main 함수가 바로 종료되면, 생성된 고루틴이 실행될 기회조차 얻지 못하고 사라짐
    // 이를 방지하기 위해 임시로 1초간 대기 (좋은 방법은 아님)
    time.Sleep(1 * time.Second)
    fmt.Println("Main function finished")
}
```
- 추가로 반복문에서 쓸때는 반복문 특유의 클로저 문제에 대해서 생각해보아야하는데 이 문제가 비동기 문제와 같이 나타나면 더 큰문제가 된다.
- 비동시처리는 실행 순서를 뒤바꾸고 클로저는 함수의 인자를 전부 동일한 값으로 사용하게 만든다.
- 이를 방지하기 위해 변수를 복사하거나 인자로 전달하여(복사됨) 실행하는것이 정석이다
```go
fmt.Println("\n올바른 예 (1): 변수 복사")
    // 올바른 예 (1): 반복 변수를 고루틴 내의 지역 변수로 복사
    for i := 0; i < 3; i++ {
        i := i // 새로운 변수 i에 현재 i의 값을 복사 (Shadowing)
        go func() {
            fmt.Println(i) // 복사된 변수를 사용
        }()
}
    time.Sleep(1 * time.Second)
    fmt.Println("\n올바른 예 (2): 인자로 전달")
    // 올바른 예 (2): 반복 변수를 고루틴 함수의 인자로 전달
    for i := 0; i < 3; i++ {
        go func(val int) {
            fmt.Println(val)
        }(i) // 현재 i의 값을 인자로 전달
    }
time.Sleep(1 * time.Second)
```
- 우선 클로저는 함수가 만들어질 당시의 환경을 의미하며 함수가 만들어질때 주변에 있던 지역변수들까지 함께 묶어서 저장한다. 그러면 함수 안에 정의된 지역변수는 상위 호출함수가 사라지더라도 메모리에 남아있게 되며 해당 함수를 다른 곳에서 실행했을때 그 지역변수를 참조하여 내부 내용을 수행할 수 있다.
- 클로저 문제에 대해 이해하기 위해 아래 내용을 보면
- 첫번째 반복문안에서 배열에 함수를 만들어서 저장한다. 이때 이 함수는 i라는 변수를 출력하는 역할을 한다. 근데 for에 설정한 i는 반복문이 진행됨에 따라 바뀌므로 최종 i의 값은 3이다.
- 물론 함수를 설정하는게 아니라 반복문을 돌면서 그냥 fmt.Println(i)만 실행한다면 바로 012가 출력되겠지만 해당 반복문에서 실행되는건 내부 프린트 함수가 아니라 append함수이다. 이때 함수 내부의 변수는 값을 넣어서 저장하는게 아니라 fmt.Println(i) 이 식 자체를 캡쳐하여 함수로 만든다.(클로저) 이때의 i는 정확히 말하면 i를 가르키는 포인터이며 즉 함수를 직접 실행할때 메모리에 저장된 i값을 참조하게 된다.
- 아래서처럼 함수를 다 만들어 놓고 일괄적으로 실행하면 for문의 지역변수인 i가 클로저 때문에 메모리에 남아있으나 이 i엔 최종값인 3이 저장되어있으므로 결국 이후에 함수를 호출하여 333이 출력되게 된다.
```go
for i := 0; i < 3; i++ {
    funcs = append(funcs, func() {
        fmt.Println(i)
    })
}

for _, f := range funcs {
    f() // 이제야 실행!
}
```

### 📌 1-2. 채널
- 고루틴은 사용자 정의 스레드이므로 이들간에 데이터 왕래가 필요할 수 있다. 또한 한 비동기 작업을 처리하고 다음 비동기 작업을 하는경우 데이터가 이어져야하는데 이런 것들을 구현할 수 있도록 채널이라는 개념이 있다.
- 채널은 고루틴 간에 데이터를 주고받을 수 있는 타입이 지정된 통로이다. <- 연산자를 사용하여 채널에 데이터를 보내거나(ch<- value) 채널로부터 데이터를 받을 수 있다.(value := <-ch)
- ch := make(chan string)로 특정 데이터 타입의 정보를 주고받는 통로를 만들고 이를 go worker에 보낸다. 그러면 wocker는 작업을 처리한 후 ch <- "작업이 성공적으로 끝났습니다." 이런 형식으로 채널을 통해 결과를 리턴한다. 이때 go worker(ch) 이 라인에서 채널로 결과가 돌아올때까지는 다음 작업으로 진행하지 않는다.
- msg := <-ch 이렇게 채널에서 나오는 값을 받아서 이어서 사용할 수 있고 이렇게 값이 나오면 대기가 풀린 후 다음 코드가 실행된다.
```go
// 문자열을 받는 채널을 인자로 받는 함수
func worker(ch chan string) {
    fmt.Println("Worker: 작업 시작...")
    time.Sleep(500 * time.Millisecond) // 작업을 시뮬레이션하기 위해 0.5초 대기
    fmt.Println("Worker: 작업 완료")
    // 채널에 작업 완료 메시지를 보냄
    ch <- "작업이 성공적으로 끝났습니다."
}
func main() {
    // string 타입의 데이터를 주고받을 수 있는 채널 생성
    ch := make(chan string)
    // worker 함수를 고루틴으로 실행하고, 생성한 채널을 넘겨줌
    go worker(ch)
    // 채널로부터 데이터가 수신될 때까지 이 라인에서 대기(blocking)함
    msg := <-ch
    // 데이터가 수신되면 대기가 풀리고 다음 코드가 실행됨
    fmt.Printf("Main: 수신된 메시지 - '%s'\n", msg)
}
```

### 📌 1-3. 여러 개의 고루틴을 한번에 처리
- sync.WaitGroup를 이용하여 여러개의 고루틴을 한번에 처리하고 그동안 메인 시스템이 기다릴 수 있도록한다.
- wg.Add(n): 기다려야 할 고루틴의 수를 n만큼 추가.
- wg.Done(): 고루틴이 작업을 완료했음을 알림. Add로 추가한 카운터를 1 감소시킴. defer와 함께 사용하는 경우가 많
음.
- wg.Wait(): 카운터가 0이 될 때까지 대기.
- 이때 타입이 sync.WaitGroup이다.
```go
// WaitGroup의 포인터와 작업자 ID를 인자로 받는 함수
func workerWithWaitGroup(id int, wg *sync.WaitGroup) {
    
    fmt.Printf("Worker %d: 작업 시작\n", id)
    time.Sleep(100 * time.Millisecond) // 작업 시뮬레이션
    fmt.Printf("Worker %d: 작업 완료\n", id)

    // 함수가 종료될 때 wg.Done()을 호출하여 작업 완료를 알림
    defer wg.Done()
}

func main() {
    // WaitGroup 생성
    var wg sync.WaitGroup
    // 3개의 작업자 고루틴을 실행
    for i := 1; i <= 3; i++ {
        // 기다려야 할 고루틴의 수를 1 증가시킴
        wg.Add(1)
        // worker 함수를 고루틴으로 실행
        go workerWithWaitGroup(i, &wg)
    }
    // 모든 고루틴이 Done()을 호출할 때까지 (카운터가 0이 될 때까지) 대기
    wg.Wait()
    fmt.Println("Main: 모든 작업이 완료되었습니다.")
}
```

### 📌 1-4. 여러 고루틴이 공유지를 사용할 경우
- 여러 고루틴이 비동기적으로 상호배제되어야할 공유지에 접근할 경우 프로그램이 꼬일 수 있다.
- 하여 해당 공유지에 한번에 하나의 고루틴만 접근하도록 lock을 걸어버리는 mutex를 사용한다.
```go
package main

import (
"fmt"
"sync"
)

func main() {
    var wg sync.WaitGroup
    var mu sync.Mutex // 뮤텍스 생성
    counter := 0
    // 1000개의 고루틴을 실행하여 counter를 1씩 증가시킴
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()

            // counter에 접근하기 전에 Lock을 획득
            mu.Lock()

            counter++ // 이 연산은 원자적(atomic)이지 않음

            // Lock을 해제하여 다른 고루틴이 접근할 수 있도록 함
            mu.Unlock()
        }()
    }
    wg.Wait() // 모든 고루틴이 끝날 때까지 대기
    // mu.Lock()/Unlock()을 주석 처리하고 실행하면,
    // 데이터 경쟁으로 인해 counter 값이 1000이 아닐 수 있음.
    fmt.Printf("최종 counter 값: %d\n", counter)
}
```