# 📌 0. pandas 기초
### 📌0-1. csv란
- Comma-Separated Values의 약자로 열은 줄로 행은 콤마로 구분해서 정리해둔 파일을 의미한다.
- 이는 평문 텍스트 파일이다.
- CSV는 그냥 텍스트 파일이라서 어떤 운영체제, 어떤 프로그램에서도 열 수 있어 복잡한 구조 없이 행과 열만 있으면 표현 가능하기 때문에 모든 언어와 도구가 지원하고 가볍고 저장공간 효율이 높기 때문에 보통 csv 파일을 많이 사용한다.
```pgsql
name,age,city
Alice,23,Seoul
Bob,30,Busan
```

### 📌0-2. series와 dataframe
- Series: “라벨 붙은 1차원 배열” = index ⟶ value 함수
- 한 컬럼, 한 축, 하나의 dtype
- DataFrame: “Series들의 정렬된 사전” + “공유 행 인덱스”
- 열마다 dtype 다를 수 있음
- 표 연산(집계·피벗·머지) 최적화
- 판다스는 이 series와 dataframe을 (내부적으로 행렬과 같다.) numpy기반으로 행렬 연산을 수행하기 때문에 일일히 곱하는 연산보다 더 빠르다. -> 백터화 연산
```py
odd = [1, 3, 5, 7, 9]
pd_odd = pd.Series(odd)
print(odd, pd_odd)

numbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
pd_numbers = pd.DataFrame(numbers, columns=['col1','col2','col3'])   # 데이터프레임은 행렬, 2차원 구조라고 함
print(pd_numbers)
```

# 📌 1. 파일 읽기
### 📌0-1. 기본명령
- pd.read_csv("/content/weight_log.csv")로 읽어들이면 이는 dataframe 자료형에 해당한다.
- 아래서 사용하는 data 아래의 함수들이나 접근은 모두 dataframe 객체에 접근하는 것이다.
```py
import pandas as pd

# 이때 data는 dataframe 자료형
data = pd.read_csv("/content/weight_log.csv") 
```
- shape은 해당 데이터 프레임의 행과 열 정보를 가지고 있는 속성이다.
- columns는 열들과 열들의 데이터 타입을 출력한다. 이때 object는 문자열을 의미한다.
- index는 각 행의 인덱스 정보를 출력한다.
- info는 해당 데이터 프레임의 기본 정보를 표시해준다.
- describe는 기술통계 정보를 보여준다. 평균, 표준편차, 최대최소값, 분위수 등
- head : 기본값 5개, 전달한 매개변수만큼 위에서부터 자료를 보여준다.
- tail : 기본값 5개, 전달한 매개변수만큼 아래에서부터 자료를 보여준다.
- Percentile은 분위수를 의미한다.
```py
print(data.shape)   # 몇개 행과 열이 있는지 알려준다. (9, 7)
print(data.columns) # Index(['회차', '이름', '측정일', '몸무게', '단위', '담당', '지점'], dtype='object')
print(data.index)

data.info() # 해당 데이터 프레임의 기본 정보를 표시해준다.
data.describe() # 기술통계 정보를 보여준다. 평균, 표준편차, 최대최소값, 분위수 등
data.describe(percentiles=[0.1, 0.9]) 
data.head(2) # 기본값 5개, 전달한 매개변수만큼 위에서부터 자료를 보여준다.
data.tail(3) # 기본값 5개, 전달한 매개변수만큼 아래에서부터 자료를 보여준다.
```

### 📌 0-2. dataframe의 행열기준조회
- loc는 전체 컬럼이 아닌 특정 컬럼만 선택적으로 보고 싶을 경우 주로 사용한다.
- 데이터 프레임에 []안에 열이름이나 열이름을 여러개 저장한 리스트를 넣으면 해당 열들에 해당하는 정보들만 선택한다.
- 파이썬에서 obj[key] 이 표현은 단순한 문법이 아니라, 내부적으로 obj.__getitem__(key) 라는 호출로 바뀌게 된다.
- 즉 []는 문법이 아니라 __getitem__ 메서드 호출이다.
- 이때 loc는 data의 속성이지만 이는 속성이면서 실제로는 _LocIndexer 클래스 객체이고 이 객체 내부에 __getitem__ 메서드를 오버라이드하여 입력에 따라 다양한 탐색이 가능하도록 구현되어 있어 이것이 가능한 것이다.
- 판다스는 dataframe의 []를 행(row)/열을 라벨(label) 기반으로 다루도록 조건을 세밀하게 분기해두어서 이를 sql처럼 유연하게 동작하도록 설계해두었다.
- 숫자 혹은 슬라이싱을 사용하면 인덱스 기준으로 행열에 접근이 가능하다.
```py
data["담당"]
col = ["몸무게","지점"]
data[col].head(3) # data에 리스트를 넣으면 해당하는 열을 모두 확인할 수 있다.

# index 기준 조회
data.loc[3] # index는 location을 의미한다.
data.loc[[3,6,7]]
data.loc[3:5] # 슬라이싱
data.loc[::-1] # 이것도 되긴 하네
# 문법에서 어떻게 키값으로 자료형을 받는거야 
```
- 아래 처럼 행과 열을 정확히 지정해주면 해당하는 소스를 정확히 제공받을 수 있다.
```py
# index & colummns
data.loc[3, "몸무게"] # lco[행-열]
data.loc[[3,6,7], ["몸무게", "단위"]]
```

### 📌0-3. dataframe의 조건에 의한 데이터 조회 <- boolean index방식
- 02번과 03번은 by label 방식이다.
- data["지점"] == "서초구" 이건 그자체로 boolean인것이 자명하다.
```py
data["지점"] == "서초구" # 맞는건 false 아닌 건 true로 내부에서 인식 = sql에서 where문 값은 것
data[data["지점"] == "서초구"] # select '지점' from data where '지점' == '서초구'; 
data.loc[data["지점"] == "서초구", ["담당", "지점"]]
```
- 아래처럼 boolean은 loc에 넣으면 조건에 맞는 값만 뽑아올 수 있다.
- and는 & or 는 |로 사용한다.
- boolean 연산을 할때는 이 boolean들을 괄호로 쳐서 구분해두어야한다.
```py
# 지점이 강남구, 서초구 중에서 몸무게 75조가 큰 데이터 조회 
# and는 & or 는 |로 사용한다.
# boolean 연산을 할때는 이 boolean들을 괄호로 쳐서 구분해두어야한다.
data.loc[(data["지점"] == "강남구") | (data["지점"] == "서초구") & (data["몸무게"] >= 76.0)]
```

### 📌0-4. by position 
- 아래는 by position 방법이다. -> 열이름이 바뀌어도 자리기준으로 계속 자료를 해석할 수 있다.
- iloc는 인덱스 기준으로 가져온다.
- 이 또한 행열 순으로 리스트를 제공하면 해당 행의 위치, 해당 열의 위치에 해당하는 값들을 반환한다.
```py
data.iloc[[4,5], [5,6]]
data.loc[4:5].iloc[0,[5,6]]
```

### 📌0-5. 결측치 확인
- missing values 결측치 확인, 처리 방법
- is는 질문을 던지는 함수들이다. -> true, false로 답이 온다.
- data.isna().sum()은 true 는 1, false는 0으로 해서 데이터의 합을 구한다.
- axis=0이 sum의 기본값인데 열기준으로 합을 구한다. axis를 1로 주면 다음 축을 선택할 수 있다.
- data[data["몸무게"].isna()]로 아래 데이터들만 직접 확인할 수 있다.
```py
data.info() # RangeIndex와 해당 데이터 개수 비교
data.isna().sum(axis=0)

# 참고: 
data[data["몸무게"].isna()]
```

### 📌0-6. 결측치 처리
- dataframe의 .fillna 함수를 사용하여 특정 값으로 na값을 채울 수 있다.
- 이때 아래 함수를 활용하여 평균, 중위수, 중앙값, 최대최소등의 값을 미리 저장해두고 이를 대입하여 사용할 수도 있다.
- data["몸무게"].fillna(75.83) 이렇게 처리된 열을 data = data["몸무게"].fillna(75.83)이렇게 밀어넣으면 저장된다. 그냥 data["몸무게"].fillna(75.83)만 하면 이렇게 처리된 열을 보여주는 것밖에 되지 않는다.
```py
data["몸무게"].mean()
data["몸무게"].min()
data["몸무게"].max()
data["몸무게"].median()
data["몸무게"].quantile(0.25)
data["몸무게"].quantile(0.75)

# 결측치 처리
data["몸무게"].fillna(75.83)
```
- 이때 원본을 웬만하면 훼손하지 않는 것이 좋으므로 아래처럼 data["몸무게"].fillna(75.83) 이렇게 처리된 열을 data["몸무게(결측처리)"]에 넣어서 처리한다.
```py
# 컬럼 추가 
data["몸무게(결측처리)"] = data["몸무게"].fillna(75.83)
data.head()
```
- 아래는 컬럼을 삭제하는 방법이다.
```py
data.drop(columns=["몸무게(결측처리)", "단위"])
```
