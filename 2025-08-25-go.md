# 📌 0. go 파일 입출력
### 📌 0-1. 기본 go 방식 파일입출력
- os.Open으로 os에 파일 오픈을 요청해서 이를 가져온다.
- scanner := bufio.NewScanner(os.Stdin)
- → os.Stdin(표준 입력)을 읽을 수 있는 스캐너를 만든다.
- → 파일을 대상으로 하고 싶으면 os.Open("파일명")을 열어서 그 파일 객체를 넣으면 된다.
- scanner.Scan()
- → 입력에서 **다음 토큰(token)**을 읽는다. 기본값은 한 줄(line) 단위.
- → 새로운 입력이 있으면 true, 더 이상 없으면 false를 반환한다.
- scanner.Text()
- → 방금 읽은 줄(토큰)을 문자열로 돌려준다.
```go
file, err := os.Open("data.txt")
if err != nil {
    log.Fatal(err)
}
defer file.Close()
scanner := bufio.NewScanner(file)
for scanner.Scan() {
    fmt.Println(scanner.Text())
}
```

### 📌 0-2. 파일쓰기
- os.Create 함수는 새로운 파일을 생성하거나, 같은 이름의 파일이 이미 있으면 내용을 비워서(Truncate) 다시 쓰기 시작하도록 준비
- ../example.txt: 현재 실행 중인 프로그램의 **상위 디렉터리(..)**에 example.txt 파일을 만들어라
- bytesWritten, err := file.Write(data)로 data := []byte("Go 언어 파일 입출력 실습\n첫 번째 줄입니다.\n두 번째 줄입니다.") 이렇게 만든 바이트 슬라이스를 받아서 파일에 씀
- file.Sync()를 호출하면 → OS에게 “지금 당장 디스크에 확실히 기록해라”라고 요청.
```go
func main() {
    // 1. 파일 생성: os.Create()는 파일을 생성하거나 기존 파일을 덮어씀
    // Java의 new FileOutputStream("example.txt")와 유사함
    file, err := os.Create("../example.txt")

    if err != nil {
        fmt.Println("파일 생성 실패:", err)
        return // Java의 throw new IOException()과 유사한 에러 처리
    }

    // 2. defer를 사용한 리소스 관리: Java의 try-with-resources와 유사
    // 함수가 종료될 때 자동으로 파일이 닫힘
    defer file.Close()

    // 3. 파일에 쓸 데이터 준비: Go는 바이트 슬라이스를 사용
    // Java의 byte[] 배열과 유사하지만 더 유연함
    data := []byte("Go 언어 파일 입출력 실습\n첫 번째 줄입니다.\n두 번째 줄입니다.")

    // 4. 파일에 데이터 쓰기: Write 메서드는 바이트 슬라이스를 받음
    // Java의 OutputStream.write(byte[])와 동일한 역할
    bytesWritten, err := file.Write(data)
    if err != nil {
        fmt.Println("파일 쓰기 실패:", err)
        return
    }

    // 5. 결과 출력 및 동기화
    fmt.Printf("파일에 %d 바이트를 성공적으로 썼습니다.\n", bytesWritten)

    // 6. 파일 버퍼를 디스크에 강제로 쓰기 (Java의 flush()와 유사)
    err = file.Sync()

    if err != nil {
        fmt.Println("파일 동기화 실패:", err)
        return
    }

    fmt.Println("파일 쓰기 완료")
}
```

### 📌 0-3. 기본 파일 읽기
- content, err := io.ReadAll(file)로 모든 파일의 내용을 읽어온다.
```go
func main() {
// 1. 파일 열기: os.Open()은 읽기 전용으로 파일을 엶
// Java의 new FileInputStream("example.txt")와 유사
file, err := os.Open("../example.txt")
if err != nil {
    fmt.Println("파일 열기 실패:", err)
    return // Java의 FileNotFoundException 처리와 유사
}

// 2. defer로 파일 닫기 보장
defer file.Close()

// 3. 파일 전체 내용 읽기: io.ReadAll()은 파일의 모든 내용을 메모리로 읽음
// 작은 파일에 적합하며, Java의 Files.readAllBytes()와 유사
content, err := io.ReadAll(file)
if err != nil {
    fmt.Println("파일 읽기 실패:", err)
    return
}

// 4. 읽은 내용 출력: 바이트 슬라이스를 문자열로 변환
// Java의 new String(bytes, StandardCharsets.UTF_8)와 유사
fmt.Println("파일 내용:")
fmt.Printf("--- 시작 ---\n%s\n--- 끝 ---\n", string(content))

// 5. 파일 크기 정보 출력
fmt.Printf("총 %d 바이트를 읽었습니다.\n", len(content))
}
```

### 📌 0-4. 버퍼를 사용한 파일처리
```go
func main() {
    // 1. 먼저 테스트용 대용량 파일 생성
    createLargeFile()

    // 2. 버퍼를 사용한 라인별 읽기
    readFileLineByLine()
}

// 테스트용 파일 생성 함수
func createLargeFile() {
    file, err := os.Create("../large_file.txt")

    if err != nil {
        fmt.Println("대용량 파일 생성 실패:", err)
        return
    }

    defer file.Close()

    // bufio.Writer를 사용하여 버퍼링된 쓰기 (Java의 BufferedWriter와 유사)
    writer := bufio.NewWriter(file)

    // 1000줄의 텍스트 데이터 생성
    for i := 1; i <= 1000; i++ {
        line := fmt.Sprintf("이것은 %d번째 줄입니다. 버퍼링된 파일 처리를 테스트합니다.\n", i)

        // WriteString은 문자열을 바로 쓸 수 있는 편의 메서드
        _, err := writer.WriteString(line)
        if err != nil {
            fmt.Println("라인 쓰기 실패:", err)
            return
        }

    }
    // 버퍼의 내용을 파일에 플러시 (Java의 BufferedWriter.flush()와 동일)
    err = writer.Flush()

    if err != nil {
        fmt.Println("버퍼 플러시 실패:", err)
        return
    }

    fmt.Println("테스트용 대용량 파일 생성 완료")
}

// 라인별 파일 읽기 함수
func readFileLineByLine() {
    file, err := os.Open("../large_file.txt")

    if err != nil {
        fmt.Println("파일 열기 실패:", err)
        return
    }

    defer file.Close()

    // bufio.Scanner를 사용한 라인별 읽기 (Java의 Scanner와 유사)
    scanner := bufio.NewScanner(file)
    lineCount := 0

    // Scan() 메서드는 다음 토큰(기본적으로 라인)이 있으면 true 반환
    // Java의 Scanner.hasNextLine()과 유사한 패턴
    for scanner.Scan() {

    lineCount++

    line := scanner.Text() // 현재 라인의 텍스트 반환 (개행문자 제외)
    // 처음 5줄과 마지막 5줄만 출력 (메모리 효율성 시연)
    if lineCount <= 5 || lineCount > 995 {
            fmt.Printf("라인 %d: %s\n", lineCount, line)
        } else if lineCount == 6 {
            fmt.Println("... (중간 라인들 생략) ...")
        }
    }

    // 스캔 과정에서 발생한 에러 확인 (EOF는 정상적인 종료이므로 에러가 아님)
    if err := scanner.Err(); err != nil {
        fmt.Println("파일 스캔 중 에러 발생:", err)
        return
    }

    fmt.Printf("\n총 %d줄을 처리했습니다.\n", lineCount)
}
```

### 📌 0-5. JSON파일 처리
- marshal은 직렬화를 의미한다. Indent는 들여쓰기를 의미하는데 이는 데이터를 사람이 읽기 좋게하여 출력해준다.
- MarshalIndent의 첫번째 인자는 바꿀 JSON 데이터이고 두번째 인자는 각줄의 접두사이며 세번째 인자는 들여쓰기 문자이다. 이는 보통 탭이나 스페이스바 두개를 사용한다.
```go
func main() {
    jsonData, err := json.MarshalIndent(config, "", " ")
    if err != nil {
        fmt.Println("JSON 변환 실패:", err)
        return
    }

    // 3. JSON 데이터를 파일에 쓰기: os.WriteFile()은 한 번에 파일 쓰기 완료
    // Java의 Files.write()와 유사하지만 더 간단함
    err = os.WriteFile("../users.json", jsonData, 0644) // 0644는 파일 권한 (rw-r--r--)
    if err != nil {
        fmt.Println("파일 쓰기 실패:", err)
        return
    }

    fmt.Println("JSON 파일 생성 완료: users.json")
    fmt.Printf("파일 크기: %d 바이트\n", len(jsonData))

    // 4. 생성된 JSON 내용의 일부를 콘솔에 출력
    fmt.Println("\n생성된 JSON 내용:")
    fmt.Println(string(jsonData))
}
```

### 📌 0-6. JSON을 구조체에 매핑하기
- Unmarshal로 JSON을 역직렬화하여 구조체에 값을 저장한다.
- err = json.Unmarshal(jsonData, &config)에서 두번째 인자로 넘긴 구조체의 주소를 찾아가서 값을 매핑한다.
```go
func main() {
    // 1. JSON 파일 읽기: os.ReadFile()은 파일 전체를 바이트 슬라이스로 읽음
    // Java의 Files.readAllBytes()와 동일한 기능
    jsonData, err := os.ReadFile("../users.json")

    if err != nil {
        fmt.Println("파일 읽기 실패:", err)
        fmt.Println("먼저 JSON 파일 쓰기 예제를 실행하세요.")
        return
    }

    // 2. JSON 데이터를 구조체로 변환: json.Unmarshal()로 역직렬화
    // Java의 ObjectMapper.readValue()와 유사
    // 두 번째 매개변수는 포인터여야 함 (값을 직접 수정하기 위해)
    var config UserConfig
    err = json.Unmarshal(jsonData, &config)
    if err != nil {
        fmt.Println("JSON 파싱 실패:", err)
        return
    }
}
```

# 📌 1. context
### 📌 1-1. context 기본
- 고루틴 간에 “취소, 시간제한, 값 전달” 같은 제어 신호를 공유하는 도구이다.
- context는 크게 세가지 기능을 하는데 이는 취소 신호 전파, 타임아웃/데드라인 설정, 값 전달이다.

| 함수 / 메서드                               | 파라미터                                                           | 리턴값               | 설명                                             |
| -------------------------------------- | -------------------------------------------------------------- | ----------------- | ---------------------------------------------- |
| `context.Background()`                 | 없음                                                             | `context.Context` | 비어있는 최상위 컨텍스트를 반환. 보통 `main` 함수나 요청의 시작점에서 사용됨 |
| `context.WithValue(parent, key, val)`  | `parent context.Context`, `key interface{}`, `val interface{}` | `context.Context` | 부모 컨텍스트에 키-값 쌍을 저장한 새로운 자식 컨텍스트를 반환            |
| `(ctx Context).Value(key interface{})` | `key interface{}`                                              | `interface{}`     | 컨텍스트 체인을 따라 올라가며 주어진 키에 해당하는 값을 찾아 반환          |

- type requestIDKey string 는 문자열을 받는 새로운 데이터 타입 즉 사용자 정의 타입을 만든 것이다.
- 이는 WithValue 인자에 아무 값이나 들어갈 수 있는데 이때 그냥 string을 키로 쓰면 다른 string 값들이랑 충돌이 날 수도 있기때문에 오직 이 유형만 받는 다는 의미로 새로운 타입을 정의하여 사용한다.
```go
type requestIDKey string

func processRequest(ctx context.Context) {
    // 2. 컨텍스트에서 "requestID" 키로 값을 조회
    id, ok := ctx.Value(requestIDKey("requestID")).(string)

    if !ok {
        id = "unknown"
    }

    fmt.Printf("Processing request with ID: %s\n", id)
}

    func main() {
    // 3. 비어 있는 최상위 컨텍스트 생성
    ctx := context.Background()

    // 4. 컨텍스트에 "requestID"와 값 "12345"를 저장
    ctxWithID := context.WithValue(ctx, requestIDKey("requestID"), "12345")

    // 5. 값이 저장된 컨텍스트를 함수에 전달
    processRequest(ctxWithID)
}
```

### 📌 1-2. 취소신호 전파
- 우선 select 문법은 switch와 비슷해보이지만 채널의 준비상태에 따라 분기한다.
- 이때 각 case는 송수신연산이어야 한다.
- 해당 case에 해당하는 동작을 할 수 있으면 해당 동작을 수행하고 아래 코드를 실행한다.
- default는 위의 어떤 채널도 준비되지 않았을 때 실행이다.
- ctx, cancel := context.WithCancel(ctx) 이렇게 하면 해당 컨택스트를 만들면서 이 컨택스트를 종료할 수 있는 cancel 함수를 같이 반환한다.
- 이후 이 함수가 호출되면 해당 컨텍스트들에 ctx.Done() 즉 취소 신호를 송신한다.
```go
func worker(ctx context.Context, name string) {
    for {
        select {
        case <-ctx.Done(): // 취소 신호 수신
            fmt.Printf("[%s] 작업 중단: %v\n", name, ctx.Err())
            return
        default:
            fmt.Printf("[%s] 작업 진행 중...\n", name)
            time.Sleep(500 * time.Millisecond)
        }
    }
}

func main() {
    // 1. 최상위 컨텍스트 생성
    ctx := context.Background()

    // 2. 취소 가능한 컨텍스트 생성
    ctx, cancel := context.WithCancel(ctx)

    // 3. 두 개의 worker 고루틴 실행
    go worker(ctx, "A")
    go worker(ctx, "B")

    // 4. 2초 뒤 작업 취소
    time.Sleep(2 * time.Second)
    fmt.Println("메인: 취소 신호 전송")
    cancel()

    // 5. 고루틴 종료 대기
    time.Sleep(1 * time.Second)
}
```
- 이를 타임아웃으로 사용하면 특정 시간이 지났을때 함수의 활동을 멈출 수 있다.
- 컨텍스트를 생성할때 미리 시간을 주고 타임아웃을 설정해둘 수 있다.
- 방법은 이와같다. ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
```go
package main

import (
    "context"
    "fmt"
    "time"
)

func task(ctx context.Context) {
select {
    case <-time.After(3 * time.Second): // 3초 걸리는 작업 --> 타임아웃이 먼저 발생하여 실행되지 않음
    fmt.Println("작업 완료")

    case <-ctx.Done(): // 타임아웃 또는 취소
    fmt.Println("작업 중단:", ctx.Err())
}
}

func main() {
    // 타임아웃 2초짜리 컨텍스트
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()
    task(ctx)
}
```

# 📌 2. 암호화
### 📌 2-1. go언어 암호처리

| 항목      | Go (`crypto` 패키지)    | Java (`java.security`, `javax.crypto`) |
| ------- | -------------------- | -------------------------------------- |
| 철학      | 단순하고 직관적, 직접 조립해서 사용 | 포괄적이고 설정이 많음, Provider 모델 사용           |
| 주요 알고리즘 | ECDSA, RSA, SHA256   | EC, RSA, SHA256                        |
| 사용 편의성  | 코드가 짧고 직관적           | 상대적으로 복잡하고 장황함                         |

- 개인키 (Private Key): “나만 할 수 있는 동작”에 사용됨. (복호화, 서명)
- 공개키 (Public Key): “나만 할 수 있는 동작”에 사용됨. (암호화, 서명 검증)
- ecdsa.GenerateKey는 사용할 타원곡선 elliptic.P256()와 안전한 난수 rand.Reader를 사용하여 개인키를 만든다.
- 이후 이 개인키를 이용해 &privateKey.PublicKey로 공개키를 만든다.
- 보통 해시에다가 서명을 하므로 sha256.Sum256(data) = 데이터를 SHA-256으로 해싱 → [32]byte 배열 반환하여 값을 가지고 있는다.
- hash[:]는 배열 전체를 가리키는 슬라이스를 만드는 문법이고 SignASN1함수는 인자로 슬라이스를 요구한다.
- 이 서명을 생성하면 공개키와 이 메세지에 대한 해시가 있다면 참 거짓을 검증할 수 있게된다.
- 공개키 (누구나 볼 수 있음)
- 메시지의 해시값 (원문을 해시한 결과)
- 서명값 (개인키로 만든 결과)
- 위의 세개가 있으면 verify 함수에 저 셋을 넣고 맞는지 검증할 수 있다.
```go
func main() {
    // 1. 키 생성
    privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)

    if err != nil {
        log.Fatal(err)
    }

    publicKey := &privateKey.PublicKey

    // 키 출력
    fmt.Println("Private Key:", privateKey)
    fmt.Println("Public Key:", publicKey)

    // 2. 메시지 준비 및 해시
    message := []byte("hello world")
    hash := sha256.Sum256(message)
    fmt.Println("메시지 해시:", hash)

    // 3. 서명 생성
    signature, err := ecdsa.SignASN1(rand.Reader, privateKey, hash[:])

    if err != nil {
        log.Fatal(err)
    }

    fmt.Println("서명:", signature)

    // 4. 검증
    valid := ecdsa.VerifyASN1(publicKey, hash[:], signature)
    if valid {
        fmt.Println(">>> 서명 검증 성공!")
        fmt.Println(">>> 원문 메시지:", string(message))
    } else {
        fmt.Println(">>> 서명 검증 실패!")
    }

    // 5. 변조된 메시지 테스트
    fakeMessage := []byte("hello gopher")
    fakeHash := sha256.Sum256(fakeMessage)
    fakeValid := ecdsa.VerifyASN1(publicKey, fakeHash[:], signature)
    fmt.Printf(">>> 변조 메시지 검증 결과: %v\n", fakeValid)
}
```