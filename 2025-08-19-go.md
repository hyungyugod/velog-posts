# 📌 0. go언어 컬렉션
- 배열 (Array), 슬라이스 (Slice), 맵 (Map)
### 📌 0-1. 배열
- go언어의 배열은 값 타입이고 자바의 배열은 참조타입이다. 

| 언어         | 배열/시퀀스 자료형    | 값/참조 성격       | 대입/함수 전달 시 동작                              | 특징                      |
| ---------- | ------------- | ------------- | ------------------------------------------ | ----------------------- |
| **C**      | 배열 `int a[3]` | **값(메모리 블록)** | 함수에 넘길 때 자동으로 **포인터**로 decay (사실상 참조처럼 동작) | 크기 고정, 스택/전역 메모리에 연속 저장 |
| **Go**     | 배열 `[3]int`   | **값 타입**      | 대입/전달 시 **전체 복사**                          | 길이까지 타입의 일부, 비교 가능      |
| **Java**   | 배열 `int[]`    | **참조 타입**     | 대입/전달 시 **참조 복사**                          | 힙 객체, 참조 공유, null 가능    |
| **Python** | 리스트 `list`    | **참조 타입**     | 대입/전달 시 **참조 복사**                          | 동적 크기, 다양한 타입 혼합 가능     |

### 📌 0-2. 슬라이스
- 함수에 인자를 전달할 때, 변수의 “값”을 복사해서 전달하는 방식.
- 함수 안에서 인자를 변경해도 원래 변수에는 영향이 없음.
- Go 언어는 모든 함수 호출이 call by value 이다. (java는 무조건 call by reference)
- 사실 자바도 객체 이름이 힙에 있는 객체의 주소를 가르키는 값이 스택에 저장되어있고 이 값이 변수에 저장되어있는 것이므로 값을 복사하는데 일종의 포인터가 복사되어 참조로 되는 것이다. 
- 슬라이스, 맵, 채널 같은 타입은 내부적으로 포인터 같은 참조를 포함한 작은 구조체.
이 구조체 자체는 값으로 복사되지만, 내부에 담긴 참조는 원본을 가리키므로 함수 안에서 원소를 바꾸면 호출자에게도 보임.
- 슬라이스의 구조는 아래와 같다.
```go
type slice struct {
    array unsafe.Pointer // 배열 시작 주소
    len   int            // 길이
    cap   int            // 용량
}
```
- []int{4, 5, 6}은 사실 길이 3짜리 배열을 힙에 하나 생성하고, 그 배열을 가리키는 슬라이스 헤더(ptr, len=3, cap=3)를 만든 것이다.
- var nilSlice []int의 nil 슬라이스는 내부 배열주소를 가리키는 포인터 값이 nil임을 의미한다. 따라서 len이나 cap을 사용할 수 있고 append(nilSlice, 1,2,3) 처럼 새롭게 할당하면 nil값에 새로 할당되므로 문제없이 이어서 사용할 수 있다.
- 아래는 append의 기능이다.
- cap 안에서 추가 가능할 때
- 기존 backing array 에 값을 집어넣고 슬라이스 헤더(len)만 늘린다. → 같은 배열을 계속 가리킴.
- cap을 초과할 때
- Go 런타임이 새 배열을 더 큰 용량(cap)으로 할당한다. -> 기존 원소들을 새 배열로 copy한다. -> 새 배열의 주소를 가리키도록 슬라이스 헤더의 ptr을 갱신한다.
- len은 늘어난 길이로 조정.
- go 배열 리터럴: ...을 사용하여 컴파일러가 초기화 값의 개수에 따라 배열 크기를 자동 추론하게 한다.
```go
func main() {
	var arr1 = [3]int{1, 2, 3}
	fmt.Println("배열 arr1", arr1)

	// go 배열 리터럴: ...을 사용하여 컴파일러가 초기화 값의 개수에 따라 배열 크기를 자동 추론하게 한다.
	arr2 := [...]string{"apple", "banana", "cherry"}
	fmt.Println("배열 arr2", arr2)

	modifyArray(arr1)
	fmt.Println("modifyArray 호출 후 arr1 (변화없음),", arr1)

	slice1 := []int{4, 5, 6}
	fmt.Println("슬라이스 slice1:", slice1)

	slice2 := make([]int, 5)
	fmt.Println("슬라이스2 make로 생성", slice2)

	slice3 := make([]string, 0, 10)
	fmt.Println("슬라이스3(길이 0, 용량 10)", slice3)

	var nilSlice []int
	fmt.Printf("nilSlice: %v, 길이: %d, 용량: %d\n", nilSlice, len(nilSlice), cap(nilSlice))
	if nilSlice == nil { // nil 슬라이스는 `nil`과 비교할 수 있다.
	fmt.Println("nilSlice는 nil이다.")
	}
}

func modifyArray(arr [3]int) {
	arr[0] = 99 // 복사된 배열의 첫 번째 요소를 변경
	fmt.Println("modifyArray 내부:", arr)
}

func modifySlice(s []int) {
	s[0] = 99
	fmt.Println("modifySlice 내부:", s)
}
```

### 📌 0-3. map
- go에서 map을 생성할때는 역시 빈값으로 생성할 수도, 값을 채워서 생성할 수도 있다.
- 값을 가져오는건 역시 키값으로 접근한다.
- 값을 삭제하는건 delete(playerStats, "Mana")함수를 사용하여 키값을 지정해 삭제한다.
```go
scores := map[string]int{"Alice": 90, "Bob": 85}
playerStats := make(map[string]int)
mana := playerStats["Mana"]
delete(playerStats, "Mana")
```

### 📌 0-4. 슬라이싱
- Go에서 ... 은 가변 인자(unpack, variadic expansion) 를 뜻한다.
- 자주 설명글에서 나오는 T는 타입(Type) 의 약자로 어떤 타입이든 올 수 있음을 의미한다. K : Key, V : Value, E : Element, R : Result / Return type 등도 있다.
- 여기서 nums... 은 슬라이스를 풀어헤쳐서 가변 인자 함수에 맞게 넣어주는 문법.
- 이건 단순히 구조분해라기보다, “가변 인자로 풀어 전달”하기 위해 특별히 제공되는 문법이다.
- 원래 func append(slice []T, elems ...T) []T로 append가 정의되어있어 두번째 인자를 여러개 풀어서 넣을 수 있게 가변인자로 설정해 두었는데 하여 이 형식에 맞춰서 두번째 인자를 풀어서 전달하는 것이다.
- 즉 정의 쪽 ... → 가변 인자 함수 선언 (여러 인자를 슬라이스로 받음).
- 호출 쪽 ... → 슬라이스를 “펼쳐서” 가변 인자 함수에 전달. 이다.
- go언어도 기본적으로 슬라이싱이 가능한데 아는 배열, 슬라이스 모두 가능하다. 다만 결과물은 모두 슬라이스이다.
```go
func append(slice []T, elems ...T) []T
sliceToDelete = append(sliceToDelete[:1], sliceToDelete[2:]...)
```

### 📌 0-5. 컬렉션 순회
- range를 통해 컬렉션을 순회하면 값을 인덱스와 벨류로 분리해서 떨궈준다. 이때 사용하지 않으면 에러가 나므로 만약 인덱스나 값 중 하나를 사용하지 않는다면 값을 _로 표시하여 사용하지 않는 값임을 밝히면 에러가 뜨지 않는다.
- 맵을 순회하면 값을 키와 벨류로 리턴해주고 문자열은 각 글자를 리턴한다.
- 이때 문자열의 인덱스는 utf8부터 모든 언어 불문 한글자당 3바이트이므로 0부터 3의 배수로 형성된다.
- 배열 순회는 슬라이스 순회와 비슷하다.
- range에서 값을 꺼내서 할당할때는 타입을 자동 지정하는게 편하므로 짧은 변수 선언 :=를 사용한다.
```go
/** 슬라이스 순회 */
numbers := []int{10, 20, 30, 40, 50}
fmt.Println("--- 슬라이스 순회 ---")
for i, num := range numbers {
    fmt.Printf("인덱스: %d, 값: %d\n", i, num)
}
fmt.Println("순회 후 슬라이스 (변화 없음):", numbers)

for _, num := range numbers {
    fmt.Println("값:", num)
}

/** 맵 순회 */
scores := map[string]int{"Alice": 90, "Bob": 85, "Charlie": 95}
fmt.Println("--- 맵 순회 ---")
for name, score := range scores {
    fmt.Printf("학생: %s, 점수: %d\n", name, score)
}

 fmt.Println("--- 맵 키만 순회 ---")

for name := range scores {
    fmt.Println("학생:", name)
}

/** 문자열 순회 */
koreanString := "안녕하세요"
fmt.Println("--- 문자열 순회 ---")
for i, r := range koreanString {
    fmt.Printf("인덱스: %d, 룬(문자): %c, 유니코드 값: %U\n", i, r, r)
}

/** 배열 순회 (슬라이스와 유사) */
arr := [3]string{"A", "B", "C"}
fmt.Println("--- 배열 순회 ---")
for i, val := range arr {
    fmt.Printf("인덱스: %d, 값: %s\n", i, val)
}
```

# 📌 1. go언어 코딩테스트
### 📌 1-1. 분수의 덧셈
- 웬만하면 슬라이스로 만드는게 좋고 배열타입, 길이로 일단 만든다. 
- 이때 세 번째 인자를 안 주면 cap = len이다.
- 배열을 선언하려면 arr := [2]int{} 이렇게 그냥 값없이 선언하고 나중에 할당하면 된다.
- 데이터 타입 뒤에 쓰는것과 if에 중괄호 묶는 것을 유의해야한다.
```go
func solution(numer1 int, denom1 int, numer2 int, denom2 int) []int {
    answer := make([]int, 2)
        n3 := numer1 * denom2 + denom1 * numer2
        d3 := denom1 * denom2
        g := gcd(n3, d3)

        answer[0] = n3/g
        answer[1] = d3/g
        
        return answer
}

func gcd(a int, b int) int {
    if b == 0 {return a}

        return gcd(b, a % b)
    }
```

### 📌 1-2. 아이스 아메리카노
- func solution(money int) []int 이렇게 되어있으면 []int는 리턴타입이 슬라이스임을 의미한다.
- 아래처럼 먼저 슬라이스 선언 -> 각각 값 할당이던가
- 빈 슬라이스 생성 answer := []int{} 후
- answer = append(answer, money/5500, money%5500)로 채우는 방법 두가지가 있다 아래는 전자
```go
func solution(money int) []int {
    answer := make([]int,2)
    answer[0] = money/5500
    answer[1] = money%5500
    return answer
}
```
- 아래는 후자이다.
```go
func solution(money int) []int {
    answer := []int{} // 빈 슬라이스
    answer = append(answer, money/5500, money%5500)
    return answer
}
```

### 📌 1-3. 배열 회전시키기
- 첫번째 인자는 무조건 슬라이스여야하기 때문에 []int{numbers[n-1]} 이렇게 슬라이스로 써주거나 numbers[1:] 이렇게 구조분해 없이 써주어야한다.
- append는 그냥 사용한다 answer.append 이런식이 아니다
```go
func solution(numbers []int, direction string) []int {
    answer := []int{}
    n := len(numbers)

    if direction == "right" {
        answer = append([]int{numbers[n-1]}, numbers[:n-1]...)
    } else {
        answer = append(numbers[1:], numbers[0])
    }
    return answer
}
```

### 📌 1-4. 배열 뒤집기
- num_list[start++] go는 옆처럼 못쓴다.
- 무조건 정석대로 따로 분해해서 써주어야한다.
```go
func solution(num_list []int) []int {
    start := 0
    end := len(num_list) - 1

    for start < end {
        tmp := num_list[start]
        num_list[start] = num_list[end]
        num_list[end] = tmp

        start++  
        end--
    }
    return num_list
}
```

### 📌 1-5. 중복된 숫자 개수
- 인덱스랑 값 따로 데이터 타입 넣어주기 귀찮으니까 그냥 :=로 하자
- for _, i := range array
```go
func solution(array []int, n int) int {
    answer := 0
    for _, i := range array{
        if (i == n){
            answer++
        }
    }
    return answer
}
```

### 📌 1-6. 최댓값 만들기
- sort 라이브러리에서 역순배열을 만드려면 Reverse를 사용해야한다.
- sort.Reverse는 sort.Interface를 받아서 "내림차순 비교를 하는 새로운 정렬 인터페이스" 를 반환하는 래퍼(wrapper) 이다.
```go
import "sort"
func solution(numbers []int) int {
    sort.Sort(sort.Reverse(sort.IntSlice(numbers)))
    return numbers[0] * numbers[1]
}
```

# 📌 2. go언어 입출력
- bufio.NewReader: 입력을 버퍼링해서 효율적으로 처리하는 "Reader 객체"를 만든다.
- os.Stdin: 표준 입력(= 키보드 입력)
- reader := bufio.NewReader(os.Stdin)에서 reader는 키보드에서 입력받은 값을 가져오는 도구가 된다.
- ReadString('\n') : 엔터(개행 문자)까지 읽어서 문자열로 반환한다.
- \n을 굳이 포함해서 받는 이유는 저기까지 안받으면 어디서 끝인지 모호하기 때문에 스페이스바 입력을 끝으로 설정한 것이다.
- 사용자가 5 입력 후 Enter → "5\n"
- 반환값은 (string, error) 두 개인데, _로 error는 무시
- input = strings.TrimSpace(input) : 문자열 양쪽 끝의 공백 문자(스페이스, 탭, 줄바꿈 등)를 제거한다.
- Print만 써서 바로 옆에 입력할 수 있도록 하는 디테일
```go
fmt.Print("구구단을 출력할 숫자를 입력하세요 (2-9): ")
reader := bufio.NewReader(os.Stdin) // 표준 입력 리더 생성
input, _ := reader.ReadString('\n') // 한 줄 읽기
input = strings.TrimSpace(input)    // 공백 제거
```
- 아래는 이를 활용해 만든 구구단이다.

### 📌 2-1. 구구단
- 입력값은 string이므로 Atoi를 통해 문자열을 정수로 변환한다.
- 이때 c와 다르게 에러도 같이 반환하는데 에러가 나오면 이를 잘못된 입력으로 처리한다.
```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

func main() {
	fmt.Print("구구단을 출력할 숫자를 입력하세요 (2-9): ")
	reader := bufio.NewReader(os.Stdin) // 표준 입력 리더 생성
	input, _ := reader.ReadString('\n') // 한 줄 읽기
	input = strings.TrimSpace(input)    // 공백 제거
	num, err := strconv.Atoi(input)
	if err != nil {
		fmt.Println("잘못된 입력입니다. 숫자를 입력해주세요.")
		return
	}

	fmt.Println("---", num, "단 ---")
	for i := 1; i < 10; i++ {
		fmt.Println(input, " X ", i, " = ", num * i)
	}
}
```
### 📌 2-2. 전화번호부
- main에서 메인 프로그램과 버튼을 만들고 switch가 클릭한 버튼이나 상황에 따라 경로를 만들어서 뿌려주면 된다.
- phoneBook[name]과 같은 map에서는 인자를 한개만 받아도 되고 두개를 받아도 된다. 이때 두번째 인자는 해당 값이 존재하는지 아닌지를 boolean으로 받는다. 이는 if 안에서만 유효하다.
- go언어에서 쓰는 패턴으로 map에서 두번째인자를 받아서 값이 존재할때 뒤에 boolean값을 사용하면 값이 있을때만 해당 코드를 실행할 수 있다.
- "'%s' 연락처가 삭제되었습니다.\n" 처럼 포멧팅할때는 printf를 쓰고 서식 지정자를 ''로 감싸주어야한다.
- 삭제는 delete로 구현한다.
```go
if phone, ok := phoneBook[name]; ok {
    // ok == true 일 때 실행
} else {
    // ok == false 일 때 실행
}
```
```go
var phoneBook = make(map[string]string) 
var reader = bufio.NewReader(os.Stdin)  

// 연락처 추가
func addContact() {
	fmt.Print("이름을 입력하세요: ")
	name, _ := reader.ReadString('\n')
	name = strings.TrimSpace(name)

	fmt.Print("전화번호를 입력하세요: ")
	phone, _ := reader.ReadString('\n')
	phone = strings.TrimSpace(phone)

	phoneBook[name] = phone
	fmt.Printf("'%s' 연락처가 추가되었습니다.\n", name)
}

// 연락처 조회
func viewContact() {
	fmt.Print("조회할 이름을 입력하세요: ")
	name, _ := reader.ReadString('\n')
	name = strings.TrimSpace(name)

	if phone, ok := phoneBook[name]; ok {
		fmt.Printf("이름: %s, 전화번호: %s\n", name, phone)
	} else {
		fmt.Println("연락처를 찾을 수 없습니다.")
	}
}

// 연락처 삭제
func deleteContact() {
	fmt.Print("삭제할 이름을 입력하세요: ")
	name, _ := reader.ReadString('\n')
	name = strings.TrimSpace(name)

	if _, ok := phoneBook[name]; ok {
		delete(phoneBook, name)
		fmt.Printf("'%s' 연락처가 삭제되었습니다.\n", name)
	} else {
		fmt.Println("연락처를 찾을 수 없습니다.")
	}
}

// 모든 연락처 보기
func listAllContacts() {
	if len(phoneBook) == 0 {
		fmt.Println("저장된 연락처가 없습니다.")
		return
	}
	fmt.Println("--- 모든 연락처 ---")
	for name, phone := range phoneBook {
		fmt.Printf("이름: %s, 전화번호: %s\n", name, phone)
	}
}

// 메뉴
func main() {
	for {
		fmt.Println("\n--- 전화번호부 ---")
		fmt.Println("1. 연락처 추가")
		fmt.Println("2. 연락처 조회")
		fmt.Println("3. 연락처 삭제")
		fmt.Println("4. 모든 연락처 보기")
		fmt.Println("5. 종료")
		fmt.Print("메뉴를 선택하세요: ")

		choice, _ := reader.ReadString('\n')
		choice = strings.TrimSpace(choice)

		switch choice {
		case "1":
			addContact()
		case "2":
			viewContact()
		case "3":
			deleteContact()
		case "4":
			listAllContacts()
		case "5":
			fmt.Println("프로그램을 종료합니다.")
			return
		default:
			fmt.Println("유효하지 않은 메뉴입니다. 다시 선택해주세요.")
		}
	}
}
```
