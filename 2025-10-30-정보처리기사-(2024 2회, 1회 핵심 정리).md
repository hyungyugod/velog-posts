# 📌 1. SQL의 비교 연산자
## 1-1. 기본 비교
- SQL에서 같다는 비교는 `=`를 사용한다.
- `==`는 C/Java 계열 언어에서 사용하는 연산자이며, SQL에서는 사용하지 않는다.
- 예: `SELECT * FROM users WHERE id = 3;`

## 1-2. 이유
- SQL은 선언형 언어이고, 비교 연산자 집합이 제한적이다.
- 표준 SQL: =, <>, <, >, <=, >=, LIKE, BETWEEN 등이 기본이다.

# 📌 2. 서브넷팅과 ip subnet-zero
## 2-1. 기본 상황
- 주어진 대역: 123.100.1.0/22
- /22는 실제 네트워크 시작이 123.100.0.0이어야 한다. (/22는 3번째 옥텟이 4단위로 증가)
- 6개의 서브넷이 필요하면 3비트 추가 → /25로 쪼갬.

## 2-2. /25로 쪼갰을 때 나오는 서브넷
- 123.100.0.0/25 → 브로드캐스트 123.100.0.127
- 123.100.0.128/25 → 브로드캐스트 123.100.0.255
- 123.100.1.0/25 → 브로드캐스트 123.100.1.127
- 123.100.1.128/25 → 브로드캐스트 123.100.1.255
- …

## 2-3. ip subnet-zero를 사용할 때/안할 때
- 사용함: 0번 서브넷(123.100.0.0/25)도 사용 → 첫 번째 브로드캐스트는 123.100.0.127
- 사용 안 함: 0번 서브넷은 버림 → 첫 번째로 사용하는 것은 123.100.0.128/25 → 브로드캐스트 123.100.0.255

## 2-4. 왜 답지가 123.100.1.255일 수 있는가
- 문제에서 123.100.1.0/22를 “그냥 시작점”으로 본 경우
- 즉, 정규화(0.0부터) 안 하고 1.0부터 서브넷을 세면
  - 0번: 123.100.1.0/25
  - 1번: 123.100.1.128/25 → 브로드캐스트 123.100.1.255
- 이런 식의 출제는 시험에서 간혹 있고, 답지가 오타일 가능성도 있다.

# 📌 3. FLSM과 VLSM
## 3-1. FLSM(Fixed Length Subnet Mask)
- 모든 서브넷이 같은 마스크를 사용.
- 예: /24 → 4개로 나눌 때 전부 /26.
- 장점: 계산 쉬움. 단점: 주소 낭비.

## 3-2. VLSM(Variable Length Subnet Mask)
- 필요한 곳에는 큰 서브넷, 작은 곳에는 작은 서브넷.
- 같은 네트워크 안에 /25, /26, /28이 공존.
- 주소 효율이 좋다.
- OSPF, RIP v2, EIGRP는 VLSM 지원.

# 📌 4. 테스트 커버리지
## 4-1. 문장(Statement)
- 모든 문장을 ≥ 1회 실행.

## 4-2. 분기/결정(Branch/Decision)
- 각 분기의 True/False를 ≥ 1회씩 실행.

## 4-3. 조건(Condition)
- 복합 조건 안의 원자 조건 각각을 True/False로 만든다.

## 4-4. 변형 조건/결정(MC/DC: Modified Condition/Decision Coverage)
- 각 원자 조건을 하나씩 바꿨을 때 전체 결과가 실제로 바뀌는지 확인.
- 항공/의료처럼 안전성 높은 분야에서 사용.

## 4-5. 경로(Path)
- 가능한 모든 경로 실행. 분기 많아지면 현실적으로 불가.

## 4-6. 루프
- 0회/1회/다회로 테스트해 경계 오류를 잡는다.

# 📌 5. 악성 소프트웨어
## 5-1. 루트킷(Rootkit)
- root(최고권한)+kit(도구묶음)
- 시스템 깊은 곳에 숨어 프로세스/파일/포트를 숨김.
- 탐지 어렵고 커널 모드일수록 위험.

## 5-2. 주요 악성코드
- 바이러스: 파일에 기생, 실행 시 복제.
- 웜: 네트워크로 스스로 퍼짐.
- 트로이목마: 겉은 정상, 속에 악성.
- 스파이웨어: 정보 수집.
- 랜섬웨어: 암호화 후 몸값 요구.
- 봇넷: 감염 PC를 원격에서 묶어 대규모 공격.

# 📌 6. 라우팅 프로토콜 분류
## 6-1. IGP vs BGP
- IGP(Interior): 하나의 AS 내부 라우팅. RIP, IGRP, OSPF, EIGRP.
- BGP(Border): AS 사이 라우팅. 정책 기반.

## 6-2. 대표 프로토콜
- RIP: Distance Vector, 홉수 15 제한.
- IGRP: Cisco, 대역폭/지연 고려, RIP 보완.
- OSPF: Link-State, 최단경로(Dijkstra), VLSM/CIDR 지원.
- EIGRP: Cisco, DUAL, 하이브리드.

# 📌 7. VLSM과 CIDR
## 7-1. VLSM
- 같은 조직 내부에서 다른 길이의 마스크를 사용해 주소 낭비를 줄이는 기술.
- 목표: “필요한 곳에만 크게 주자.”

## 7-2. CIDR(Classless Inter-Domain Routing)
- 클래스 A/B/C 구분 없이 임의 길이 프리픽스(/22, /23…) 사용.
- 목적: 라우팅 테이블 축소(요약), 전세계 주소 공간 절약.
- 여러 개의 /24를 /22로 묶는 것이 전형적인 CIDR 요약.

# 📌 8. 응집도와 결합도
## 8-1. 응집도 (높을수록 좋음)
- 순서: 기능적 → 순차적 → 통신적 → 절차적 → 시간적 → 논리적 → 우연적
- 외우기: 기순통절시논우
- 통신적 응집이란: 같은 데이터(입력/출력)를 공유하며 그 데이터를 중심으로 뭉친 경우. communication의 원래 뜻이 “공유”라서 이렇게 부른다.

## 8-2. 결합도 (낮을수록 좋음)
- 순서(나쁜→좋은): 내용 → 공통 → 외부 → 제어 → 스탬프 → 자료
- 외우기: 내공외제스자
- 자료 결합이 가장 좋다. 필요한 데이터만 딱 넘기는 구조.

## 8-3. 전체 정리

| 구분 | 유형 | 설명 | 예시 | 품질 |
|------|------|------|------|------|
| **응집도 (Cohesion)** | **기능적 (Functional)** | 모듈 내 모든 요소가 하나의 기능을 수행 | `계산모듈`, `로그인검증` | ★★★★★ 가장 좋음 |
|  | **순차적 (Sequential)** | 한 기능의 출력이 다음 기능의 입력으로 사용 | `입력 → 처리 → 출력` | ★★★★☆ |
|  | **통신적 (Communicational)** | 같은 데이터(입출력)를 함께 사용하는 기능이 묶임 | `DB 읽기+쓰기`, `폼 입력+검증` | ★★★☆☆ |
|  | **절차적 (Procedural)** | 특정 절차 순서로 수행해야 하는 기능 묶음 | `초기화 → 처리 → 종료` | ★★☆☆☆ |
|  | **시간적 (Temporal)** | 특정 시점에 함께 수행되어야 하는 기능 묶음 | `프로그램 시작 시 초기화` | ★★☆☆☆ |
|  | **논리적 (Logical)** | 유사한 종류의 기능을 하나로 묶음 | `입력 관련 기능` | ★☆☆☆☆ |
|  | **우연적 (Coincidental)** | 아무 관련 없는 기능이 우연히 한 곳에 있음 | `무의미한 묶음` | ☆☆☆☆☆ 최악 |

> **응집도는 높을수록 좋다.**  
> 모듈 내부의 기능들이 얼마나 ‘단일 목적’에 집중되어 있는가를 나타냄.

---

| 구분 | 유형 | 설명 | 예시 | 품질 |
|------|------|------|------|------|
| **결합도 (Coupling)** | **내용 결합 (Content)** | 한 모듈이 다른 모듈의 내부 구현을 직접 접근 | 전역 변수 수정, 내부 코드 호출 | ☆☆☆☆☆ 최악 |
|  | **공통 결합 (Common)** | 여러 모듈이 동일한 전역 데이터를 사용 | `global 변수` | ★☆☆☆☆ |
|  | **외부 결합 (External)** | 외부 인터페이스나 파일 형식 의존 | `파일 구조, DB 포맷 공유` | ★★☆☆☆ |
|  | **제어 결합 (Control)** | 제어 신호(플래그)를 전달해 흐름 제어 | `함수에 플래그 전달` | ★★★☆☆ |
|  | **스탬프 결합 (Stamp)** | 구조체/레코드 전체를 전달 (일부만 사용) | `struct 전체 전달` | ★★★★☆ |
|  | **자료 결합 (Data)** | 필요한 데이터만 인자로 전달 | `int sum(int a, int b)` | ★★★★★ 가장 좋음 |

> **결합도는 낮을수록 좋다.**  
> 모듈 간의 상호 의존성을 최소화해야 유지보수성과 재사용성이 높아진다.

# 📌 9. 자바 배열 초기화
## 9-1. 기본형 배열
- `int[] v = new int[26];` 하면 26개 전부 0으로 자동 초기화.
- 자바는 `new`로 만든 배열은 항상 각 타입의 기본값으로 채운다.

## 9-2. 참조형 배열
- `String[] s = new String[10];` → 10개 전부 `null`.

# 📌 10. CPU 스케줄링 문제 (SRTF)
## 10-1. 주어진 프로세스
- P1: 도착 0, 실행 10
- P2: 도착 2, 실행 6
- P3: 도착 4, 실행 4

## 10-2. SRTF(Shortest Remaining Time First)로 스케줄링
- 0~2: P1
- 2~6: P2 (남은 시간이 P1보다 짧아서 선점)
- 6~10: P3
- 10~18: P1

## 10-3. 대기시간
- P1: 종료 18, 도착 0, 실행 10 → 대기 =18-0-10=8
- P2: 종료 6, 도착 2, 실행 6 → 대기 =6-2-6=0
- P3: 종료 10, 도착 4, 실행 4 → 대기 =10-4-4=2
- 평균 대기시간 =(8+0+2)/3 = 10/3 ≈ 3.33 → 4

## 10-4. 해설 표의 의미
- 시간축을 세로로 그려서 각 시점에 어느 프로세스가 CPU를 점유했는지 점으로 찍은 간트차트 표현이다.

# 📌 11. 패킷 교환 방식
## 11-1. 데이터그램 방식
- 각 패킷이 독립적으로 전송.
- 전송 순서가 보장되지 않는다.
- 목적지에서 재조립한다.
- 문제의 빈칸에 들어갈 말은 “데이터그램 교환 방식”.

## 11-2. 가상회선 방식
- 통신 전에 논리적 경로를 하나 잡는다.
- 이후 패킷은 순서대로 도착.
- X.25, ATM, Frame Relay 등이 이 방식.

## 11-3. 다른 교환과의 비교
- 회선 교환: 통화처럼 먼저 전용선을 확보.
- 메시지 교환: 메시지 단위 저장후전달.
- 패킷 교환: 작은 단위 잘라서 보냄 → 데이터그램/가상회선으로 나뉨.

# 📌 12. Iterator 디자인 패턴
## 12-1. 목적
- “집합체의 내부구현을 노출하지 않고” 원소들에 순차적으로 접근.
- 저장(자료구조)와 접근(순회로직)을 분리한다.

## 12-2. 구성
- Aggregate: 데이터 가진 쪽
- Iterator: next(), hasNext()로 순회 방법만 노출
- 클라이언트는 내부가 배열인지 연결리스트인지 모른다.

## 12-3. 설계 철학
- 캡슐화 유지
- 컬렉션 교체해도 순회 코드는 그대로

# 📌 13. Command 패턴과 관련 패턴
## 13-1. Command
- “요청을 객체로 캡슐화”하는 패턴.
- 버튼/메뉴/이벤트와 실제 실행 로직을 분리.
- 실행을 나중으로 미루거나, 큐에 넣거나, undo/redo를 구현하기 쉽다.

## 13-2. Strategy
- 알고리즘을 바꿔 끼우고 싶을 때.
- if-else 대신 객체로 알고리즘 전달.

## 13-3. Template Method
- 처리 뼈대는 상위가 정하고, 일부 단계만 하위가 변경.

## 13-4. Observer
- 상태가 바뀌면 자동 통보.

# 📌 14. for문의 실행 순서와 스코프
## 14-1. for문의 실행 순서
1. 초기식 1번 실행
2. 조건식 검사
3. 본문 실행
4. 증감식 실행
5. 조건식으로 돌아감
- “for문이 끝나도 마지막에 한 번 더 돈다”가 아니라, “마지막 반복의 끝에서도 증감식이 실행되고, 그 다음 조건이 false라서 빠져나오는 것”이다.

## 14-2. for문 안 변수의 스코프
- `for (int i = 0; ... )`에서 선언한 `i`는 지역변수다.
- for블록이 끝나면 소멸한다.
- 전역변수로 쓰고 싶으면 메서드 밖(클래스 필드)에서 선언해야 한다.

```java
for (int i = 0; i < 3; i++) {
    // i 사용 가능
}
// 여기서는 i 사용 불가
```


