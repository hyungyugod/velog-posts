# 📌 1. UI 기획 산출물: 와이어프레임, 목업, 스토리보드

## 1-1. 와이어프레임(Wireframe)의 개념과 목적

- **정의**  
  화면의 **뼈대 구조**를 단순한 선, 박스, 텍스트 블록 정도로 표현한 스케치 수준의 설계도이다.
- **목적**
  - 각 화면에 **어떤 요소가 어디에 배치되는지**를 결정한다.
  - 버튼, 메뉴, 입력창, 배너 등의 **위치와 우선순위**를 정한다.
  - 기능의 유무, 이동 경로를 거칠게 잡는 단계이며, **시각 디자인 요소(색, 폰트, 이미지)** 는 중요하지 않다.
- **특징**
  - 저해상도(low-fidelity) 표현
  - 회색 박스, 선, 간단한 텍스트 위주
  - 개발자·디자이너·기획자 사이에서 **화면 구성과 흐름만 합의**할 때 사용

## 1-2. 목업(Mockup)의 개념과 목적

- **정의**  
  실제 완성 화면처럼 보이도록 **색, 폰트, 아이콘, 이미지, 여백**까지 포함한 시각 디자인 시안이다.
- **목적**
  - 서비스의 **최종 디자인 느낌**을 미리 확인하고 피드백 받기 위함
  - 색상·폰트·버튼 스타일 등 **UI 디자인 의사결정**을 내리는 단계
- **특징**
  - 고해상도(high-fidelity) 정적 화면
  - 실제 서비스와 거의 유사한 모양
  - 동작(클릭, 전환)은 없고, **보여주기용**에 집중

## 1-3. 스토리보드(Storyboard)의 개념과 목적

- **정의**  
  사용자가 **서비스를 이용하면서 거치는 화면 순서와 행동 흐름**을 시퀀스(이야기 흐름)로 나열한 것이다.
- **목적**
  - “사용자가 어디서 시작해서 → 무엇을 하고 → 어느 화면으로 이동하는지” 전체 **사용자 여정(UX 흐름)** 을 정리한다.
  - 기능 단위가 아니라 **시나리오 단위**로 사고하게 해준다.
- **특징**
  - 여러 개의 화면 이미지(또는 간단한 스케치)를 **화살표/번호로 연결**
  - 각 화면 옆에 “사용자 행동 / 시스템 반응” 메모를 붙이는 경우가 많다.
  - 기획 문서, 개발자 전달, 이해관계자 설명 등에 사용

## 1-4. 세 가지의 비교 정리

| 구분 | 와이어프레임 | 목업 | 스토리보드 |
|------|--------------|------|------------|
| 초점 | 화면 구조, 요소 배치 | 시각적 완성도 | 화면 간 흐름, 시나리오 |
| 표현 수준 | 단순 박스, 흑백 | 실제와 유사한 디자인 | 여러 화면 + 화살표/텍스트 |
| 주 사용 시점 | 기획 초기 | 디자인 단계 | 전체 UX 점검 단계 |
| 산출물 성격 | 설계도(뼈대) | 디자인 시안(겉모습) | 사용 흐름 시나리오(스토리) |

---

# 📌 2. 테스트 커버리지: 문장, 조건, 분기, 조건/결정, 변형 조건/결정(MC/DC)

## 2-1. 문제에서 사용된 제어 흐름 구조 정리

문제에서 등장한 노드들의 의미는 대략 다음과 같다.

- $1$: $POINTER = FALSE$
- $2$: 결정점(조건) $D1$: $X > K$ ?
- $3$: $POINTER = TRUE$
- $4$: $X = X + 2$
- $5$: $CALL\ SUB(X, POINTER, RESULT)$
- $6$: 결정점(조건) $D2$: $RESULT > 1$ ?
- $7$: $PRINT\ RESULT$

루프 구조 때문에 $2$와 $6$이 여러 번 평가될 수 있지만,  
시험에서는 **“같은 노드는 한 번만 적는 방식”** 으로 경로를 기호화하는 형태가 출제되었다.

## 2-2. 문장(Statement) 커버리지

- **정의**  
  프로그램 내의 **모든 문장(노드)** 가 적어도 한 번 이상 실행되면 문장 커버리지 100\%를 만족한다.
- **예시 경로**
  - 예: `1234567`
  - 실제 흐름(의미):
    - $1$: 포인터 초기화
    - $2$: 조건 한 번 이상 평가
    - $3$: 참일 경우 포인터 설정
    - 이후 결국 $4, 5, 6, 7$을 한 번씩 통과
  - 결과: $1 \sim 7$ 모든 노드가 한 번 이상 실행 → **문장 커버리지 만족**

## 2-3. 조건(Condition) 커버리지

- **정의**  
  각 조건식이 **True와 False를 모두 한 번 이상** 갖도록 테스트하는 것.
- 조건들:
  - $D1$: $X > K$
  - $D2$: $RESULT > 1$
- 조건 커버리지용 테스트 조합 예:
  - 테스트 1: `124567`
    - $D1$: False, $D2$: False
  - 테스트 2: `1234561`
    - $D1$: True와 False 모두 나타남, $D2$: True
- 두 테스트를 합치면:
  - $D1$은 True/False 모두 만족
  - $D2$는 True/False 모두 만족  
  → 조건 커버리지 충족

## 2-4. 분기(결정) 커버리지

- **정의**  
  각 결정점(분기점)의 **True/False 두 방향 분기를 모두 한 번 이상** 수행하게 만드는 커버리지.
- 이 문제에서의 대표 답 예시:
  - 세트 1: `1234561`, `124567`
  - 세트 2: `1234567`, `124561`
- 위와 같은 세트는
  - $D1$의 True/False 분기 모두 커버
  - $D2$의 True/False 분기 모두 커버
  → **결정(분기) 커버리지 만족**

## 2-5. 조건/결정 커버리지

- **정의**
  - **결정 커버리지 + 조건 커버리지** 를 동시에 만족하는 기준.
- 이 문제에서는 각 결정점이 **단일 조건식** 이기 때문에,
  - 분기 커버리지를 만족하는 세트는
  - 조건 커버리지도 자동으로 만족한다.
- 따라서, 예:
  - `1234561`, `124567`  
  는 조건/결정 커버리지 세트로도 사용 가능하다.

## 2-6. 변형 조건/결정(MC/DC) 커버리지

- **정의(일반적인 경우)**  
  복합 조건(예: $A \land B$, $A \lor B$)에서,
  - 각 개별 조건이 **나머지 조건들을 고정한 상태에서**
  - True ↔ False로 바뀔 때
  - 결정 전체의 결과도 실제로 바뀌는 것이 드러나도록 테스트를 구성하는 기준이다.
- 이 문제에서는 각 분기가 단일 조건만 가지므로,
  - True/False가 모두 한 번씩 나오기만 하면
  - MC/DC 기준도 자연스럽게 충족된다.
- 따라서, 이 문제에서는 **MC/DC 커버리지용 세트 = 분기 커버리지 세트** 가 된다.

## 2-7. 문장 커버리지는 만족하지만 분기 커버리지는 만족하지 못하는 예

- 경로: `1234567`
  - 모든 노드 $1 \sim 7$을 한 번씩 방문 → **문장 커버리지 만족**
  - 하지만 $D2$에서 $RESULT > 1$ 분기:
    - 예를 들어 False만 사용했다면, True 분기를 한 번도 타지 않음
  - 따라서 이 단일 테스트만으로는 **분기 커버리지 미달** 사례가 된다.

---

# 📌 3. 관계대수에서 SELECT, PROJECT, JOIN 혼합 사용

## 3-1. 기본 관계 연산자 복습

- $σ$: **SELECT 연산자** – 행(튜플)을 조건으로 필터링  
  - 예: $σ_{\text{학과}='컴퓨터공학과'}(STUDENT)$
- $π$: **PROJECT 연산자** – 열(속성)을 선택  
  - 예: $π_{\text{이름, 학번}}(STUDENT)$
- $⨝$: **JOIN 연산자** – 두 릴레이션을 조건에 따라 결합  
  - 예: $STUDENT ⨝ ENROLL$

## 3-2. SELECT + PROJECT 혼합 예시

> “컴퓨터공학과 학생의 이름과 학번만 출력하라.”

- 관계대수식:
  $$
  π_{\text{이름, 학번}} \bigl( σ_{\text{학과}='컴퓨터공학과'}(STUDENT) \bigr)
  $$
- 해석:
  1. $σ$: 학과가 '컴퓨터공학과'인 튜플만 선택
  2. $π$: 그중 이름, 학번 속성만 추출

## 3-3. JOIN + SELECT + PROJECT 예시

> “성적이 A인 학생의 이름과 과목코드를 구하라.”

- 테이블:
  - $STUDENT(\text{학번, 이름, 학과, 학년})$
  - $ENROLL(\text{학번, 과목코드, 성적})$
- 관계대수식:
  $$
  π_{\text{이름, 과목코드}}\bigl(
    σ_{\text{성적}='A'}(STUDENT ⨝ ENROLL)
  \bigr)
  $$
- 해석:
  1. $STUDENT$와 $ENROLL$을 학번 기준으로 조인
  2. 성적이 $A$인 튜플만 선택
  3. 이름, 과목코드만 투영

## 3-4. 3개 릴레이션에서 JOIN 중첩 예시

> “서울에 사는 고객이 주문한 상품명과 수량을 구하라.”

- 테이블:
  - $CUSTOMER(\text{고객ID, 이름, 지역})$
  - $ORDER(\text{주문ID, 고객ID, 상품ID, 수량})$
  - $PRODUCT(\text{상품ID, 상품명, 단가})$
- 관계대수식:
  $$
  π_{\text{이름, 상품명, 수량}}\Bigl(
    σ_{\text{지역}='서울'}
    \bigl(
      (CUSTOMER ⨝ ORDER) ⨝ PRODUCT
    \bigr)
  \Bigr)
  $$

---

# 📌 4. JOIN에서 기준 속성을 명시하는 케이스

## 4-1. 자연 조인(Natural Join)

- **형태**
  $$
  R ⨝ S
  $$
- **특징**
  - 두 릴레이션 $R, S$에서 **이름이 같은 공통 속성**들이 자동으로 조인 기준이 된다.
  - 공통 속성은 결과에서 **한 번만** 나타난다.
- 예시:
  - $STUDENT(\text{학번, 이름, 학과})$
  - $ENROLL(\text{학번, 과목코드, 성적})$
  - 자연 조인: $STUDENT ⨝ ENROLL$  
    → 공통 속성 $\text{학번}$ 을 기준으로 자동 조인

## 4-2. θ-조인(Theta Join) – 기준 속성을 명시하는 조인

- **형태**
  $$
  R ⋈_{\theta} S \quad \text{또는} \quad R ⋈_{R.A\ \theta\ S.B} S
  $$
  여기서 $\theta$는 $=, \lt, \gt, \le, \ge, \ne$ 와 같은 비교 연산자이다.
- **용도**
  - 속성 이름이 서로 다른 경우
  - 단순 일치 조건이 아니라 부등식, 복합 조건 등을 쓸 때
- 예시:

EMP와 DEPT 테이블이 다음과 같다고 하자.

- $EMP(\text{사번, 이름, 부서ID, 급여})$
- $DEPT(\text{부서번호, 부서명, 지역})$

속성 이름이 다르므로 자연 조인 대신 θ-조인을 사용한다.

$$
EMP ⋈_{EMP.\text{부서ID} = DEPT.\text{부서번호}} DEPT
$$

→ 기준 속성을 **명시적으로** 적어주어 조인한다.

## 4-3. 등가조인(Equi-Join)

- θ-조인 중에서 $\theta$ 가 $=$ 인 조인을 **등가조인**이라 부른다.
- 자연 조인과 달리 **중복 속성이 제거되지 않는다.**
- 예:
  $$
  EMP ⋈_{EMP.\text{부서ID} = DEPT.\text{부서번호}} DEPT
  $$
  결과 스키마에 $\text{부서ID}$ 와 $\text{부서번호}$ 가 둘 다 남는다.

## 4-4. SELECT, PROJECT와 함께 쓰는 예시

> “부서명이 '인사부'인 부서에서 일하는 사원의 이름과 부서명을 출력하라.”

- 관계대수식:
  $$
  π_{\text{이름, 부서명}}\Bigl(
    σ_{\text{부서명}='인사부'}(
      EMP ⋈_{EMP.\text{부서ID} = DEPT.\text{부서번호}} DEPT
    )
  \Bigr)
  $$

---

# 📌 5. SQL에서 EXISTS의 의미

## 5-1. EXISTS의 기본 동작

- **형태**
  $$
  EXISTS(\text{subquery})
  $$
- **의미**
  - 서브쿼리의 결과가 **하나라도 존재하면** $TRUE$
  - 결과가 **한 건도 없으면** $FALSE$
- 중요한 점:
  - $EXISTS$는 **값을 반환하지 않고**, **논리값(참/거짓)** 만 반환한다.
  - “조건을 만족하는 값 하나만 출력하고 마는” 것이 아니라,  
    “그런 값이 **존재하는지 여부만 판단**”하는 연산자이다.

## 5-2. 예시: 수강 내역이 있는 학생 이름 조회

```sql
SELECT 이름
FROM STUDENT S
WHERE EXISTS (
    SELECT 1
    FROM ENROLL E
    WHERE E.학번 = S.학번
);
```

- 각 학생 $S$ 에 대해,
  - $ENROLL$ 에서 $E.\text{학번} = S.\text{학번}$ 인 튜플이 한 건이라도 있으면 $EXISTS$는 $TRUE$
  - 그러면 해당 학생은 결과에 포함된다.
- 서브쿼리 안에서 실제로 몇 건이 나오든 **첫 건이 발견되는 순간 TRUE** 가 되고,  
  그 뒤 결과들을 출력하는 것이 아니라 **존재 여부만 이용하여 WHERE 조건을 평가**한다.

## 5-3. NOT EXISTS 예시

> “수강 내역이 전혀 없는 학생의 이름을 구하라.”

```sql
SELECT 이름
FROM STUDENT S
WHERE NOT EXISTS (
    SELECT 1
    FROM ENROLL E
    WHERE E.학번 = S.학번
);
```

- $ENROLL$에 해당 학번이 한 번도 등장하지 않으면 TRUE → 결과에 포함.

---

# 📌 6. JOIN과 EXISTS의 차이와 사용 의도

## 6-1. JOIN의 목적: 데이터 결합 및 출력

- **JOIN의 역할**
  - 두 테이블을 **실제로 결합해서** 하나의 결과 집합으로 만든다.
  - 예를 들어, 학생과 수강 정보를 합쳐서 “학생 + 과목” 정보를 모두 보고 싶을 때.
- 예시:

```sql
SELECT S.이름, E.과목코드
FROM STUDENT S
JOIN ENROLL E
ON S.학번 = E.학번;
```

- 결과:
  - 학생이 3과목 수강했다면 3행 출력
  - 즉, **카디널리티(행의 개수)가 늘어날 수 있다.**
- 목적:
  - 데이터 **결합 + 출력** 이 핵심이다.

## 6-2. EXISTS의 목적: 존재 여부로 필터링

- **EXISTS의 역할**
  - 다른 테이블에 **관련 레코드가 존재하는지 여부** 로 현재 행을 필터링한다.
  - 데이터를 실제로 결합해서 보여주기보다는,  
    “조건을 만족하는 튜플이 있는가?” 만 확인하려는 용도이다.
- 예시(같은 목적을 EXISTS로 표현):

```sql
SELECT S.이름
FROM STUDENT S
WHERE EXISTS (
    SELECT 1
    FROM ENROLL E
    WHERE E.학번 = S.학번
);
```

- 이 경우:
  - $ENROLL$과 결합된 행들을 직접 출력하지 않고,
  - “수강 내역이 있는 학생인지” 만 검사하여 학생 테이블에서 필요한 행만 필터링한다.
  - 학생당 한 행씩만 출력되므로 **중복이 없다.**

## 6-3. 성능/의도 관점 비교

| 항목 | JOIN | EXISTS |
|------|------|--------|
| 주 목적 | 두 테이블의 데이터를 **결합해서 보여줌** | 다른 테이블에 해당 데이터가 **존재하는지 필터링** |
| 반환 데이터 | 결합된 모든 행 | 원래 바깥 쿼리의 행(필터링만) |
| 중복 가능성 | 높음(한쪽이 여러 행이면 곱만큼 증가) | 없음(바깥 행 기준) |
| 내부 동작 | 조인 결과를 만들어냄 | 첫 일치행 발견하면 TRUE, 더 이상 안 봄 |
| 전형적 사용 예 | “학생 + 과목 목록 다 보고 싶다” | “수강한 적 있는 학생만 보고 싶다” |

요약하면,

> JOIN은 “두 테이블의 내용을 함께 보고 싶을 때”,  
> EXISTS는 “그런 데이터가 **있냐 없냐만** 확인해서 필터링할 때” 쓴다.

---

# 📌 7. C 언어 비트필드와 구조체 크기

## 7-1. 비트필드와 구조체 멤버 저장 방식

```c
struct C {
    unsigned int a : 1;
    unsigned int b : 1;
    unsigned int c : 1;
    unsigned int d : 1;
    unsigned int e : 1;
    unsigned int f : 1;
    unsigned int g : 1;
    unsigned int h : 1;
};
```

- 각 필드는 `unsigned int` 타입의 **비트필드** 이고, 각자 **1비트**를 차지한다.
- C 표준에서 비트필드는 **해당 선언 타입(`int`, `unsigned int`, `short` 등)의 저장 단위 안에서** 비트 단위로 채워진다.
- 일반적인 환경에서 `unsigned int`는 4바이트(32비트)이므로:
  - $a \sim h$ 총 8비트 → 하나의 32비트 블록 안에 모두 저장 가능
  - 나머지 24비트는 아직 사용되지 않은 상태로 남아 있다.

## 7-2. 구조체 전체 크기

- 대부분의 32비트/64비트 환경, GCC/Clang/MSVC 등에서는
  - 위 구조체의 크기를
    ```c
    sizeof(struct C)
    ```
    로 확인하면 **4바이트**가 되는 경우가 많다.
- 이유:
  - 컴파일러가 비트필드들을 **같은 `unsigned int` 저장 단위에 연속으로 채워넣고**,  
    그 하나의 단위를 구조체의 저장 단위로 삼는 전략을 쓰기 때문이다.

## 7-3. 왜 “항상 4바이트”라고 단정할 수는 없는가?

- C 표준은 비트필드의 **정렬 방식(alignment)과 패딩 전략**을 엄격히 규정하지 않고,  
  이를 **구현 정의(implementation-defined)** 로 남겨둔다.
- 따라서 이론적으로는 컴파일러가:
  - 모든 비트필드를 하나의 `unsigned int`에 연속 배치 → $sizeof = 4$
  - 혹은 정렬을 과도하게 보수적으로 잡아서 더 크게 만들 수도 있다.
- 하지만 실제 실무에서 널리 쓰이는 대부분의 컴파일러는  
  동일 타입의 비트필드를 가능한 한 한 저장 단위에 압축하는 방식으로 구현한다.

## 7-4. 비트필드를 사용하는 이유 (요약)

- **여러 개의 불리언/플래그 값을 한 저장 단위 안에 압축**해서 보관하기 위함
  - 예: `flag1`, `flag2`, `flag3` 를 전부 `unsigned int`로 선언하면 12바이트
  - 비트필드로 1비트씩 선언하면 보통 4바이트 안에 모두 들어간다.
- **하드웨어 레지스터 매핑**
  - 레지스터의 각 비트를 의미 있는 이름으로 다루고 싶을 때 직관적이다.
- **비트 연산보다 가독성이 좋다**
  - 비트 마스크 대신, `status_flag.ready = 1;` 과 같이 의미 있는 이름으로 접근 가능하다.

---

# 📌 8. 전체 요약

## 8-1. 개념별 핵심 한 줄 요약

- 와이어프레임: **화면 구조와 요소 배치를 잡는 뼈대 설계도**
- 목업: **실제처럼 보이는 시각 디자인 시안**
- 스토리보드: **여러 화면을 연결한 사용자 흐름 시나리오**

- 문장 커버리지: **모든 문장을 한 번 이상 실행**
- 조건 커버리지: **각 조건식이 True/False 모두 나오게**
- 분기(결정) 커버리지: **각 if/조건문의 True/False 분기를 모두 타보기**
- 조건/결정, MC/DC: **이 문제처럼 단일 조건이면 분기 커버리지와 거의 동일하게 볼 수 있음**

- 관계대수에서 $σ, π, ⨝$:  
  - $σ$: 조건으로 행 선택  
  - $π$: 필요한 열만 선택  
  - $⨝$: 서로 관련 있는 릴레이션을 결합

- 자연 조인: **공통 속성 이름 기준으로 자동 조인**
- θ-조인: **조인 조건을 명시적으로 적는 조인** ($R.A = S.B$ 등)

- $EXISTS$: **서브쿼리 결과의 존재 여부(참/거짓)만 판단하는 조건 연산자**
- JOIN: **두 테이블의 데이터를 실제로 결합해서 보여주는 연산자**

- C 비트필드: **하나의 저장 단위 안에 여러 비트를 압축해 넣는 문법**이며,  
  구조체 크기는 보통 해당 타입 크기 단위로 잡히지만,  
  그 안에서 여러 필드를 비트 단위로 나눠 쓰기 때문에 **필드 단위 낭비를 줄일 수 있다.**
