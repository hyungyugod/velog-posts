# 📌 0. node.js 파일처리
### 📌 0-1. 파일 새로 쓰기
- import fs from "fs"; Node.js의 파일 시스템 모듈(fs) 가져오기. 파일 생성, 읽기, 쓰기, 삭제, 권한 변경 등을 할 수 있다.
- const target = "./output_sync.txt"; 작업할 파일 경로를 문자열로 정의. 여기서는 현재 디렉토리(./) 밑의 output_sync.txt.
- const content = "Hello World"; 파일에 저장할 내용 문자열.
- const is_exist = fs.existsSync(target); target 파일이 존재하는지 여부를 검사. 동기식 함수라 바로 true/false 반환.
- if (!is_exist) { ... } else { ... } 파일이 존재하지 않으면 → 새로 생성하고 권한 설정. 파일이 이미 존재하면 → 삭제.
- [파일이 없을 때 실행되는 부분]
- fs.writeFileSync(target, content, "utf-8"); 동기식으로 파일에 문자열 쓰기. 인자: (경로, 내용, 인코딩). 여기서는 "Hello World"가 output_sync.txt에 저장된다.
- fs.chmodSync(target, "0766"); 파일의 **퍼미션(권한)**을 바꾼다.
- "0766" = 8진수 권한 코드.
- 7 = 소유자(read/write/execute 모두 허용).
- 6 = 그룹(read/write).
- 6 = 기타 사용자(read/write).
- [파일이 이미 있을 때 실행되는 부분]
- fs.unlinkSync(target); 해당 파일을 동기식으로 삭제한다.
```js
import fs from"fs";

const target = "./output_sync.txt";
const content = "Hello World"; //저장할 내용
const is_exist = fs.existsSync(target);  //파일의 존재 여부 검사

if(!is_exist) {
    /** 파일이 존재하지 않을 경우 새로 저장 */
    //상대 경로 지정, 동기식 파일 저장
    fs.writeFileSync(target, content, "utf-8");

    //퍼미션 설정
    fs.chmodSync(target, "0766");

    console.log(target + "파일에 데이터 쓰기 및 퍼미션 설정 완료.");
} else {
    /** 파일이 존재할 경우 파일 삭제 */
    fs.unlinkSync(target);
    console.log(target + "파일 삭제 완료");
}
```
- Sync 붙은 건 = 순서대로 동작, 멈춤(blocking)
- Sync 없는 건 = 비동기, 바로 넘어감(non-blocking)
- 아래는 sync가 없기 때문에 비동기 처리를 의미한다.
```js
import fs from "fs";

const target = "./output.txt";
const content = "Hello World"; //저장할 내용
const is_exist = fs.existsSync(target);  //파일의 존재 여부 검사

if(!is_exist) {
    /** 파일이 존재하지 않을 경우 새로 저장 */
    //절대경로 지정, 비동기식 파일 저장
    fs.writeFile(target, content, "utf-8", (err) => {
        if(err) {
            return console.log(err)
        }
        console.log(target + "에 데이터 쓰기 완료");

        //퍼미션 설정
        fs.chmod(target, "0766", (err) => {
            if(err) {
                return console.log(err);
            }
            console.log(target + "의 퍼미션 설정 완료");
        });
    });

    console.log(target + "의 파일을 요청했습니다.");
} else {
    fs.unlink(target, (err) => {
        if (err) {
            return console.log(err);
        }

        console.log(target + "의 파일 삭제 완료");
    });

    console.log(target + "의 파일 삭제를 요청했습니다.");
}
```
- 비동기처리에 async await을 사용해서 순서를 부여하면 아래와 같다.
- 이때 await을 쓰려면 Promise를 반환하는 함수가 필요하다.
```js
import fs from "fs";

const target = "./output.txt";
const content = "Hello World"; //저장할 내용
const is_exist = fs.existsSync(target);  //파일의 존재 여부 검사

if(!is_exist) {
    /** 파일이 존재하지 않을 경우 새로 저장 */
    //절대경로 지정, 비동기식 파일 저장
   (async () => {
    console.log(target + "의 파일 저장을 요청했습니다.");

    //async~await는 비동기식 처리를 동기식으로 작동하도록 제어함
    try {
        await fs.promises.writeFile(target, content, "utf8");
        console.log(target + "에 데이터 쓰기 완료");

        await fs.promises.chmod(target, "0766");
        console.log(target + "의 퍼미션 설정 완료");
    } catch (err) {
        console.log(err);
        return;
    }
   })();
} else {
    //파일이 존재할 경우 파일 삭제
   console.log(target + "의 파일 삭제를 요청했습니다.");

   (async () => {
    try {
        await fs.promises.unlink(target);
        console.log(target + "의 파일 삭제 완료");
    } catch (err) {
        console.log(err);
        return;
    }
   })();
}
```

### 📌 0-2. 파일 읽기
- fs.existsSync(target)
→ 파일이 있는지 즉시 검사 (true/false 반환).
- fs.readFileSync("./output_sync.txt", "utf8") 동기식 파일 읽기.
```js
import fs from "fs";

const target = "./output_sync.txt";

if(fs.existsSync(target)) {
    //파일을 동기식으로 읽어서 내용을 리턴한다.
    //대용량 처리에는 부적합
    const data = fs.readFileSync("./output_sync.txt", "utf8");

    //읽어들인 데이터를 출력
    console.log(data);
} else {
    console.log(target + "파일이 존재하지 않습니다.");
}
```
- fs.existsSync(target)
→ 파일이 있는지 확인.
- fs.readFile(target, 'utf-8', (err, data) => { ... }) 비동기식 파일 읽기.
```js
import fs from "fs";
const target = './output.txt';

if(fs.existsSync(target)) {
    //파일을 비동기식으로 읽기
    //파일 읽기 종료 시 세 번째 파라미터인 콜백함수가 호출됨.
    fs.readFile(target, 'utf-8', (err, data) => {
        if(err) {
            return console.log(err);
        }
        console.log(data);
    });
    console.log(target + '파일을 읽도록 요청했습니다.');
} else {
    console.log(target + "파일이 존재하지 않습니다.");
}
```

# 📌 1. 환경변수
### 📌 1-1. 환경변수 값 가져오기
- const path = process.env.Path || process.env.PATH; 특정 환경 변수(PATH) 값을 가져오는 부분.
- 문제: OS마다 환경 변수 이름 표기가 다를 수 있음.
- Windows → "Path" (대소문자 섞임)
- Linux/macOS → "PATH" (대문자)
- 그래서 || (OR 연산자)를 써서: process.env.Path가 존재하면 그 값 사용 없으면 process.env.PATH 사용
```js
//process.env 객체를 통해 모든 환경변수를 JSON 형태로 접근 가능
console.log("모든 환경변수:", process.env);

//특정 환경변수 값에 접근
//운영체제마다 이름이 다름. (win: Path, mac/Linux: PATH)
// ||(OR 연산자)를 사용하면 Path 가 없을 경우 PATH로 대체하여 조회함.
const path = process.env.Path || process.env.PATH;

console.log(path);
```

### 📌 1-2. 환경변수 값 핸들링
- import dotenv from 'dotenv'; dotenv 모듈을 불러온다 이 모듈은 .env 파일(환경변수 설정 파일)의 내용을 읽어서 process.env에 자동으로 넣어주는 역할을 한다.
- dotenv.config(); .env 파일을 읽고, 그 안의 키=값 쌍을 process.env에 로드한다.
- 가져온 내용들을 객체로 만들어 환경변수 값을 핸들링한다.
```js
//1. dotenv 모듈을 불러옴
import dotenv from 'dotenv';

//이 함수가 호출되는 순간 .env 파일의 내용이 process.env에 저장된다.
dotenv.config();

//2. .env 파일에 저장된 값들을 process.env를 통해 사용함
console.log('데이터베이스 설정:');
const dbConfig = {
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
};
console.log(dbConfig);
console.log();

//3. Boolean 타입 환경변수 처리
//.env 파일의 모든 값은 문자열이므로, Boolean으로 변환해야함.
console.log('Boolean 타입 환경변수:');
const isDebugMode = process.env.DEBUG === 'true';
console.log(`디버그 모드 활성화: ${isDebugMode}`);
console.log();
```