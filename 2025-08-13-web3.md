# 📌 0. web 3 특강
- 본인 역량에 대한 정량적인 계산을 해봐야한다.
### 📌 0-1. web 3 기초
- web 1: 일방적인 정보제공
- web 2: 주고 받을 수 있음. (시스템-제시, 나-결정) - sns, ecom 
- 여러 개선점이 있다. -> 예를 들어 로그인 정보를 은행 시스템이 가지고 있는데 정보 보관료를 우리에 주지 않는다. 혹은 허락이나 이력이라도 제시해야하는데 그렇지도 않다. (정보비대칭)
- web 3: 정보제공자가 내가 된다. -> 내가 정보를 제시할 수 있음 (내 구매의지, 정보제공 의지가 나에게 있으니까 정보도 나에게서 나와야한다.)
- 정보 제공자가 개인이 되면 개인이 모든 책임을 질 수 있게되고 이는 오히려 보증의 근원이 더 명확해진다.
- 프랑스 GDPR -> 우리나라의 전자 서명법이 바뀌었다. (공인인증서 -> 공동인증서) // 공인의 의미가 사라졌다. -> 기존에 계약에 대해서 나라가 보장하던 것을 국가가 보장하지 않는다.
- 모든 계약이 사람과 사람간의 사업처럼 된다.
- de-fi(분산된 금융) 는 개인이 권리와 권한을 전부 가지고 있다.
- 법철학 쪽 정밀 틀로 보면, 권리는 타인의 **의무(duty)**를 발생시키는 **청구권(claim-right)**이고, 권한은 법률관계나 시스템 상태를 **변경할 수 있는 권능(power)**에 가깝다.
- 청구권(claim-right) = “A는 B가 φ하도록 B에게 의무가 지워지는 ‘청구권’을 가진다” = “B는 A에게 φ할 의무가 있다.” (**φ(파이)**는 수학·논리에서 **“아무 행위/명제 자리에 들어갈 변수(자리표시자, placeholder)”**이다. )

### 📌 0-2. web 2의 mvc패턴 기초
- web -> web-server -> application server -> db
- mobile app -> mobile-server -> application server -> db
- 여기서 web-server와 mobile-server는 통신을 이어주는 gateway 역할을 하면서도 트래픽을 조절하는 버퍼 역할 즉 proxy 역할을 동시에 한다.
- 이때 application server에 트래픽이 집중되어 부하가 발생하는 문제가 생긴다. 하여 중간에 switch를 두고 application server를 이중화하여 한쪽으로 요청이 몰리는 것을 방지한다. (L4 스위치)
- 일반적인 스위치(L2)는 MAC 주소 기반으로만 패킷을 전달하고, L3 스위치는 IP 주소 기반 라우팅까지 가능하지만, L4 스위치는 TCP/UDP 포트 번호까지 인식해서 트래픽을 제어한다는 점이 차이예요.
- L4 스위치 특징: TCP/UDP 포트 번호를 읽어서 서비스 단위로 트래픽을 분산시킬 수 있음.
- 스위치에서 트래픽을 분산할때 각 애플리케이션 서버의 threshold(보통 70%)을 참고하여 분산시킨다.
- 하드디스크 스토리지의 70%이상이 차면 리눅스 게열을 거의 오류를 낸다. -> VFS 방식을 사용하기 때문 (디스크 여유 블록 부족 → 단편화 증가 → 블록 할당 실패·지연)
- VFS(가상 파일 시스템, Virtual File System)는 커널 안에서 여러 종류의 파일시스템(ext4, XFS, NTFS, NFS, tmpfs, procfs 등)을 하나의 ‘공용 인터페이스’로 추상화해 주는 계층이다. 덕분에 사용자 프로그램은 open/read/write/close 같은 동일한 시스템콜만 쓰면, 실제로 그 데이터가 로컬 디스크든 네트워크든 메모리 위 가상 FS든 구분하지 않고 접근할 수 있다.
- 위에서 application server를 이중화한것처럼 db도 이중화한다. 이때 이중화한 db들의 정보를 사람이 손수 백업 db에 저장하는데 이 db는 정보의 저장만 한다. 
- 이때 관리자 서버가 하는 것은 이 백업 db를 분석하고 조회하는 것이다. 가장 중요한 것은 관리자 서버가 경고를 내주는 것이다.
- 이때 모든 로그 txt 파일에 백업 db에 저장한다. -> 디스크에 쌓고 해당하는 툴을 사용해서 보고싶은 정보만 db에 저장한다. 

### 📌 0-3. 블록체인 개요
- 정보가 바뀌지 않는다는 보장이 있다면, 또는 바꿀 수 없다면 그리고 100% 사실이라면 신뢰가 생긴다.
- 혹은 100% 추적이 가능해야한다.
- web 3에서는 web 2의 db가 외부 공통 저장소를 끌고와야한다. 이 저장소와 관련된 기술이 블록체인(DLTDB-분산원장기술db)이다.
- 정보가 바뀌지 않는다는 보장, 바꿀 수 없다는 보장을 블록체인 네트워크로 하는데 이에는 같은 서버가 상용화되었을때 100~200대가 똑같이 복사되어있고 연결되어있다.
- 신뢰가 가장 중요하다.
- 가상의 인물의 정보를 넣었을때 이걸 검증하려면 결국 3의 기관에 기대야하는거 아닌가 -> 그 보관하는 제 3의 기관도 이를 임의로 수정할 수 없다는 기술적 보장을 받고 있기 때문에 사람들은 또 이를 신뢰한다. -> 이때 이를 유지하는 기관은 정보 보관료를 받는다.
- NFT기술은 여기서 정보에 접근하는 열쇠를 주고 그 열쇠가 사용될때 마다 원래 가지고 있는 사람에게 돈이 들어간다.
- 비트코인은 이 블록체인 네트워크에서 서버를 그니까 저장소를 개인이 관리해주면(정확히는 보안을 강화해준다.) 관리비로 일정 확률로 코인이 나오는 것이다. 서버에 데이터가 많이 돌수록 코인이 많이 나오고 그 시스템이 많이 이용될 수록 코인의 가치가 오른다. 이때 사람들은 서버가 돌기도 전에 이 코인이 오를거라고 하면서 미리 판다. 그 돈으로 네트워크를 구성해야하는데 구성을 안하고 튀면 사기가 되는거다.
- 이때 다른 네트워크에서 기생해서 중계이득을 취하는 경우도 있다. 이때는 web-server만 있고 application server -> db는 외부의 api를 가져다가 사용하는 것이다.
- 그러면 초기에는 코인을 돈으로 바꿔주겠다는 약속이 있는건가? 그리고 서버가 잘되면 이를 올려주겠다는 약속이 있는건가? -> 고리대금업자가 보관증을 써주고 보관증이 거래되는 현실에서 비트코인의 경우는 초기에 보관증을 금으로 바꿔주겠다는 약속만 있었고 그렇게 바꾼 사례는 없지만 이게 빠른 속도로 거래소가 생기고 거래가 시작되면서 초기 과정이 많이 생략된 것이다. 
- 그러면 코인은 그 서버에서 사용할 수 있는 토큰인 것인가
- 유럽은 단일 블록체인 시스템을 구축해서 모든 정보가 하나의 저장소에 들어가있다.

### 📌 0-4. 블록과 체인에 관하여
- 블록 = 장부의 “한 페이지”
- 사람들끼리 돈을 보낸 기록(트랜잭션)을 일정량 모아 한 묶음으로 만든 것이 블록이다.
- 그 페이지 맨 위에는 **요약표(헤더)**가 붙는데, 거기엔
- 이전 페이지의 지문(해시),
- 이번 페이지에 적힌 모든 거래의 지문(머클루트),
- 시간, 난이도 같은 정보가 있다.
- 비유하면 “가계부 한 페이지 + 위·변조 방지 도장” 정도로 생각하면 된다.

[ Block N ]
  - 이전 페이지 지문(prev hash)
  - 이번 거래 요약 지문(merkle root)
  - 시간/난이도/기타
  - 거래1, 거래2, 거래3, ...

- 체인 = 페이지들을 “지문으로 연결한 책”
- 각 블록은 바로 앞 블록의 지문을 꼭대기에 담아둔다
- 그래서 과거 페이지를 몰래 고치면 그 페이지 지문이 바뀌고, 다음 페이지들 지문이 줄줄이 안 맞는다.
- 즉, 한 장만 바꿔도 그 뒤 전부를 다시 써야 하는 구조라서 손대기 어렵다.

[ Block N-1 ] --지문--> [ Block N ] --지문--> [ Block N+1 ]

- 왜 안전한가
- 연결 자물쇠: “이전 블록 지문” 때문에 과거 수정이 줄줄이 들통.
- 도장 자물쇠: PoW(작업증명)라면 퍼즐을 풀어야 페이지에 도장을 찍을 수 있다(많은 계산 필요).
- PoS(지분증명)라면 지분을 건 검증자들이 서명을 모아 도장 찍어둔다.
- 사본 자물쇠: 전 세계 여러 컴퓨터가 같은 책 사본을 들고 서로 대조해 틀리면 거부.

- 1. 실제 흐름(아주 간단 버전)

거래가 올라온다: “A→B로 1코인 보냄” 같은 요청들이 네트워크로 전파(메모풀 대기).

페이지를 꾸린다: 채굴자/검증자가 거래 여러 개를 모아 블록 후보를 만든다.

도장 찍기:

PoW: 퍼즐을 풀어 정답 해시를 찾으면 블록 확정.

PoS: 다수 검증자의 서명/투표가 모이면 확정.

전파·검증·연결: 다른 노드들이 블록을 확인하고 체인 끝에 연결한다.

확정도(컨펌): 그 뒤에 새 블록이 몇 장 더 쌓일수록 되돌리기 어려워져서 안정성↑.

- 2. 블록이 만들어지고 확정되는 과정

메모풀: 네트워크에 퍼진 미확정 트랜잭션들이 대기.

블록 후보 조립: 채굴자가 트랜잭션을 모아 블록을 만들고 헤더를 구성.

작업증명(PoW): nonce 등을 바꿔가며 헤더 해시 ≤ 난이도 목표가 되도록 반복 계산. 먼저 찾는 채굴자가 승자. 
Investopedia

전파·검증: 노드들이 서명·잔액·규칙을 검증하고 블록을 체인에 연결.

확정(확률적 최종성): 더 긴(정확히는 누적 난이도가 더 큰) 체인을 따르므로, 뒤에 여러 블록이 더 쌓일수록 되돌리기 어려워진다(예: “6컨펌” 관행). 
developer.bitcoin.org

- 3. 난이도·간격·보상

블록 간격: 평균 약 10분. 네트워크 상황에 따라 난이도가 **2,016블록(약 2주)**마다 자동 조정되어 10분 근처를 유지한다. 

보상: 코인베이스 트랜잭션으로 블록보상 + 수수료를 받는다. 보상은 약 4년마다 반감(2012: 25, 2016: 12.5, 2020: 6.25, 2024: 3.125 BTC 등)

머클루트: “여러 거래(트랜잭션) 해시들을 이진 트리로 위아래로 합쳐서 만든 단 하나의 요약 해시”이다. 블록 헤더에 저장되고, 블록 안 모든 거래가 한 글자라도 바뀌면 머클루트도 바뀐다. 그래서 위·변조 탐지가 쉽다.

- 4.  한 눈에 보는 흐름(비트코인/PoW 기준)

사용자가 거래 서명 → 네트워크에 전파(메모풀 대기)

채굴자가 거래들을 골라 블록 후보 조립(헤더: 이전블록해시·머클루트·타임스탬프·난이도 등)

채굴자가 해시 퍼즐을 풀어 유효한 블록을 찾으면 네트워크에 전파

모든 풀노드가 블록·거래·규칙을 검증

유효하면 자신의 로컬 체인 끝에 연결(복제된 원장 업데이트)

뒤에 블록이 더 쌓일수록 되돌리기 어려워져 “사실상 확정”

- 원장이란
- 원장(元帳): 회계에서 거래를 계정별로 모아 정리해 둔 기본 장부. 분개장(일기장처럼 시간순)에서 옮겨와 계정별 잔액을 확인하는 책. 영어로 ledger / general ledger(총계정원장). 
quickbooks.intuit.com
Remote
한자 감각: 元(근원/기본) + 帳(장부) → 핵심 장부라는 뉘앙스.
- ledger
- ledger는 중세 영어 ligger/leger에서 왔고, to lie/lay(놓여 있다)에서 파생된 말.
본래 **“항상 한 곳에 눕혀 두는 큰 책”**이라는 뜻에서 회계의 기본 장부 의미로 굳었다.
