# 📌 1. 스택 / 큐

---

### 📌 기본 비교표

| 구분         | 스택 (Stack)               | 큐 (Queue)                     |
|--------------|----------------------------|--------------------------------|
| 순서         | LIFO (후입선출)             | FIFO (선입선출)                |
| 주요 연산     | `push` / `pop` / `peek`    | `enqueue` / `dequeue` / `peek` |
| 내부 구현     | 배열, 연결 리스트           | 배열(원형 큐), 연결 리스트     |
| 주요 활용     | 호출 스택, 되돌리기 기능    | BFS, 작업 스케줄링, 메시지 큐  |

---

### 📌 1-1. 스택과 큐를 이용하면 좋은 상황

| **분류**       | **상황·패턴 / 선택 조건**       | **대표 문제·예시**              | **사용 근거·핵심 사고 과정**                           |
|----------------|----------------------------------|----------------------------------|--------------------------------------------------------|
| **스택 패턴**  | 괄호·태그 검사                   | 올바른 괄호, HTML 태그 검증      | 열릴 때 `push`, 닫힐 때 `pop` → 비면 오류 발생        |
|                | 역추적·Undo                      | ‘뒤로가기’ 기능, DFS 백트래킹    | 한 단계 작업 후 **원래 상태**로 복귀 필요              |
|                | 수식 파싱                        | 중위 → 후위(후위 계산기) 변환     | 연산자 우선순위대로 스택에 **임시 보관**               |
|                | 단조(모노톤) 스택               | 다음 큰 수, 히스토그램 최대 직사각형 | 이전 값과 비교하며 `pop/push`로 범위 계산              |
| **큐 패턴**    | BFS (너비 우선 탐색)             | 미로 최단거리, 그래프 탐색       | 인접 정점 `enqueue`, 거리 순 `poll`                    |
|                | 멀티 소스 확산                   | 토마토 익히기, 불 퍼지기         | 여러 시작점 동시 처리, 각 레벨 단위 진행               |
|                | 스케줄링·캐시                    | OS 작업 큐, CPU Job Queue        | 선입 선출 순서대로 작업 소비                           |
|                | 슬라이딩 윈도우 (Deque)         | 윈도우 최대값 유지, 이동 평균    | 범위 초과 시 앞 제거(`poll`), 새 원소 뒤 삽입(`offer`)  |

---

#### ✅ 선택 체크리스트

| 상황                              | 선택 자료구조 |
|-----------------------------------|---------------|
| 거꾸로 꺼내야 한다면?             | 스택 (LIFO)   |
| 입력 순서대로 처리해야 한다면?     | 큐 (FIFO)     |
| 레벨·시간 단계별 전파인가?        | 큐 + BFS      |
| 이전 상태로 돌아가야 하나?        | 스택 + 백트래킹 |
| 이전 원소와의 비교가 반복되는가?   | 모노톤 스택   |

---

#### 🧠 부가 설명

- “앞(head)/뒤(tail)”는 메모리 주소가 아닌, **자료구조 내부 논리적 개념**이다.
- `push / pop`은 스택에서 앞에 넣고 앞에서 꺼내는 방식이다.
- 메모리 효율: `LinkedList` > `ArrayDeque` ≒ `ArrayList`

---

#### 📚 자주 쓰는 메서드 비교

| 분류          | 메서드                        | 예외 발생 | 설명                                       |
|---------------|-------------------------------|-----------|--------------------------------------------|
| `Queue<E>`    | `offer(e)`                    | ✖         | 뒤(꼬리)에 넣기, 자리 없으면 `false` 반환   |
|               | `add(e)`                      | ✔         | 뒤(꼬리)에 넣기, 자리 없으면 예외 발생      |
|               | `poll()`                      | ✖         | 앞(머리)에서 꺼냄, 없으면 `null`            |
|               | `remove()`                    | ✔         | 앞(머리)에서 꺼냄, 없으면 예외 발생         |
|               | `peek()`                      | ✖         | 앞 요소 미리보기, 없으면 `null`             |
|               | `element()`                   | ✔         | 앞 요소 미리보기, 없으면 예외 발생          |
| `Deque<E>`    | `addFirst()` / `addLast()`    | ✔         | 앞/뒤 삽입                                  |
|               | `offerFirst()` / `offerLast()`| ✖         | 앞/뒤 삽입, 자리 없으면 `false`             |
|               | `pollFirst()` / `pollLast()`  | ✖         | 앞/뒤 꺼내기, 없으면 `null`                 |
|               | `peekFirst()` / `peekLast()`  | ✖         | 앞/뒤 미리보기                              |
|               | `push(e)`                     | ✔         | = `addFirst()` (스택 용도)                  |
|               | `pop()`                       | ✔         | = `removeFirst()` (스택 용도)               |

---
### 📌 1-2. 같은 숫자는 싫어 (STACK)

> 인접한 **중복 숫자를 제거**하고 남은 숫자들을 **입력 순서대로 반환**하는 문제이다.  
스택과 큐를 이용하여 간결하고 효율적인 방식으로 해결한다.

---

#### 📌 핵심 요약:

- **스택 (Stack)**: 마지막으로 본 숫자 하나만 보관 (중복 제거용)
- **큐 (Queue)**: 중복 제거 후 남은 숫자를 원래 순서대로 저장
- **LIFO / FIFO 구조를 함께 사용**하여 중복 제거와 순서 유지 모두 달성

---

#### ✅ 예시 설명:

- 입력: `[1, 1, 3, 3, 0, 1, 1]`
- 처리:
  - 첫 1은 스택에 넣음
  - 다음 1은 중복 → 건너뜀
  - 3은 다름 → 이전 1을 큐로 보내고 3을 스택에 넣음
  - 다음 3은 중복 → 건너뜀
  - 0은 다름 → 3을 큐로 보내고 0을 스택에 넣음
  - 1은 다름 → 0을 큐로 보내고 1을 스택에 넣음
  - 마지막 1은 중복 → 건너뜀
- 마지막 스택에 남은 1을 큐로 보내고 최종 배열로 반환
- 출력: `[1, 3, 0, 1]`

---
```java
import java.util.*;

/** 인접한 중복을 제거하고 남은 숫자만 순서대로 반환 */
public int[] solution(int[] arr) {

    /* 1) 스택: 가장 마지막에 본 숫자 하나만 보관(LIFO) */
    Deque<Integer> stack = new ArrayDeque<>();

    /* 2) 큐: 최종 결과를 '넣은 순서 그대로' 저장(FIFO) */
    Queue<Integer> answer = new ArrayDeque<>();

    // ── 3) 배열 순회 ──────────────────────────────
    for (int num : arr) {

        if (stack.isEmpty()) {                 // 아직 아무 것도 없으면
            stack.push(num);                   // 바로 스택에 넣기 (앞에다가 넣는다.)
        }
        else if (!stack.peek().equals(num)) {  // 이전 숫자와 다르면 (앞에서 꺼냄)
            answer.offer(stack.pop());         // → 이전 숫자를 결과 큐로 이동
                                                // 반환하고 원래있는 큐/데크에서는 삭제함.
            stack.push(num);                   // → 새 숫자를 스택에 넣기
        }
        /* else : 동일한 숫자면 아무 일도 하지 않고 건너뜀 */
    }

    // ── 4) 루프가 끝났을 때 스택에 남은 마지막 숫자 처리 ──
    if (!stack.isEmpty()) {
        answer.offer(stack.pop());
    }

    // ── 5) 큐 → int[] 로 변환해서 반환 ────────────────────
    return answer.stream().mapToInt(Integer::intValue).toArray();
}
```
##### ⚠️ 주의할 점:

- `peek()`로 꺼낸 스택의 top 값과 현재 숫자를 비교한다. **`.equals()` 사용 주의** (언박싱 오류 방지)
- **중복을 제거하되 '인접한 것'만 제거**한다. 중간에 다른 숫자가 끼면 다시 추가된다.
- 스택에 남은 마지막 값은 반복문 이후에 **별도로 큐에 넣어야 함**

---


### 📌 1-3. 기능개발 (QUEUE)

> 기능 개발의 진척도를 바탕으로 **각 배포마다 몇 개의 기능이 함께 배포되는지**를 계산하는 문제이다.  
큐를 이용하여 기능의 남은 일 수를 계산하고, 앞에서부터 배포할 수 있는 묶음을 처리한다.

---

#### 📌 핵심 요약:

- **큐 (Queue)** 사용: 각 기능이 완료되기까지의 **필요 일수**를 큐에 저장
- **배포 기준일보다 일수가 작거나 같은 기능들을 묶음 처리**하여 한 번에 배포
- `poll()`(앞에서 꺼내기) / `offer()`(뒤로 넣기)는 값이 없을 경우 false 반환 → 안정적 처리 가능
- `peek()`나 `pop()`은 값이 없으면 예외 발생 → 반드시 `isEmpty()` 체크 필요
- poll도 pop처럼 빼면 원래 있던 자리에서는 없어짐.

---

#### ✅ 예시 설명:

- 입력:
  - `progresses = [93, 30, 55]`
  - `speeds = [1, 30, 5]`
- 처리:
  - 각 기능의 남은 일수 계산 → `[7, 3, 9] → [7, 3, 9] → [7, 3, 9] → [7, 9]` (정확히는 `[7, 3, 9]`)
  - 첫 기능(7일)에 맞춰 이후 기능 중 완료된 것 함께 배포
  - 3일은 7보다 작아도 **큐 순서상 뒤에 있는 기능**이므로 한 배포에 포함되지 않음
- 결과: `[2, 1]` (7일 후 2개, 9일 후 1개 배포)

---
```java
import java.util.*;

public class Solution {
    public int[] solution(int[] progresses, int[] speeds) {

        // 1) 각 기능이 완료되기까지 남은 '필요 일수'를 계산
        Queue<Integer> days = new ArrayDeque<>();
        for (int i = 0; i < progresses.length; i++) {
            int remain = 100 - progresses[i];
            int needDay = (remain + speeds[i] - 1) / speeds[i]; // 남은 날/ 한번에 걸리는 날을 올림 계산한 것
            days.offer(needDay); // progresses 배열의 순서대로 값을 담는다.
        }

        // 2) 앞에서부터 배포 묶음을 계산
        List<Integer> answer = new ArrayList<>();
        while (!days.isEmpty()) {
            int deployDay = days.poll();  // 이번 배포 기준일 (앞에서 꺼내기)
            int cnt = 1;                  // 최소 1개는 함께 나감

            while (!days.isEmpty() && days.peek() <= deployDay) { // 남은 날이 더 적은 뒤의 친구들과 함께 나간다.
                days.poll();
                cnt++;
            }
            answer.add(cnt);
        }

        // 3) List → int[]
        return answer.stream().mapToInt(Integer::intValue).toArray();
    }
}
```
##### ⚠️ 주의할 점:

- `poll()`과 `offer()`는 값이 없을 때 false 반환 → 안전하게 큐 조작 가능
- `peek()` 또는 `pop()`은 값이 없으면 **예외 발생** → 반드시 `isEmpty()` 체크 필요
- 큐는 선입선출 구조이므로 **뒤에 있어도 먼저 끝나는 기능은 앞 기능과 동시에 배포되지 않음**

---





