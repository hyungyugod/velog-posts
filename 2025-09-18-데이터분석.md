# 📌 0. 데이터 분석 문제풀이
### 📌 0-1. 날짜 데이터 변환 후 할당
- pd.to_datetime(raw_log["eventdatetime"])가 변환된 series를 반환하므로 저장하려면 다시 할당해주어야 한다.
```py
raw_log["eventdatetime"] = pd.to_datetime(raw_log["eventdatetime"])
```
- Pandas는 "eventdatetime","eventdatetime_year" 를 튜플로 인식하기 때문에. raw_log[("eventdatetime","eventdatetime_year")] 형태가 되어버려서, 단일 컬럼 이름을 튜플로 찾으려고 하니 없는 컬럼이라고 에러가 발생하는 것이다.
- 하여 아래처럼 여러개의 컬럼을 가진 데이터프레임을 얻고자할때는 리스트로 묶어서 넘겨주어야 한다.
```py
raw_log[["eventdatetime","eventdatetime_year"]]
```
- 새로운 컬럼에 만들어진 series를 밀어넣고 조회하면서 답안을 아래처럼 마무리한다.
```py
# eventdatetime 날짜 데이터로 바꾸고 연월일시분초 데이터 추출하기'
raw_log["eventdatetime"] = pd.to_datetime(raw_log["eventdatetime"])
raw_log["eventdatetime_year"] = raw_log["eventdatetime"].dt.year
raw_log["eventdatetime_month"] = raw_log["eventdatetime"].dt.month
raw_log["eventdatetime_day"] = raw_log["eventdatetime"].dt.day
raw_log["eventdatetime_hour"] = raw_log["eventdatetime"].dt.hour
raw_log["eventdatetime_minute"] = raw_log["eventdatetime"].dt.minute
raw_log["eventdatetime_second"] = raw_log["eventdatetime"].dt.second
raw_log[["eventdatetime","eventdatetime_year","eventdatetime_month","eventdatetime_day","eventdatetime_hour","eventdatetime_minute","eventdatetime_second"]].head(5)
```

### 📌 0-2. osversion 칼럼에 들어가있는 정보를 여러개의 칼럼으로 나누기
- str보다 text라고 하는게 더 낫다. -> str은 파이썬의 내장 데이터타입이름이다.
- isnumeric() 는 유니코드 숫자 전부(예: 로마 숫자, 동아시아 숫자 등)까지 참으로 본다.
- ASCII 숫자만 원하면 isdigit() 혹은 ch in "0123456789" 를 쓰는 편이 더 예측 가능하다.
- apply를 활용해서 칼럼의 값을 원활하게 커스텀하여 사용한다.
```py
def ext_ostype(text):
  box = []
  for i in text:
    if not i.isnumeric():
      box.append(i)
    
    else:
      break

  return "".join(box)

def ext_version(text):
  box = []
  for i in text:
    if i.isnumeric() or i == ".":
      box.append(i)

  return "".join(box)

raw_log["ostype(clean)"] = raw_log["osversion"].apply(ext_ostype)
raw_log["osversion(clean)"] = raw_log["osversion"].apply(ext_version)

raw_log[["osversion","ostype(clean)","osversion(clean)"]].head(5)
```
- gpt가 추천한 방법으로 s.str.replace는 문자열을 벡터화 연산하여 좀 더 빠르게 연산을 수행할 수 있다.
```py
# 안전하게 문자열 dtype으로 맞춤
s = raw_log["osversion"].astype("string")

# OS 타입: 첫 숫자부터 끝까지 제거 → 앞의 숫자-이전 문자만 남김
raw_log["ostype(clean)"] = s.str.replace(r"\d.*$", "", regex=True).str.strip()

# 버전: 숫자/점만 남기고 나머지 제거
raw_log["osversion(clean)"] = s.str.replace(r"[^0-9.]", "", regex=True)

raw_log[["osversion","ostype(clean)","osversion(clean)"]].head(5)
```

### 📌 0-3. 제조사 정보 정리하기
- startwith가 아니라 startswith이다.
- 데이터 타입이 str이 아닌 이상한 데이터는 other로 처리한다.
- 텍스트의 양여백을 제거하고 소문자로 변경한다. 
- 이후 문제 조건에 맞게 데이터를 정제하는 함수를 apply를 통해 전체 적용한다.
```py
def clean_devicemanufacturer(text):
    if not isinstance(text, str):
        return "Other"
    
    t = text.strip().lower()  # 공백 제거 + 소문자 변환
    
    if t.startswith("samsung"):
        return "Samsung"
    elif t.startswith(("lge", "lg electronics", "lg")):
        return "LG"
    elif t.startswith("apple"):
        return "Apple"
    else:
        return "Other"

# 적용
raw_log["devicemanufacturer"] = raw_log["devicemanufacturer"].apply(clean_devicemanufacturer)

# 결과 확인
print(raw_log["devicemanufacturer"].value_counts())
```