# 📌 1. 트랜잭션, COMMIT, ROLLBACK

## 1-1. 트랜잭션의 본질

- 트랜잭션(transaction)은 **하나의 논리적 작업 단위**이다.
- 트랜잭션의 목적은 **성능 향상**이 아니라, $ACID$ 특성으로 대표되는 **데이터 무결성과 일관성 유지**이다.
- $ACID$ 중 핵심:
  - $A$ (Atomicity, 원자성): 전부 수행되거나 전부 취소.
  - $C$ (Consistency, 일관성): 제약조건, 비즈니스 규칙을 항상 만족.
  - $I$ (Isolation, 격리성): 동시에 수행되어도 서로 간섭 최소화.
  - $D$ (Durability, 지속성): 커밋된 내용은 장애가 나도 보존.

## 1-2. COMMIT과 ROLLBACK의 역할

- $COMMIT$
  - 현재 트랜잭션에서 수행한 변경을 **영구 반영**한다.
  - 커밋 이후에는 ROLLBACK으로 되돌릴 수 없다.
- $ROLLBACK$
  - **커밋되지 않은 변경사항**을 트랜잭션 시작 시점으로 되돌린다.
  - 이미 커밋된 변경은 되돌리지 못한다.
- 흐름 예시:
  ```sql
  BEGIN;
  UPDATE 학생 SET 점수 = 0 WHERE 학번 = 1;
  DELETE FROM 출석 WHERE 학번 = 1;
  ROLLBACK;  -- 두 문장이 모두 취소
  ```

## 1-3. 트랜잭션과 성능

- “트랜잭션은 업무를 하나로 묶어 성능이 증가한다”는 설명은 부정확하다.
- 실제로 트랜잭션은 다음과 같은 추가 비용을 유발한다.
  - undo/redo 로그 기록
  - lock 유지
  - MVCC 스냅샷 관리
- 따라서 트랜잭션이 길어지면 병렬성(동시 수행 능력)이 떨어지고, 성능이 **오히려 저하**될 수 있다.
- 성능 향상은 보통 **배치 처리, bulk insert, 인덱스 최적화, 커넥션 풀** 등으로 달성하고, 트랜잭션은 **정합성 보장**이 주목적이다.

---

# 📌 2. 정규화, 1:N 관계, 1차 정규형(1NF)

## 2-1. 부분함수적 종속과 1:N 구조

- 예시 함수적 종속 관계:
  - $(상품ID, 카테고리) \to (상품명, 등록시점, 상품설명)$
  - $(상품ID) \to (상품명)$
- 여기서 $상품명$은 $상품ID$만으로도 결정되므로 **부분 함수적 종속**이 존재한다.
- 정규화 결과 테이블 분리:
  1. $상품(상품ID \to 상품명)$
  2. $상품\_상세(상품ID, 카테고리 \to 등록시점, 상품설명)$
- 이때
  - 하나의 $상품ID$가 여러 $카테고리$별 상세정보를 가질 수 있으므로
  - $상품 : 상품\_상세 = 1 : N$ 관계가 된다.

## 2-2. 10번 문제와 1차 정규형(1NF)

- 예시 테이블: 연락처1, 연락처2 컬럼이 존재.
- **1차 정규형(1NF)** 정의:
  - 모든 속성 값은 **원자값(atomic)** 이어야 하고, **반복 그룹**이 없어야 한다.
- `연락처1`, `연락처2`는 본질적으로 하나의 속성(연락처)의 **반복값**을 열을 늘려서 표현한 것이라 1NF 위반이다.
- 바른 설계:
  - $고객(고객ID, 고객명, \dots)$
  - $고객연락처(고객ID, 연락처)$  → 고객 $1$명 : 연락처 $N$개
- 1차 정규화에서 먼저 **도메인 원자성 확보**가 필요하고, 이후에 2NF, 3NF 수준의 테이블 분리는 그 다음 단계다.

---

# 📌 3. 인조식별자와 본질식별자(자연키)

## 3-1. 본질식별자(Natural Key, 본질 식별자)

- 업무에서 **이미 고유성을 가진 속성(또는 속성 조합)**을 그대로 식별자로 사용하는 것.
- 예:
  - 주민등록번호, 사업자번호
  - 학번, 사번
  - (상품코드, 버전), (학생ID, 학기, 과목코드)와 같은 **복합키**
- 특징:
  - 업무 의미가 풍부하다.
  - 한 속성으로 유일하지 않은 경우가 많아 **복합키**로 구성되는 경우가 잦다.
  - 업무 규칙 변경 시 식별자 자체가 변경될 위험이 있다.
  - PK/FK, JOIN, 인덱스가 모두 복잡해질 수 있다.

## 3-2. 보조식별자(Surrogate Key, 인조 식별자)

- 시스템이 **PK 전용으로 인위적으로 만든 식별자**.
- 예:
  - AUTO\_INCREMENT 숫자 ID
  - 시퀀스 번호, UUID
- 특징:
  - 업무적 의미가 없다.
  - 일반적으로 단일 컬럼이므로 JOIN, 인덱스, FK 관리가 단순해진다.
  - 업무 중복을 PK가 막지 못하므로, **업무적 유일성은 별도 UNIQUE 제약**으로 보장해야 한다.
- “인조식별자는 관리가 간편하고 데이터 중복 입력 가능성이 있다”는 말의 의미:
  - 관리가 간편: 단일 숫자 PK, 변경 없음, JOIN 단순.
  - 중복 가능성: 예를 들어, 고객이름/전화번호가 같은 레코드가 여러 건 들어와도, PK는 각기 다른 ID이므로 DB가 중복을 자동으로 감지하지 못한다.

---

# 📌 4. ERD에서 관계(Relationship)의 구성요소

## 4-1. 관계의 주요 구성 개념

관계(Relationship)를 표현할 때 핵심 요소는 다음과 같다.

1. **Cardinality(기수성)**  
   - $1:1$, $1:N$, $N:M$ 등 “몇 개와 연결되는가”.
2. **Optionality(선택/필수 참여)**  
   - 참여가 필수인지($1$), 선택인지($0$) → $(0,1)$, $(1,1)$ 등으로 표현.
3. **Participation/Membership(참여)**  
   - 어떤 엔티티들이 이 관계에 참여하는가(사원–부서 등).

시험 관점에서는 “관계의 구성요소가 아닌 것”을 물을 때 **Attribute(속성)**을 오답으로 내는 경우가 많다.  
엔티티(Entity)는 속성을 가지지만, 관계 자체는 속성을 갖지 않는 것이 기본 가정이다(특수한 ERD 표기에서 관계 속성을 둘 수는 있으나 예외적이다).

---

# 📌 5. FULL OUTER JOIN과 Oracle의 (+) 조인

## 5-1. FULL OUTER JOIN의 의미

- LEFT OUTER JOIN + RIGHT OUTER JOIN을 합친 결과와 같으며,  
  양쪽 테이블의 **모든 행을 보존**하고, 매칭되지 않는 쪽은 $NULL$로 채운다.
- ANSI 표기:
  ```sql
  SELECT ...
  FROM A
  FULL OUTER JOIN B
    ON A.key = B.key;
  ```

## 5-2. Oracle의 (+) 조인과 한계

- Oracle 전통 문법:
  ```sql
  SELECT ...
  FROM A, B
  WHERE A.key = B.key(+);  -- B가 부족한 쪽(OUTER)
  ```
- 규칙:
  - $(+)$는 **한쪽에만** 올 수 있다. 양쪽 모두에 $(+)$ 사용 불가.
  - 여러 조건이 있을 때도 $(+)$는 한쪽 테이블에만 붙어야 한다.
  - 따라서 **FULL OUTER JOIN을 $(+)$ 문법만으로 표현할 수 없다.**
- 시험 포인트:
  - “Oracle 방식에서는 조인 조건 양쪽에 $(+)$ 기호를 사용해 FULL OUTER JOIN을 구현할 수 있다” → 틀린 설명.

---

# 📌 6. CONNECT BY와 PRIOR의 방향

## 6-1. PRIOR의 의미

- Oracle 계층 질의:
  ```sql
  CONNECT BY prior 부모컬럼 = 자식컬럼
  CONNECT BY 자식컬럼 = prior 부모컬럼
  ```
- 절대 규칙:
  - **$PRIOR$가 붙은 쪽이 ‘부모(상위 노드)’**
  - $PRIOR$가 없는 쪽이 ‘자식(하위 노드)’

## 6-2. 순방향/역방향 전개 해석

- 문제 조건: $EMP\_ID$ = 하위, $MANAGER\_ID$ = 상위.
- 전개식 비교:
  1. `CONNECT BY PRIOR EMP_ID = MANAGER_ID`
     - $PRIOR EMP\_ID$가 부모가 되므로, 계층 의미상 약간 어색한 구조.
  2. `CONNECT BY EMP_ID = PRIOR MANAGER_ID`
     - $PRIOR MANAGER\_ID$가 부모, $EMP\_ID$가 자식  
       → **부모(상위) → 자식(하위)로 전개되는 구조**.
- 일부 교재에서는 “Oracle 기본 문법( `CONNECT BY PRIOR 부모 = 자식` )을 정방향”으로 정의하고, 그 반대 형태를 “역방향”이라고 부르기도 한다.
- 하지만 데이터 계층 관점에서는 **PRIOR가 상위(부모)에 붙고, 자식이 그 아래에 나오는 것이 자연스러운 순방향 전개**이다.

---

# 📌 7. Oracle의 빈 문자열과 NULL 처리

## 7-1. Oracle vs 다른 DBMS

- Oracle:
  - 길이가 $0$인 문자열 `''`을 **$NULL$과 동일하게 취급**한다.
  - 따라서:
    ```sql
    INSERT INTO TAB(COL2) VALUES('');
    -- COL2에는 NULL이 저장됨
    ```
- SQL Server 등 다른 DBMS:
  - `''`은 길이 $0$인 문자열(공백 없는 텍스트)로 저장된다.
  - $NULL$은 전혀 다른 값이다.

## 7-2. WHERE 조건에서의 영향

- Oracle에서:
  ```sql
  WHERE COL2 = ''   -- 사실상 WHERE COL2 IS NULL 과 같은 효과
  ```
- 이 차이 때문에 문제에서 “Oracle은 COL2에 $NULL$이, SQL Server는 공백이 입력된다” 같은 문장을 구분해야 한다.

---

# 📌 8. 순수 관계연산자와 일반 집합연산자

## 8-1. 순수 관계연산자(관계대수)

| 연산자    | 의미                            |
|----------|---------------------------------|
| SELECT   | 행 선택 ($\sigma$)             |
| PROJECT  | 열 선택 ($\pi$)                |
| JOIN     | 공통 속성을 기준으로 결합      |
| DIVISION | 포함 관계(“모든” 조건 만족)    |
| PRODUCT  | 카티션 곱(모든 조합)           |

## 8-2. 일반 집합연산자

| 연산자       | 의미                                               |
|-------------|----------------------------------------------------|
| UNION       | 합집합, 중복 제거                                  |
| UNION ALL   | 합집합, 중복 포함                                  |
| INTERSECT   | 교집합                                             |
| MINUS/EXCEPT| 차집합(첫 집합에서 두 번째 집합을 뺀 결과)         |

- 순수 관계연산자: 테이블(릴레이션)을 대상으로 하는 **관계대수 기본 연산**.
- 집합 연산자: 두 결과 집합을 **집합 이론** 관점에서 결합/차집합 등을 수행.

---

# 📌 9. INSERT ... SELECT 문법

## 9-1. 올바른 문법

- 테이블 구조가 동일할 때, 조건에 맞는 행을 그대로 복사하는 대표 패턴:
  ```sql
  INSERT INTO EMP_TEMP
  SELECT * 
  FROM EMP
  WHERE DEPTNO = 10;
  ```

## 9-2. 잘못된 문법 예시

- `VALUES`와 `SELECT`를 섞는 문법은 틀리다.
  ```sql
  -- 잘못된 예
  INSERT INTO EMP_TEMP VALUES (SELECT * FROM EMP WHERE DEPTNO = 10);
  ```
- $VALUES$는 보통 상수 튜플 하나(혹은 명시된 튜플들)를 입력할 때 사용하고,
- $INSERT \ \cdots \ SELECT$는 **서브쿼리 결과(여러 행)**를 입력할 때 사용한다.

---

# 📌 10. 집합 연산자 주의점 (UNION, INTERSECT 등)

## 10-1. ORDER BY 사용 규칙

- 집합 연산자를 사용할 때 **각 SELECT 안에 개별적으로 ORDER BY를 쓸 수 없다.**
- ORDER BY는 집합 연산 **전체 결과에 대해 한 번만** 사용 가능하다.
  ```sql
  SELECT ... FROM A
  UNION
  SELECT ... FROM B
  ORDER BY 1;
  ```
- 시험 함정:
  - “UNION 연산자를 사용할 때 각 SELECT 문에 ORDER BY를 사용할 수 있다” → 틀린 설명.

## 10-2. UNION vs UNION ALL vs INTERSECT

- $UNION$: 합집합, 중복 제거, 정렬이 수반될 수 있어 비용이 크다.
- $UNION \ ALL$: 중복 제거를 하지 않고 단순히 이어 붙인다.
- $INTERSECT$: 교집합 + 중복 제거(정렬/해시 연산 필요).

- “두 집합 간 중복이 없다면 UNION과 UNION ALL 결과는 동일하다” → 참.
  - 다만 성능 측면에서 $UNION ALL$이 더 유리하다(중복 제거 작업이 없기 때문).

---

# 📌 11. 1:1 필수관계의 의미

## 11-1. 1:1 필수 식별관계

예시: 주문(ORDER)과 주문상세(ORDER\_DETAIL)

- 조건:
  - 두 테이블 모두 $PK = 주문번호$를 가진다.
  - 주문이 입력되면 주문상세도 **반드시** 존재해야 한다.
- 의미:
  - 주문 : 주문상세 = $1:1$ 관계.
  - **필수 관계**이므로, 부모(주문)가 존재하면 자식(주문상세)이 항상 존재한다.
- 결과적으로:
  - $주문 \ MINUS \ 주문상세 = 0$건이어야 한다.
  - 두 테이블의 행 수가 이론상 동일하다.

## 11-2. 시험 포인트

- 1:1 필수관계 + 동일 PK(식별관계)라면:
  - 주문 테이블의 모든 행은 주문상세 테이블에 반드시 존재.
  - MINUS 결과가 0건이 되는 설명이 정답이 된다.

---

# 📌 12. 윈도우 함수와 WINDOWING 절

## 12-1. 기본 구조

```sql
함수() OVER (
  PARTITION BY ...
  ORDER BY ...
  WINDOWING ...
)
```

- $PARTITION \ BY$: 그룹을 나누는 기준.
- $ORDER \ BY$: 각 파티션 내에서의 순서.
- $WINDOWING$: 계산에 포함할 행의 **프레임 범위**를 지정.

## 12-2. WINDOWING 종류

1. **ROWS**
   - 물리적인 행 기준.
   - 예: 현재 행 포함 과거 $3$행까지 누적
     ```sql
     ROWS BETWEEN 3 PRECEDING AND CURRENT ROW
     ```
2. **RANGE**
   - ORDER BY 값의 범위 기준.
   - 같은 ORDER BY 값을 갖는 행들이 한꺼번에 포함될 수 있다.
3. **GROUPS** (버전에 따라 지원)
   - ORDER BY 값이 같은 행 집합을 하나의 그룹으로 보고, 그룹 단위로 프레임을 지정.

## 12-3. 대표 예시

- 누적합:
  ```sql
  SUM(sal) OVER (
    ORDER BY hiredate
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
  )
  ```
- 이동평균(이전 2행 + 현재행):
  ```sql
  AVG(sal) OVER (
    ORDER BY hiredate
    ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
  )
  ```

---

# 📌 13. ON DELETE CASCADE의 방향과 설정 위치

## 13-1. 동작 방향

- ON DELETE CASCADE의 의미:
  - **부모가 삭제되면, 그 부모를 참조하던 자식 행도 자동 삭제**.
- 반드시 기억할 것:
  - ✔ 부모 삭제 $\Rightarrow$ 자식 삭제 (허용)
  - ✖ 자식 삭제 $\Rightarrow$ 부모 삭제 (허용되지 않음)
- 참조 무결성 철학:
  > 자식은 부모를 참조할 뿐, 부모에게 영향을 줄 수 없다.

## 13-2. 설정 위치

- ON DELETE CASCADE는 **부모 테이블이 아니라, 자식 테이블의 외래키(FK)에 설정**한다.

예시:

```sql
CREATE TABLE dept (
  deptno NUMBER PRIMARY KEY
);

CREATE TABLE emp (
  empno  NUMBER PRIMARY KEY,
  deptno NUMBER,
  CONSTRAINT fk_emp_dept
    FOREIGN KEY (deptno)
    REFERENCES dept(deptno)
    ON DELETE CASCADE
);
```

- `DELETE FROM dept WHERE deptno = 10;`
  - 부서 $10$에 속했던 `emp` 행이 모두 삭제된다.
- `DELETE FROM emp WHERE empno = 100;`
  - `dept` 테이블에는 아무 영향이 없다.

---

# 📌 14. 본질식별자 vs 보조식별자, 그리고 NULL 비교(IN, =)

## 14-1. 다시 보는 본질/보조 식별자 정리

- **본질식별자(자연키)**:
  - 업무적으로 의미 있는 속성(또는 조합)에 의해 튜플이 유일하게 식별.
  - 복합키가 많고, 업무 변경에 취약.
- **보조식별자(인조키, Surrogate Key)**:
  - 시스템이 임의로 부여하는 PK 전용 값.
  - 관리, JOIN, 인덱스가 단순하지만, 중복 데이터는 별도 UNIQUE 제약으로 막아야 함.

## 14-2. IN(NULL)이 NULL을 포함하지 못하는 이유

예시 문제:

```sql
SELECT *
FROM TAB
WHERE COL1 IN (NULL, 'A', 'A', 'B');
```

테이블 데이터: $A, B, NULL, C$

- $IN$ 연산은 내부적으로 다음과 같이 해석된다.

  $$
  COL1 \in (x_1, x_2, \dots, x_n)
  \equiv (COL1 = x_1) \lor (COL1 = x_2) \lor \dots \lor (COL1 = x_n)
  $$

- $NULL$ 비교의 진리값:
  - $NULL = 'A' \Rightarrow UNKNOWN$
  - $NULL = 'B' \Rightarrow UNKNOWN$
  - $NULL = NULL \Rightarrow UNKNOWN$  (SQL에서 $NULL = NULL$은 TRUE가 아니다)
- 따라서 $COL1$이 $NULL$인 행에 대해:
  - `COL1 IN (NULL, 'A', 'B')`의 결과는 $UNKNOWN$.
- WHERE 절은 $TRUE$인 행만 통과시키므로:
  - $A$와 $B$만 출력되고, $NULL$ 값은 출력되지 않는다.

정리하면,

- $NULL$은 “값이 없다 / 모른다”를 의미하는 **3값 논리의 UNKNOWN**이기 때문에,
- $=$, $\neq$, $IN$ 같은 비교에서 **절대로 TRUE가 되지 않는다.**
- $NULL$을 찾고 싶으면 항상 `IS NULL`을 사용해야 한다.

---

# 📌 15. 전체 요약

1. 트랜잭션은 성능 향상 도구가 아니라, $ACID$를 통한 **데이터 정합성 보장 메커니즘**이다.
2. ROLLBACK은 **커밋되지 않은 변경만** 되돌리며, 커밋 이후는 취소할 수 없다.
3. 정규화에서 1차 정규형은 **도메인 원자성**과 **반복 그룹 제거**가 핵심이다.
4. 부분 함수적 종속을 제거하면 자연스럽게 **1:N 관계** 테이블 구조가 등장한다.
5. 본질식별자는 업무 의미가 있는 자연키, 보조식별자는 시스템이 만든 인조키이다.
6. ERD 관계에서는 Cardinality, Optionality, Participation 등이 핵심 요소이다.
7. FULL OUTER JOIN은 $(+)$ 문법으로 구현할 수 없으며, $(+)$는 한쪽에만 쓸 수 있다.
8. CONNECT BY에서 $PRIOR$가 붙은 쪽이 **부모(상위)**이며, 방향 해석에서 교재마다 용어가 달라질 수 있다.
9. Oracle은 빈 문자열 `''`을 $NULL$로 취급한다는 점이 타 DB와 다르다.
10. 순수 관계연산자와 집합 연산자의 역할 차이를 구분해야 한다.
11. $INSERT \ \cdots \ SELECT$는 여러 행을 삽입하는 표준 패턴이며, $VALUES$와 혼용할 수 없다.
12. UNION 계열에서는 ORDER BY를 전체 결과에 대해 한 번만 사용한다.
13. 1:1 필수 관계에서는 부모가 존재하면 자식도 반드시 존재해야 하며, MINUS 결과가 0건이다.
14. 윈도우 함수의 WINDOWING 절은 어떤 행 범위를 계산에 포함시킬지 정하는 프레임 정의이다.
15. ON DELETE CASCADE는 **부모 삭제 → 자식 삭제** 방향이며, 자식 테이블 FK에 설정한다.
16. $IN(NULL)$은 $NULL$ 값을 찾지 못하고, $IS \ NULL$을 사용해야 한다.
