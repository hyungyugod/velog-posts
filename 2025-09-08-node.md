# 📌 0. 로그처리와 사용
### 📌 0-1. 로거 모듈 만들기
- dotenv.config(); .env 파일을 읽어서 process.env에 저장.
- 이때 .env는 단순한 텍스트 파일인데 이를 파싱하여 Node.js가 제공하는 환경변수 저장소 객체인 process.env에 저장해둘 필요가 있다. 이를 dotenv 라이브러리가 하는 것이다.
- fs.mkdirSync로 디렉토리를 만든다. recursive: true라서 부모 디렉토리가 없어도 함께 생성.
- logger = winston.createLogger로 로거 객체를 만들어두어야한다.
- level: 로그 레벨 설정.
- format: 로그 출력 형식 정의.
- timestamp: 로그가 찍힌 시간 추가.
- errors({ stack: true }): 에러 객체를 전달했을 때 스택 트레이스까지 포함.
- printf: 출력되는 최종 문자열을 직접 커스터마이징. ${timestamp} [LEVEL]: message {meta} 형식.
- Transports (출력 대상)
- winston.format.colorize({ all: true })는 색깔을 입혀 가독성 향상한다. 그리고 아래 내용들을 저장하여 로그가 자동 기록되도록한다.
- DailyRotateFile(app-%DATE%.log): 모든 레벨의 로그를 일별 파일로 저장.
- maxSize: '20m': 파일이 20MB 넘으면 새 파일 생성.
- maxFiles: '14d': 최대 14일치 로그만 보관.
- zippedArchive: true: 오래된 로그는 자동으로 zip 압축.
- DailyRotateFile(error-%DATE%.log): 에러 레벨만 따로 저장. 30일치 보관.
- 이 로그 객체를 어디선가 호출하면 그대로 출력이 되는것
```js
// logger.js
import dotenv from 'dotenv';
import fs from 'node:fs';
import path from 'node:path';
import winston from 'winston';
import DailyRotateFile from 'winston-daily-rotate-file';

dotenv.config();

// 로그 디렉터리 준비
const logDir = process.env.LOG_PATH || 'logs';
fs.mkdirSync(logDir, { recursive: true });

const logger = winston.createLogger({
  level: (process.env.LOG_LEVEL || 'debug').toLowerCase(),
  format: winston.format.combine(
    winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    winston.format.errors({ stack: true }),
    winston.format.printf(({ timestamp, level, message, stack, ...meta }) => {
      const metaString = Object.keys(meta).length ? ` ${JSON.stringify(meta)}` : '';
      return `${timestamp} [${level.toUpperCase()}]: ${stack || message}${metaString}`;
    })
  ),
  transports: [
    // 콘솔 출력
    new winston.transports.Console({
      format: winston.format.combine(winston.format.colorize({ all: true })),
    }),

    // 전체 로그 (일별 회전)
    new DailyRotateFile({
      filename: path.join(logDir, 'app-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '20m',
      maxFiles: '14d',
    }),

    // 에러 전용 로그 (일별 회전)
    new DailyRotateFile({
      level: 'error',
      filename: path.join(logDir, 'error-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '20m',
      maxFiles: '30d',
    }),
  ],
});

export default logger;
```

### 📌 0-2. 로거 모듈의 사용
- 위에서 만든 로거 모듈을 아래와 같이 사용한다.
```js
// 1. 생성해 둔 로그 헬퍼 모듈 참조
// -> `LogHelper.js`에서 export한 logger 객체를 `logger`라는 이름으로 받는다.
import logHelper from "../helpers/LogHelper.js";
// 2. 로그 출력
// -> `LogHelper.js`에 설정된 내용에 따라, level에 맞는 로그가
// 콘솔과 파일에 각각 출력된다.
logHelper.error("이것은 에러 로그입니다.");
logHelper.warn("이것은 경고 로그입니다.");
logHelper.info("이것은 정보 로그입니다.");
logHelper.debug("이것은 디버그 로그입니다.");
logHelper.verbose("이것은 Verbose 로그입니다.");
console.log("로그 기록이 완료되었습니다.");
```

# 1. httoClient
### 📌 1-1. http클라이언트 요청
- const res = await fetch(`${API}${path}`, { method, headers, body }); 에서 베이스 URL과 경로를 합쳐 요청한다.
- 오류 처리: 2xx 아니면 throw → 호출한 쪽에서 try/catch로 받기.
- 응답 파싱: Content-Type이 JSON이면 res.json(), 아니면 res.text().
- 아래 get, post, put, delete는 각각 보낼 경로와 내용등을 받아서 요청 형식을 만들어주는 함수를 export한다.
```js
// httpClient.js
const API = 'https://jsonplaceholder.typicode.com';

async function request(path, { method = 'GET', headers, body } = {}) {
  const res = await fetch(`${API}${path}`, { method, headers, body });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  const ct = res.headers.get('content-type') || '';
  return ct.includes('application/json') ? res.json() : res.text();
}

// GET: 단건 조회
export async function getPost(id) {
  return request(`/posts/${id}`);
}

// GET: 쿼리스트링으로 필터링 (URLSearchParams 사용)
export async function getCommentsByPost(postId) {
  const qs = new URLSearchParams({ postId });
  return request(`/comments?${qs}`);
}

// POST: 새 리소스 생성 (FormData 사용)
export async function createPost({ title, body, userId }) {
  const form = new FormData();
  form.append('title', title);
  form.append('body', body);
  form.append('userId', String(userId));
  return request('/posts', { method: 'POST', body: form });
}

// PUT: 전체 수정 (필요한 필드만 넣어도 예제 API는 허용)
export async function updatePost(id, { title, body, userId }) {
  const form = new FormData();
  if (title !== undefined) form.append('title', title);
  if (body !== undefined) form.append('body', body);
  if (userId !== undefined) form.append('userId', String(userId));
  return request(`/posts/${id}`, { method: 'PUT', body: form });
}

// DELETE: 삭제
export async function deletePost(id) {
  return request(`/posts/${id}`, { method: 'DELETE' });
}

/* 사용 예시 (출력/로그 없음)
(async () => {
  const post = await getPost(1);
  const comments = await getCommentsByPost(1);
  const created = await createPost({ title: 'foo', body: 'bar', userId: 1 });
  const updated = await updatePost(1, { title: 'Updated Title' });
  const deleted = await deletePost(1);
})();
*/
```

### 📌 1-2. header 전송
- url: 요청을 보낼 엔드포인트(httpbin.org/headers는 요청 헤더를 그대로 돌려줌).
- authToken: 인증 토큰 예시(실무에선 로그인 등으로 발급받은 값 사용, 보통 Bearer <token>).
- options.headers:
- Content-Type: GET엔 일반적으로 불필요하지만, 헤더 설정 예시로 포함.
- Authorization: 인증 정보 전달.
- X-Custom-Header: 커스텀 헤더 예시.
- fetch + await: 요청/응답을 비동기적으로 수행.
- response.ok 검사: 2xx가 아니면 본문을 읽어 에러 throw.
- response.json(): 정상일 때 JSON 파싱 후 data로 활용.
```js
// headers_echo.js
(async () => {
  const url = 'https://httpbin.org/headers';
  const authToken = 'your-super-secret-auth-token';

  const options = {
    method: 'GET',
    headers: {
      // GET에는 보통 Content-Type이 필요 없지만, 예시로 포함
      'Content-Type': 'application/json',
      // 보통은 'Bearer <token>' 형태
      'Authorization': authToken,
      'X-Custom-Header': 'MyCustomValue',
    },
  };

  try {
    const response = await fetch(url, options);
    if (!response.ok) {
      const errorText = await response.text().catch(() => '');
      throw new Error(`HTTP ${response.status} ${response.statusText || ''} ${errorText}`.trim());
    }
    const data = await response.json();
    // TODO: data를 여기서 사용하세요 (예: 상태 저장, 반환 등)
  } catch (err) {
    // TODO: 네트워크/HTTP 에러 처리 로직
  }
})();
```

### 📌 1-3. 에러처리 메세지
- fetch는 네트워크 장애만 reject(DNS 실패, 오프라인 등).
- HTTP 4xx/5xx는 res.ok로 직접 검사 후 에러를 던져야 한다.
- 에러 본문은 JSON이 아닐 수 있으니 .text()로 안전하게 수집한다.
```js
// http_error_example.js
(async () => {
  const url = 'https://jsonplaceholder.typicode.com/posts/9999';

  try {
    const res = await fetch(url);

    // HTTP 에러(4xx, 5xx)는 fetch가 reject하지 않으므로 직접 검사
    if (!res.ok) {
      const body = await res.text().catch(() => '');
      const err = new Error(res.statusText || 'HTTP Error');
      err.status = res.status;   // 예: 404, 500
      err.body = body;           // 에러 응답 본문(문자열)
      throw err;
    }

    // 정상(2xx)일 때만 JSON 파싱
    const data = await res.json();
    // TODO: data 사용
  } catch (e) {
    // 네트워크 장애(fetch 자체 실패) 또는 위에서 throw한 HTTP 에러가 여기로 옴
    // e.status가 있으면 HTTP 에러, 없으면 네트워크 에러로 볼 수 있음
    // TODO: 에러 처리 (예: 상태코드별 분기, 사용자 메시지 표시, 재시도 등)
  }
})();
```

# 📌 2. open api 연동
### 📌 2-1. chat gpt연동하기
- 먼저 OpenAI Platform에 가입하고 API Keys 메뉴로 이동하여 Create new secret key 버튼을 클릭해 새로운 키를 생성한다.
- .env 파일을 생성하고 OPENAI_API_KEY="발급받은_API_키"로 키를 적어넣는다.
- .env → OPENAI_API_KEY 읽어서 없으면 즉시 에러.
- fetchHelper.post로 Content-Type: application/json + Authorization 헤더 설정.
- 응답에서 choices[0].message.content만 뽑아 문자열로 반환.
- 로깅/콘솔 출력 없음(호출한 쪽에서 결과를 표시하거나 저장).
```js
// openaiChat.js
import dotenv from 'dotenv';
import fetchHelper from '../helpers/FetchHelper.js';

dotenv.config();

const API_URL = 'https://api.openai.com/v1/chat/completions';
const API_KEY = process.env.OPENAI_API_KEY;
if (!API_KEY) throw new Error('Missing OPENAI_API_KEY');

export async function chat(prompt) {
  const params = {
    model: 'gpt-3.5-turbo',
    messages: [
      { role: 'system', content: 'You are a helpful assistant.' },
      { role: 'user', content: prompt },
    ],
    max_tokens: 1000,
    temperature: 0.7,
  };

  const headers = {
    'Content-Type': 'application/json',
    Authorization: `Bearer ${API_KEY}`,
  };

  const json = await fetchHelper.post(API_URL, params, headers);
  return json?.choices?.[0]?.message?.content ?? '';
}

/* 사용 예시
import { chat } from './openaiChat.js';
const answer = await chat('Node.js에서 파일 시스템을 다루는 방법을 설명해줘.');
*/
```