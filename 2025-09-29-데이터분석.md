# 📌 0. plotly
### 📌 0-1. plotly 세팅과 기본
- https://plotly.com/graphing-libraries/ 
- 위의 사이트에서 검색해서 예시를 찾아보면 된다.
- plotly는 기본적으로 동적으로 작동한다는 점에서 다른 시각화 패키지와 차별점이 있다.
- express는 좀 가벼운 버전으로 가볍게 사용하기 위해선 이 라이브러리로 충분하다.
- express의 약자로 px를 쓴다.
```py
import plotly.express as px
```
- 파이썬에서 딕셔너리 자료구조는 판다스의 데이터프레임 자료형으로 만들기에 용이하다.
```py
data = {
    'Month': ['January', 'February', 'March', 'January', 'February', 'March', 'January', 'February', 'March'],
    'Sales': [20000, 24000, 30000, 15000, 16000, 22000, 180000, 26000, 27000],
    'Ratio': [.234, .324, .3, .232, .1216, .332, .330, .330, .27],
    'Region': ['North', 'North', 'North', 'South', 'South', 'South', 'East', 'East', 'East']
}

df_data = pd.DataFrame(data)
df_data.head(3)
```
- 아래서 데이터 프레임을 테스트 해보기 위해 seaborn으로 데이터를 한번 그려본다.
- plt.tight_layout()은 그림 간격을 최적화 해주는 함수이다. -> 즉 그래프 전체 레이아웃을 자동으로 정리해준다.
```py
# seaborn
plt.figure(figsize=(8, 2))
plt.subplot(1,2,1)
sns.barplot(x='Month', y='Sales', data=df_data, ci=None, hue='Region')
plt.subplot(1,2,2)
sns.barplot(x='Month', y='Ratio', data=df_data, ci=None, hue='Region')
plt.tight_layout()
plt.show()
```

### 📌 0-2. px.barplot
- plotly는 웬만하면 변수로 저장하고 변수.show로 보여주는게 정석이다.
- plotly는 matplotlib.pyplot과 연동되는 것이 아니므로 크기조절을 직접 매개변수로 줘서 사용해야한다.
- barmode는 bar의 형태를 변경한다.
- color로는 색상을 구분하는 기준이 될 컬럼을 지정한다.
- text로는 그래프 위에 표시할 컬럼 값을 지정한다.
- 라벨을 통해 라벨의 기본값을 바꾸고 title을 통해 제목을 입력한다.
- width와 height로 픽셀단위로 그래프의 사이즈를 조절한다.
```py
figbar = px.bar(df_data, 
                x="Month", y="Sales",
                barmode='group',   # 막대그래프 모형 : 병렬형태
                # barmode='stack', # 막대그래프 모형: 축적 stack 형태
                # barmode=relative, # 막대그래프 모형: 비율
                color='Region',
                text='Ratio',
                title='Monthly Sales',
                labels={'Sales': 'Sales in $'},
                height=300, width=600)
figbar.show()
```

### 📌 0-3. px.line()
- 우선 할 것을 seaborn으로 한번 그려본다.
```py
# seaborn
plt.figure(figsize=(5, 2))
sns.lineplot(x="date", y="amount", data=df_data)
plt.xticks(rotation=45)
plt.show()
```
- 이를 px.line으로 그리면 아래와 같다.
- 중요한 것은 데이터를 평균 내는 계산을 seaborn처럼 자동으로 해주지 않으므로 groupby나 pivot_table을 통해 평균을 내야한다.
- 이때 x축, y축은 차원 즉 컬럼이어야 하는데 (value) 피벗테이블이나 그룹바이는 한 컬럼을 인덱스로 만들어주므로 다시 원래처럼 숫자 인덱스로 만들고 축으로 삼았던 컬럼을 다시 컬럼으로 돌릴 필요가 있다. 이 명령어가 바로 reset_index()이다.
- 나머지 표현법은 barplot과 같다.
```py
# pd.pivot_table(df_data, index="date", values="amount", aggfunc="mean").reset_index()
pv_fig_line = df_data.groupby('date')['amount'].mean().reset_index()

fig_line = px.line(pv_fig_line,
                   x='date', y='amount',
                   height=300, width=600,
                   title='Monthly Sales',
                   labels={'amount': 'Sales in $'}
                   )
fig_line.show()
```
- 화면분할은 facet_col, facet_row를 사용하는데 범주별로 따로 그래프를 따로 그려서 분할해준다.
```py
fig_line = px.line(df_data,
                   x='date', y='amount',
                   height=300, width=600,
                   color = 'payment',
                   facet_col='category',
                   facet_row='payment',
                   title='Monthly Sales',
                   labels={'amount': 'Sales in $'}
                   )
fig_line.show()
```

### 📌 0-4. px.histogram
- nbins는 히스토그램을 몇개의 구간(bins)로 나눌지 설정하는 옵션이다.
```py
fig_hist = px.histogram(
    iris,
    x='sepal_length',
    # y='species',
    color='species',
    height=300,
    width=600,
    barmode='relative',
    nbins=20,
)
fig_hist.show()
```

### 📌 0-5. 그래프 데코레이션
- 그래프 상에 글자 text 표기 방법과 옵션들은 아래와 같다.
```py
# 그래프 상에 글자 text 표기 방법 
fig_hist.add_annotation(
    x=6, y=10, text='text annotation',
    bgcolor='white', # 주석의 background color
    opacity=0.7,
    showarrow=False, # 화살표 표시여부: Truem False
    font=dict(size=15, color='black')
)
```
- 또한 그래프 상에 선을 긋는 방법은 아래와 같다.
```py
# 선 line 긋기: 세로줄
fig_hist.add_vline(x=7,
                   line_width=5,
                   line_dash='dash', 
                   line_color='blue')

# 선 line 긋기: 세로줄
fig_hist.add_hline(y=10,
                   line_width=5,
                   line_dash='dash', 
                   line_color='blue')
```
- 영역을 표시하는 방법은 아래와 같다.
```py
# 영역표시: 세로영역
fig_hist.add_vrect(x0=7, x1=5,
                   line_width=5, 
                   fillcolor='yellow',
                   opacity=0.2)

# 영역표시: 가로영역
fig_hist.add_hrect(y0=12, y1=15, 
                   line_width=5,
                   line_dash='dash', 
                   fillcolor='yellow',
                   opacity=0.5)
```

### 📌 0-6. px.pie()
- values에 데이터를 주면 알아서 비율을 분배하여 파이차트를 그려준다.
- hole은 파이차트 가운데에 구멍을 뚫어주는 옵션이다.
```py
data = {
    'Fruit': ['Apples', 'Oranges', 'Bananas', 'Apples', 'Oranges', 'Bananas'],
    'Amount': [50, 31, 42, 17, 36, 27],
    'City': ['New York', 'New York', 'New York', 'Montreal', 'Montreal', 'Montreal']
}
df_data = pd.DataFrame(data)
fig_pie = px.pie(df_data, 
                 values='Amount', # pie chart 크기(각도) 결정
                 names='City',    # pie chart 영역(구분) 항목
                 hole=0.1,
                 height=400,
                 width=400)
fig_pie.show()
```

### 📌 0-7. px.strip()
```py
iris = sns.load_dataset('iris')
fig_strip = px.strip(iris,
                     x='species',
                     y='sepal_width',
                     color='species',
                     hover_data=['sepal_length','petal_length'], # 마우스 호버
                     height=400,
                     width=500)
fig_strip.show()
```

# 0-8. px.scatter()
```py
iris = sns.load_dataset('iris')
fig = px.scatter(iris,
                 x='species',
                 y='sepal_width',
                 color='species',
                 hover_data=['sepal_length','petal_length'], # 마우스 호버
                 height=400,
                 width=500
                 )
fig.show()
```

# 📌 1. 웹 크롤링
### 📌 1-1. pandas
- 간단한 사이트의 경우에는 pandas의 read_html을 이용하여 크롤링이 가능하다.
```py
pd.read_html('https://www.w3schools.com/html/html_tables.asp')
```

### 📌 1-2. requests, BeautifulSoup으로 증시정보 가져오기
- requests 라이브러리는 서버로 요청을 대신 보내주는 역할을 한다. 아래서는 해당 url로 get요청을 보낸다.
- 요청을 받으면 돌아온 html, css, js 를 포함하여 여러 정보가 있을 것인데 이를 정리해주기 위해서 BeautifulSoup을 이용한다.
```py
import requests
from bs4 import BeautifulSoup
url = "https://finance.naver.com/marketindex/"
market_index = requests.get(url) # get 요청보냄
```
- 받아온 응답들을 html.parser로 파싱하고 이를 변수에 저장해둔다.
- 파싱된 객체에서 find 메서드로 태그 종류와 태그의 속성을 주면 해당 태그 중 첫번째 태그의 모든 요소를 긁어온다. 이때 .text를 통해 태그 내부의 내용만 가져올 수 있다.
```py
soup = BeautifulSoup(market_index.content, 'html.parser') #lxml
soup.find("span", class_="value").text # tag 내부의 text를 가져온다. -> 첫번째 결과만 가져온다.
```
- 만약 태그의 전부를 가져온다면 find_all을 사용하면 해당하는 태그 전체를 가져온다.
- 이때 리스트로 받아오므로 for문으로 돌아서 각각 text를 접근하면 모든 text를 출력해볼 수 있다.
```py
soup.find_all("span", class_="value") # tag 내부의 text를 가져온다. -> 모든 결과를 리스트로 가져온다.
for i in soup.find_all("span", class_="value"): # tag처리 시, 리스트 자료구조를 for로 돌아줄 필요가 있다.
  print(i.text)
```