# 알고리즘의 소개
- 시중에 있는 그로킹 알고리즘(아디티아바르가바 저)를 읽고 공부용으로 간단하게 정리함. 
- 혹시 누군가 본다면 당연히 정보는 많이 생략되어있으니니 자세한 정보는 책을 직접 사보시길.
## 1. 이진 탐색(binary search)
### 1-1. 단순 탐색
- 앞에서부터 일일히 탐색하는 것
  
### 1-2 이진탐색이란 
- 처음부터 일일히 찾는 방식이 아니라 절반을 기준으로 크고 작음을 따지며 점점 범위를 줄여가는 것
- 시간 복잡도가 log n이다. 

#### 1-2-1 예제 코드
```python
def binary research(arr, item): # item은 찾고자 하는 것이고 arr은 주어진 배열이다.

    low = 0           # 인덱스 0을 의미한다.
    high = len(arr)-1 # 주어진 배열의 실제 인덱스를 사용하게 하기 위함.

    while low <= high: 

        mid = (low + high) // 2 # 아래로 내림으로서 중간값을 구할 수 있음.
        guess = arr[mid] # 배열의 중간값으로 항상 추측함.

        if guess == item:
            return mid
        
        elif guess > item:
            high = mid - 1 # 예측했던 값보다 한칸 아래로 최대치를 조정 -> mid는 답이 아니었으니
        else guess < item:
            low = mid + 1  # 추측지점 포함 그 아래는 원하는 값이 없음. +1 로 설정

    return none

    # 만약 low가 high보다 커진다면 그건 찾는 값이 없어 하이, 로우가 한점에 모여 결국 low가 추월했다는 뜻 그럼 while문이 종료되면서 none을 리턴함.

    # return을 만나면 함수가 종료되므로 while문은 조건과 무관하게 자동 종료된다.
```

### 1-3 실행시간
- 단순탐색 = 선형시간 (linear time)
- 이진탐색 = 로그시간 (logarithmic time)

## 2. 빅오 표기법 (big O notion)
- 알고리즘의 실행시간을 나타내며 정확히는 O(n)과 같이 쓰고 n(자료의 양)이 증가함에 따라 증가하는 연산횟수를 괄호안에 대입하여 표기한다.
- 빅오 표기법은 최악의 실행 시간을 의미하며 이는 아무리 느려도 해당 알고리즘이 이 시간안에는 끝난다는 것을 의미한다.

### 2-1. 많이 사용하는 빅오 실행시간의 예
- O(logn) 로그시간: 이진탐색
- O(n) 선형시간: 단순탐색
- O(nlogn): 퀵 정렬처럼 빠른 알고리즘
- O(n^2): 선택정렬처럼 느린 알고리즘
- O(n!): 외판원 문제처럼 너무 느린 알고리즘 -> n곳의 도시를 차례로 들리는 경우의 수


# 선택 정렬
## 1. 메모리가 작동하는 방식
- 메모리는 주소가 있는 서랍과 같다.

## 2. 배열과 연결리스트
### 2-1 배열
- 일렬로 메모리의 일정 부분을 차지, 따닥따닥 붙어있음.
- 옮겨도 다같이 옮기고 뭐 추가할때마다 다 옮김, 삭제도 마찬가지
- 하지만 전체 위치가 뻔히 보이므로 위치(인덱스)를 한번에 찾을 수 있음.

### 2-2 연결리스트
- 연결리스트는 배열과 달리 떨어져 있을 수 있음. 
- 다만 한 원소에 다음과 이전 원소의 정보가 포함되므로 소량의 추가메모리가 듦.
- 원소의 추가, 삭제는 그냥 하나만 빼고 더하고 앞 뒤 정보들만 바꾸면 되므로 배열보다 나음.

### 2-3 뭘 더 많이 쓰나
- 배열은 임의 접근가능, 연결리스트는 순차접근해야함. 보물찾기마냥 하나 찾아야 다음걸로 찾아갈 수 있기 때문.
- 배열은 캐싱을 이용하여 주어진 원소들을 한번에 읽을 수 있다.
- 심지어 메모리도 연결리스트가 더 먹는다. 포인터(다음 원소정보) 메모리 때문이다.

## 3. 선택 정렬
- 많이 들은 가수 순으로 정렬하기
- 가수별로 플레이 수 정리하는라 한번, 옮겨서 정렬하는데 한번 총 n * n(사실 1/2인데 빅오는 상수생략) 즉 O(n^2) 시간이 소요됨.

#### 3-1-1 예제 코드
```python
    def findSmallist(arr): # 가장 작은 값을 찾는 코드드
        smallest = arr[0]  # 일단 배열 첫번째를 가장 작은 수로 생각각
        smallest_index = 0

        for i in range(1, len(arr)):
            if arr[i] < smallest:  # 순차적으로 비교하며 더 작으면 small로 업데이트트
                smallest = arr[i]
                smallest_index = i

        return smallest_index      # 다 반복하면 제일 작은 small이 최종으로 남음

    def selectionSort(arr): 
        newArr = []
        copiedArr = list(arr)  # 원래 배열 리스트로 저장
        
        for i in range(len(copiedArr)):    
            smallest = findSmallest(copiedArr)
            newArr.append(copiedArr.pop(smallest)) # pop 은 해당 인덱스에 있는 원소를 꺼내면서 이를 배열에서 제거한다. 즉 이를 반복함으로서 작은 값들을 순차적으로 꺼낼 수 있다.
        
        return newArr
```







