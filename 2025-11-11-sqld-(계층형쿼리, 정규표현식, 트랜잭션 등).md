# 📌 1. FETCH, WITH TIES, IN / NULL, 3값 논리  

## 1-1. `FETCH FIRST` vs `FETCH NEXT`

### 구문
```sql
SELECT ...
FROM ...
ORDER BY ...
OFFSET n ROWS
FETCH FIRST m ROWS ONLY;   -- 또는
FETCH NEXT  m ROWS ONLY;
```

### 핵심

- 기능적으로 **완전히 동일**하다.
- 둘 다 `OFFSET` 이후에서 **m개의 행만 가져온다.**
- 의미상 관례:
  - 첫 페이지: `FETCH FIRST`
  - 두 번째 이후 페이지: `FETCH NEXT`

실제 엔진 입장에서는 둘 다 “`OFFSET` 이후 **다음 m개 행**”이라는 같은 의미다.

---

## 1-2. `WITH TIES`와 `ORDER BY`

### 구문
```sql
SELECT ...
FROM ...
ORDER BY score DESC
FETCH FIRST 3 ROWS WITH TIES;
```

### 역할

- `WITH TIES`는 **마지막 행과 같은 정렬 키 값을 가진 행을 추가로 포함**시킨다.
  - 예: 상위 3등까지 뽑는데, 3등 점수와 같은 점수의 학생이 더 있으면 모두 포함.

### 왜 `ORDER BY`가 필수인가?

- `WITH TIES`의 “tie(동점)”은 **정렬 기준이 있을 때만 의미**가 있다.
- `ORDER BY`가 없으면:
  - “무엇이 동점인지” 기준이 존재하지 않는다.
  - 그래서 표준 SQL에서 `WITH TIES`는 **`ORDER BY` 없이 사용 불가**(문법 오류).

---

## 1-3. `IN`과 `NULL`, 3값 논리

### 예시 1: `10 IN (10, NULL)`

내부적으로 다음처럼 해석된다.

- 10 IN (10, NULL)
- ⇒ (10 = 10) OR (10 = NULL)
  - 10 = 10 → `TRUE`
  - 10 = NULL → `UNKNOWN` (NULL과 비교는 항상 알 수 없음)

3값 논리에서:

- `TRUE OR UNKNOWN` → `TRUE`

따라서

- `10 IN (10, NULL)` → `TRUE`

### 예시 2: `10 IN (NULL)`

- 10 = NULL → `UNKNOWN`
- WHERE 절에서는 `UNKNOWN`은 필터링(거의 FALSE처럼) 취급 → 조건 불만족.

정리:

- `IN`은 여러 비교를 `OR`로 묶은 것과 같다.
- 하나라도 **확실히 TRUE**이면 전체 결과는 TRUE.
- `NULL`과의 비교는 언제나 `UNKNOWN`이지만,
  - 그 앞에 이미 TRUE가 있으면 전체는 TRUE,
  - 전부 UNKNOWN이면 최종적으로 조건을 만족하지 않은 것으로 취급된다.

---

# 📌 2. 오라클 계층형 쿼리 (START WITH / CONNECT BY)

## 2-1. 기본 키워드와 의미

### 1) `START WITH`

- **루트(시작 노드)** 를 지정하는 절.
- 예:
  ```sql
  START WITH 상위메뉴ID IS NULL
  ```
  → 상위메뉴ID가 `NULL`인 행이 **모두 LEVEL = 1** 이 된다.

### 2) `CONNECT BY` + `PRIOR`

```sql
CONNECT BY PRIOR 부모컬럼 = 자식컬럼
```

- `PRIOR`가 붙은 쪽이 **부모**.
- 예:
  ```sql
  CONNECT BY PRIOR 메뉴ID = 상위메뉴ID;
  ```
  - 부모의 `메뉴ID` = 자식의 `상위메뉴ID`
  - 루트에서 아래 방향(자식 방향)으로 내려가며 트리 탐색.

반대로:

```sql
CONNECT BY 메뉴ID = PRIOR 상위메뉴ID;
```

- 이번엔 `상위메뉴ID`쪽이 부모가 된다.

### 3) `ORDER SIBLINGS BY`

```sql
ORDER SIBLINGS BY 메뉴ID DESC;
```

- **같은 부모를 가진 형제 노드들끼리** 정렬.
- 트리 전체 구조는 유지하면서, 각 부모 아래의 자식들만 정렬 순서를 바꿈.

---

## 2-2. `LEVEL`과 계층 구조

- `LEVEL`은 오라클이 자동 제공하는 **가상 컬럼**.
- 규칙:
  - `START WITH` 조건을 만족하는 행 → LEVEL = 1
  - 그 자식 → LEVEL = 2
  - 손자 → LEVEL = 3 …

예:
```sql
SELECT LEVEL, 메뉴ID, 상위메뉴ID
FROM 메뉴
START WITH 상위메뉴ID IS NULL
CONNECT BY PRIOR 메뉴ID = 상위메뉴ID;
```
- 상위메뉴ID가 `NULL`인 `M000`이 LEVEL 1.
- 그 밑의 메뉴들이 LEVEL 2, 그 밑이 LEVEL 3 …

---

## 2-3. `CONNECT BY` 관련 함수 4개 + `SYS_CONNECT_BY_PATH`

| 함수명 | 의미 | 예시 / 활용 |
|--------|------|-------------|
| `LEVEL` | 현재 노드의 깊이 | 루트 1, 자식 2, 손자 3 … |
| `CONNECT_BY_ROOT(col)` | 해당 노드가 속한 **루트 값** | 각 행에 “최상위 메뉴명” 붙이기 |
| `CONNECT_BY_ISLEAF` | 리프 노드(자식 없음)면 1, 아니면 0 | 말단 메뉴만 필터링 |
| `CONNECT_BY_ISCYCLE` | 순환(cycle)에 포함되면 1 | 잘못된 부모-자식 순환 구조 탐지 |
| `SYS_CONNECT_BY_PATH(col, 구분자)` | 루트부터 현재 노드까지의 **경로 문자열** | `/홈/회사소개/인사말` 같은 전체 메뉴 경로 |

예:
```sql
SELECT
  LEVEL,
  CONNECT_BY_ROOT 메뉴이름 AS 루트,
  메뉴이름,
  SYS_CONNECT_BY_PATH(메뉴이름, '/') AS 전체경로,
  CONNECT_BY_ISLEAF AS 리프여부
FROM 메뉴
START WITH 상위메뉴ID IS NULL
CONNECT BY PRIOR 메뉴ID = 상위메뉴ID
ORDER SIBLINGS BY 메뉴ID;
```

---

## 2-4. 순환 방지: `CONNECT BY NOCYCLE`와 `CONNECT_BY_ISCYCLE`

- 잘못된 데이터로 인해 부모-자식이 순환하면 무한 루프 위험.
- 해결:

```sql
SELECT ...
FROM 메뉴
START WITH 상위메뉴ID IS NULL
CONNECT BY NOCYCLE PRIOR 메뉴ID = 상위메뉴ID;
```

- `NOCYCLE` : 순환이 감지되면 그 **경로 확장을 중단**.
- `CONNECT_BY_ISCYCLE` : 그 행이 순환에 포함되었는지 여부(1/0)를 알려줌.

---

## 2-5. 계층형 질의 처리 순서 (GROUP BY 포함)

논리적 순서:

1. `FROM` (+ 기본 `WHERE`)
2. `START WITH`로 루트 행 찾기 → LEVEL = 1
3. `CONNECT BY`로 자식 행 재귀 탐색, LEVEL 증가
4. 계층 구조가 완성된 후 `SELECT` 컬럼 평가
5. `ORDER SIBLINGS BY`로 형제 노드 정렬
6. `GROUP BY` / `HAVING` 있으면 계층 결과에 대해 집계
7. 최종 `ORDER BY` 있으면 전체 결과 정렬

---

# 📌 3. PIVOT / UNPIVOT, 컬럼명과 값, 따옴표 규칙  

## 3-1. 작은따옴표 vs 큰따옴표 핵심

- `' '` (작은따옴표): **문자열 값(literal)**  
  - 예: `'2023'`, `'남자'`
- `" "` (큰따옴표): **식별자(identifier, 컬럼명/별칭)**  
  - 예: `"2023_매출"`, `"학생 이름"`

---

## 3-2. UNPIVOT 예제에서의 따옴표

원본 (PIVOT 결과) 테이블:

| 지점 | 2023_매출 | 2024_매출 |
|------|-----------|-----------|
| A    | 300       | 400       |

UNPIVOT:

```sql
SELECT *
FROM PIVOT_결과
UNPIVOT (
  매출           -- 새 값 컬럼 이름 (식별자)
  FOR 연도 IN (  -- 새 기준 컬럼 이름 (식별자)
    "2023_매출" AS '2023',
    "2024_매출" AS '2024'
  )
);
```

결과:

| 지점 | 연도 | 매출 |
|------|------|------|
| A    | 2023 | 300  |
| A    | 2024 | 400  |

왜 이렇게 쓰는가?

- `매출`, `연도` → **새로 생기는 컬럼명** → 식별자 → 따옴표 불필요.
- `"2023_매출"` → 기존 컬럼명.
  - 숫자로 시작하고 `_`가 있는 이름 → 식별자라서 **큰따옴표 필요**.
- `'2023'`, `'2024'` → UNPIVOT 후 **연도 값으로 들어갈 데이터** → 작은따옴표.

정리:

- `IN ( "2023_매출" AS '2023' )`
  - 왼쪽 `"2023_매출"`: **컬럼명**
  - 오른쪽 `'2023'`: **값**

---

# 📌 4. 정규표현식 – POSIX / PERL(PCRE)

## 4-1. POSIX 기본 메타문자

| 연산자 | 의미 / 설명 | 예시 |
|--------|-------------|------|
| `^` | 문자열 시작 | `^a` → a로 시작 |
| `$` | 문자열 끝 | `a$` → a로 끝 |
| `.` | 임의의 한 문자 (줄바꿈 제외) | `a.b` → `acb`, `a1b` 등 |
| `[ ]` | 문자 클래스: 안에 있는 문자 중 하나 | `[abc]` |
| `[^ ]` | 부정 문자 클래스: 안에 없는 문자 | `[^0-9]` |
| `*` | 앞 패턴 0회 이상 | `a*` |
| `+` | 앞 패턴 1회 이상 | `a+` |
| `?` | 앞 패턴 0 또는 1회 | `a?` |
| `{n}` | 정확히 n회 반복 | `a{3}` |
| `{n,}` | n회 이상 반복 | `a{2,}` |
| `{n,m}` | n~m회 반복 | `a{2,4}` |
| `|` | OR | `a|b` |
| `()` | 그룹화 | `(ab)+` |
| `\` | 이스케이프 | `\.` →

---

## 4-2. POSIX 문자 클래스

형식: `[[:class:]]`

| 클래스 | 의미 | 동일 범위 |
|--------|------|-----------|
| `[[:digit:]]` | 숫자 | `[0-9]` |
| `[[:lower:]]` | 소문자 | `[a-z]` |
| `[[:upper:]]` | 대문자 | `[A-Z]` |
| `[[:alpha:]]` | 영문자 | `[a-zA-Z]` |
| `[[:alnum:]]` | 영문자 + 숫자 | `[0-9a-zA-Z]` |
| `[[:blank:]]` | 공백(space, tab) | – |
| `[[:space:]]` | 모든 공백류 (space, tab, 개행 등) | – |

---

## 4-3. PERL(PCRE) 문자 클래스 단축 표기

| 기호 | 의미 | POSIX 대응 |
|------|------|-----------|
| `\d` | 숫자 | `[0-9]` |
| `\D` | 숫자가 아닌 문자 | `[^0-9]` |
| `\w` | 단어 문자 (영문, 숫자, `_`) | `[a-zA-Z0-9_]` |
| `\W` | 단어 문자가 아닌 문자 | `[^a-zA-Z0-9_]` |
| `\s` | 공백 문자 (space, tab, 개행 등) | `[ \t\r\n\f]` |
| `\S` | 공백이 아닌 문자 | `[^ \t\r\n\f]` |

---

## 4-4. PERL 수량자와 비탐욕(Non-greedy) 수량자

기본(탐욕적, Greedy):

- `*` : 0회 이상, 가능한 많이
- `+` : 1회 이상, 가능한 많이
- `?` : 0 또는 1회
- `{n}`, `{n,}`, `{n,m}` : 반복 횟수 지정

비탐욕(최소 매칭, Non-greedy) – 뒤에 `?` 붙이기:

- `*?` : 0회 이상, 가능한 적게
- `+?` : 1회 이상, 가능한 적게
- `??` : 0 또는 1회, 가능한 적게
- `{n,m}?` : n~m회, 가능한 적게

예:

```sql
SELECT REGEXP_SUBSTR('aaabbb', 'a+?b') FROM DUAL;
```

- 패턴 `a+?b`:
  - `a+` : a 1회 이상
  - `+?` : 그중 **최소**로 매칭
- 문자열 `aaabbb`에서
  - 첫 번째 `a`만 매칭하고 바로 `b`와 결합 → `"ab"` 반환.

---

## 4-5. REGEXP_INSTR, REGEXP_SUBSTR 파라미터 핵심

### 1) `REGEXP_INSTR`

```sql
REGEXP_INSTR(
  문자열,
  '패턴',
  시작위치,
  몇번째_매칭,
  반환위치형태
)
```

예:
```sql
SELECT REGEXP_INSTR(
  'apple banana cherry',
  '[a-z]+',
  1,    -- 검색 시작 위치
  2,    -- 두 번째 매칭
  1     -- 0: 시작 위치, 1: 끝 위치
)
FROM DUAL;
```

- `[a-z]+` : 소문자 연속(단어) 매칭 → `apple`, `banana`, `cherry`
- 두 번째 단어는 `"banana"`.
- `반환위치형태 = 1` → **끝 위치** 반환 → `"banana"`의 마지막 문자 위치 13.

### 2) `REGEXP_SUBSTR` 예제

```sql
SELECT REGEXP_SUBSTR('aaabbb', 'a+?b')
FROM DUAL;
```

- 비탐욕 `+?` 때문에
- 첫 번째 `a`와 바로 뒤 `b`가 매칭 → `"ab"`.

---

# 📌 5. 문자열 / 집계 함수: REGEXP_LIKE, COUNT, INSTR, SUBSTR, REPLACE  

## 5-1. 함수별 정리

| 함수 | 시그니처 | 역할 |
|------|----------|------|
| `REGEXP_LIKE` | `REGEXP_LIKE(컬럼, '패턴', '옵션')` | 정규식 패턴과 일치 여부를 TRUE/FALSE로 반환. WHERE 조건에 사용. |
| `COUNT` | `COUNT(*)`, `COUNT(컬럼)`, `COUNT(DISTINCT 컬럼)` | 행 개수 / NULL 제외 값 개수 / 중복 제거 개수 |
| `INSTR` | `INSTR(문자열, 찾을문자 [, 시작위치 [, 발생횟수]])` | 찾을문자가 나타나는 위치(정수)를 반환 |
| `SUBSTR` | `SUBSTR(문자열, 시작위치 [, 길이])` | 부분 문자열 추출. 시작위치가 음수면 뒤에서부터. |
| `REPLACE` | `REPLACE(문자열, 찾을문자 [, 바꿀문자])` | 문자열 내에서 지정 문자열을 다른 문자열로 치환. 바꿀문자 생략 시 삭제. |

---

## 5-2. 간단 예시

```sql
-- 숫자로만 이루어진 행 찾기
SELECT *
FROM T
WHERE REGEXP_LIKE(col, '^[0-9]+$');

-- INSTR
SELECT INSTR('HELLO WORLD', 'O', 1, 2)  -- 두 번째 O 위치 = 8
FROM DUAL;

-- SUBSTR
SELECT SUBSTR('DATABASE', 5, 3)  -- 'BAS'
FROM DUAL;

-- REPLACE
SELECT REPLACE('SQL SQL', 'SQL', 'DB')  -- 'DB DB'
FROM DUAL;
```

---

# 📌 6. MERGE 문법  

## 6-1. MERGE 기본 구조

```sql
MERGE INTO 타겟테이블 t
USING 소스테이블 s
ON (조인조건)
WHEN MATCHED THEN
    UPDATE SET ...
WHEN NOT MATCHED THEN
    INSERT (컬럼목록) VALUES (값목록);
```

- `타겟테이블` : 최종적으로 변경될 테이블.
- `소스테이블` : 새 데이터(또는 기준 데이터).
- `ON` : 두 테이블의 조인 조건 (예: `t.id = s.id`).
- `WHEN MATCHED` : 조건이 **일치(존재)** → UPDATE.
- `WHEN NOT MATCHED` : 조건이 **일치하지 않음(미존재)** → INSERT.

---

## 6-2. 동작 요약

1. `USING`의 각 행을 기준으로 `MERGE INTO` 대상과 조인.
2. 조건 일치:
   - `WHEN MATCHED` → 해당 행 UPDATE.
3. 조건 불일치:
   - `WHEN NOT MATCHED` → 새 행 INSERT.

실질적으로 **UPSERT** (존재하면 UPDATE, 없으면 INSERT)의 역할.

---

# 📌 7. 트랜잭션 개념, 명시적 / 묵시적 트랜잭션  

## 7-1. 트랜잭션 기본

- 하나의 논리적 작업 단위.
- 모든 작업이 **전부 성공(Commit)** 하거나, **전부 취소(Rollback)** 되어야 함.
- 주요 TCL(Transaction Control Language):
  - `COMMIT`: 변경 사항 확정
  - `ROLLBACK`: 최근 COMMIT 이후 변경 사항 취소
  - `SAVEPOINT`: 부분 롤백 지점 설정

---

## 7-2. 명시적(Explicit) 트랜잭션

```sql
BEGIN TRANSACTION;

UPDATE 계좌 SET 금액 = 금액 - 100000 WHERE 계좌번호 = '111';
UPDATE 계좌 SET 금액 = 금액 + 100000 WHERE 계좌번호 = '222';

COMMIT;
```

- `BEGIN TRANSACTION` 으로 **시작을 직접 선언**.
- 여러 DML을 하나의 트랜잭션으로 묶을 수 있음.
- 반드시 `COMMIT` 또는 `ROLLBACK`으로 끝내야 한다.

---

## 7-3. 묵시적(Implicit) 트랜잭션

- `BEGIN TRANSACTION`을 명시하지 않아도,
  - DML(INSERT/UPDATE/DELETE)을 실행하면 **자동으로 트랜잭션 시작**.
- 하지만 여전히 **COMMIT 또는 ROLLBACK은 수동**으로 호출해야 한다.
- 논리 구조:
  ```sql
  -- DML 실행 → 자동으로 트랜잭션 시작
  UPDATE ...;
  UPDATE ...;
  COMMIT;  -- 여기서 트랜잭션 종료
  ```

---

# 📌 8. Isolation Level & 동시성 문제 (Dirty / Non-repeatable / Phantom)

## 8-1. 4단계 Isolation Level

| 레벨 | 이름 | 설명 |
|------|------|------|
| 0 | Read Uncommitted | 커밋되지 않은 데이터도 읽는다. |
| 1 | Read Committed | 커밋된 데이터만 읽는다. (Oracle 기본) |
| 2 | Repeatable Read | 같은 행을 여러 번 읽어도 값이 변하지 않는다. |
| 3 | Serializable | 트랜잭션을 순차적으로 실행한 것과 같은 완전 고립 상태. |

---

## 8-2. 세 가지 문제 유형

### 1) Dirty Read

- “커밋되지 않은 데이터”를 읽은 경우.
- 트랜잭션 A가 값을 100 → 200으로 바꿨지만 아직 COMMIT 전,
- 트랜잭션 B가 200을 읽는다.
- 이후 A가 ROLLBACK 하면, B는 “존재하지 않는 값”을 본 셈.

### 2) Non-repeatable Read

- 같은 행을 두 번 읽었는데 값이 다름.
- A: `SELECT 금액 FROM 계좌 WHERE id = 1;` → 100
- B: `UPDATE 계좌 SET 금액 = 200 WHERE id = 1; COMMIT;`
- A: 같은 SELECT 재실행 → 200

### 3) Phantom Read

- 같은 조건으로 두 번 조회했는데 **행의 개수**가 달라짐.
- A: `SELECT * FROM 직원 WHERE 부서 = 'SALES';` → 10행
- B: 그 사이에 SALES에 직원 추가 `INSERT`.
- A: 다시 같은 SELECT → 11행 (새 행 = Phantom)

---

## 8-3. 레벨별 발생 가능 문제 요약

| 격리 수준 | Dirty Read | Non-repeatable Read | Phantom Read |
|-----------|-----------|---------------------|-------------|
| Read Uncommitted | 발생 | 발생 | 발생 |
| Read Committed | 미발생 | 발생 | 발생 |
| Repeatable Read | 미발생 | 미발생 | 발생 |
| Serializable | 미발생 | 미발생 | 미발생 |

---

# 📌 9. AUTO COMMIT, Oracle vs SQL Server, DDL의 트랜잭션 포함 여부  

## 9-1. AUTO COMMIT 개념

- DML 실행 후 DB가 **자동으로 COMMIT 할지** 여부.
- `AUTO COMMIT = TRUE`:
  - 각 SQL이 **즉시 커밋** → 매 SQL이 독립 트랜잭션.
- `AUTO COMMIT = FALSE`:
  - 사용자가 `COMMIT`/`ROLLBACK` 호출 전까지 한 덩어리.

---

## 9-2. Oracle vs SQL Server 기본 동작

| 구분 | Oracle | SQL Server (기본) |
|------|--------|--------------------|
| DML | AUTO COMMIT = FALSE (수동 커밋) | AUTO COMMIT = TRUE (자동 커밋) |
| DDL | **항상 자동 COMMIT** | 대부분 자동 COMMIT (하지만 트랜잭션으로 감싸면 롤백 가능) |

특히 Oracle:

- `DML`은 수동 커밋 필요.
- 하지만 `DDL` 실행 시:
  - **DDL 직전까지의 DML도 함께 COMMIT** 된다.
  - DDL 후 `ROLLBACK`을 해도 이전 DML은 되돌아가지 않는다.

예:
```sql
UPDATE PRD SET AMT = 30000 WHERE PRD_ID = 'P0001';
CREATE TABLE TEST_222 (...);  -- 이 시점에 자동 COMMIT
ROLLBACK;                     -- DDL 이후 변경은 롤백, 그러나 UPDATE는 이미 확정
```

결과:

- `AMT = 30000`이 확정.
- `TEST_222` 테이블도 존재.

---

## 9-3. SQL Server에서 `BEGIN TRANSACTION` 활용

SQL Server는 기본적으로 DDL도 자동 커밋이지만,

```sql
BEGIN TRANSACTION;

UPDATE PRD SET AMT = 30000;
CREATE TABLE TEST_222 (...);

ROLLBACK;
```

- 이렇게 **명시적으로 트랜잭션을 시작**하면:
  - UPDATE와 CREATE TABLE 모두 같은 트랜잭션에 묶인다.
  - `ROLLBACK` 시 둘 다 되돌아간다 → `TEST_222` 테이블도 생성되지 않음.

핵심:

- SQL Server에서는 `BEGIN TRANSACTION`을 사용하면 **DDL도 트랜잭션에 포함**되어 ROLLBACK 가능하다.
- Oracle은 그렇지 않다. DDL은 항상 자동 COMMIT.

---

## 9-4. 왜 DDL은 원래 트랜잭션에 포함되지 않도록 설계되었나? (Oracle 관점)

1. **메타데이터(데이터 사전) 일관성**
   - DDL은 테이블/인덱스/스키마 등 **DB 구조**를 바꾼다.
   - 이 정보는 시스템 전반에서 즉시 일관되게 보여야 한다.
   - 구조 변경을 롤백 가능하게 두면 **시스템 카탈로그와 실제 구조 간 불일치** 위험.

2. **성능과 락 문제**
   - DDL을 롤백 가능하게 유지하려면, 메타데이터 변경 내역을 모두 추적해야 한다.
   - 그 동안 데이터 사전에 **강한 락**이 오래 유지될 수 있어 동시성 크게 저하.

3. **트랜잭션 경계**
   - DDL 실행 시점은 “시스템 구조가 바뀌는 지점”이므로,
     - 그 전후로 트랜잭션 경계를 명확히 끊기 위해 **강제 COMMIT**을 한다.

Oracle은 이 철학을 택했고,  
SQL Server는 유연성과 복구 편의성을 위해 **선택적으로 DDL까지 트랜잭션에 포함**할 수 있게 했다.

---

## 9-5. SAVEPOINT와 COMMIT의 관계

- `SAVEPOINT`는 **트랜잭션 내부의 부분 롤백 지점**이다.

예:
```sql
BEGIN TRANSACTION;
UPDATE ...;
SAVEPOINT A;
UPDATE ...;
SAVEPOINT B;
DELETE ...;
-- ROLLBACK TO B;  가능
COMMIT;  -- 여기서 트랜잭션 종료
```

- `COMMIT`은 **트랜잭션 전체를 확정하고 종료**하는 동작.
- 따라서 COMMIT 후에는:
  - 그 트랜잭션과 관련된 모든 `UNDO` 정보, `SAVEPOINT` 메타데이터가 정리된다.
  - 즉, **SAVEPOINT는 모두 사라지고**, 다시 되돌릴 수 있는 지점이 없다.

요약:

- `ROLLBACK TO SAVEPOINT X`:
  - 같은 트랜잭션 내에서 **부분 취소**.
- `COMMIT`:
  - “이 트랜잭션은 완전히 끝났다” → SAVEPOINT 포함 모든 롤백 지점 삭제.

---

# 📌 10. 전체 흐름 요약 

1. 페이징
   - `FETCH FIRST` = `FETCH NEXT`, 문맥상 구분.
   - `WITH TIES`는 `ORDER BY` 필수.

2. NULL과 IN, 3값 논리
   - `10 IN (10, NULL)` → `TRUE` (`TRUE OR UNKNOWN`).
   - `10 IN (NULL)` → `UNKNOWN`, WHERE 조건 불만족.

3. 계층형 쿼리
   - `START WITH`로 루트(LEVEL = 1).
   - `CONNECT BY PRIOR`로 부모-자식 방향 지정.
   - `ORDER SIBLINGS BY`로 형제 정렬.
   - `LEVEL`, `CONNECT_BY_ROOT`, `CONNECT_BY_ISLEAF`, `CONNECT_BY_ISCYCLE`, `SYS_CONNECT_BY_PATH`.

4. PIVOT / UNPIVOT & 따옴표
   - `' '` → 값, `" "` → 컬럼명.
   - UNPIVOT에서 `"2023_매출"`은 컬럼명, `'2023'`은 값.

5. 정규표현식
   - POSIX 메타문자와 문자 클래스 `[[:digit:]]` 등.
   - PERL 단축 표기 `\d`, `\w`, `\s` … 및 비탐욕 수량자 `+?`.
   - `REGEXP_INSTR`의 5번째 인자: `0` 시작 위치, `1` 끝 위치.
   - `REGEXP_SUBSTR('aaabbb', 'a+?b')` → `"ab"`.

6. 기본 함수
   - `REGEXP_LIKE`: 패턴 존재 여부.
   - `COUNT`, `INSTR`, `SUBSTR`, `REPLACE`.

7. MERGE
   - `WHEN MATCHED` → UPDATE.
   - `WHEN NOT MATCHED` → INSERT.

8. 트랜잭션
   - 명시적 vs 묵시적.
   - Isolation Level 4단계와 Dirty / Non-repeatable / Phantom Read.

9. AUTO COMMIT과 DDL
   - Oracle: DML은 수동 커밋, DDL은 실행 시점 자동 커밋(직전 DML까지 함께 확정).
   - SQL Server: 기본은 자동 커밋, 하지만 `BEGIN TRANSACTION` 사용 시 DDL도 롤백 가능.
   - COMMIT 시 SAVEPOINT는 모두 소멸.
