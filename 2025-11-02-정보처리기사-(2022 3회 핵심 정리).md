# 📌 1. SQL 실행 순서와 트랜잭션 기본

## 1-1. SQL 문장은 독립적으로 실행된다
- 예시 쿼리
  ```sql
  SELECT COUNT(학과) FROM 학생;
  DELETE FROM 학생 WHERE 학과 = "bb";
  SELECT COUNT(학번) FROM 성적;
  ```
- 위 세 문장은 **위에서부터 차례로, 각각 따로** 실행된다.
- 첫 번째 `SELECT`는 그 시점의 테이블 상태만 본다.  
  즉, 아래쪽의 `DELETE`가 나중에 실행돼도 **이미 끝난 `SELECT` 결과는 바뀌지 않는다.**
- 핵심 개념: SQL은 기본적으로 “문장 단위(Statement-level)”로 실행된다.

## 1-2. 트랜잭션과 시점
- 하나의 트랜잭션으로 묶을 수는 있다:
  ```sql
  BEGIN;
  SELECT COUNT(학과) FROM 학생;
  DELETE FROM 학생 WHERE 학과 = "bb";
  COMMIT;
  ```
- 그래도 **`SELECT`는 실행된 순간의 스냅샷**만 가져오기 때문에,  
  뒤에 온 `DELETE`가 **앞의 `SELECT` 결과를 되돌려 바꾸지는 못한다.**
- 트랜잭션은 “이 변경 내용을 묶어서 반영할지($COMMIT$), 되돌릴지($ROLLBACK$)”를 결정하는 장치이지,  
  **이미 실행되어 클라이언트로 반환된 SELECT 결과를 과거로 돌리는 도구가 아니다.**

## 1-3. 정리 포인트
- “위에 있는 SELECT 결과는 그냥 그걸로 끝 아니야?” → 맞다.
- 이유: SQL은 **순차 실행 + 시점 합의** 모델이다.
- 예외가 생기는 경우는 동시성·격리수준(Isolation Level)이 다른 세션과 엮일 때인데,  
  지금처럼 한 세션에서 순서대로 실행하는 상황에서는 **그대로 이해하면 된다.**

---

# 📌 2. 블랙박스 테스트 기법 정리

## 2-1. 블랙박스 테스트 개념
- 내부 코드나 로직을 보지 않고, **입력 → 출력**만으로 기능이 요구사항대로 동작하는지 확인하는 테스트.
- 초점은 “무엇을 하는가(What)”이지 “어떻게 하는가(How)”가 아니다.
- 시험 포인트: 화이트박스 테스트는 제어구조·경로·조건 커버리지, 블랙박스는 기능·입력범위.

## 2-2. 주요 기법 목록
1. **동등 분할 기법(Equivalence Partitioning)**
   - 입력값을 **의미가 같은 집합**으로 나누고 그 안에서 대표값만 테스트.
   - 예: 점수 0~100 → 0 미만(무효), 0~100(유효), 100 초과(무효).
   - 테스트 케이스 수를 줄이면서 커버리지를 확보하는 기법.

2. **경계값 분석(Boundary Value Analysis)**
   - 오류는 경계에서 잘 난다.
   - 최소값/최대값/경계 전후 값을 집중적으로 테스트.
   - 예: 0~100 → -1, 0, 1, 99, 100, 101.

3. **결정 테이블 테스트(Decision Table Testing)**
   - 조건이 여러 개일 때 **조건 조합 전체를 표로 표현**해 누락 없이 테스트.
   - “조건+행동”이 표로 나오면 이 기법이라고 보면 된다.

4. **상태 전이 테스트(State Transition Testing)**
   - 현재 상태 + 입력 → 다음 상태 로 변하는 시스템을 테스트.
   - 로그인 상태, 세션 상태, 자동판매기처럼 “이전 상태에 따라 결과가 달라지는” 시스템에서 사용.

5. **원인-결과 그래프(Cause-Effect Graphing)**
   - 입력 조건(원인)과 결과(효과)의 **논리적 관계를 그래프로 표현**하고,  
     이것을 다시 결정테이블로 바꿔 테스트 케이스를 뽑는 기법.
   - 논리식 기반, 복잡한 조건일 때 사용.

6. **오류 추정(Error Guessing)**
   - 테스트 설계자의 경험으로 “여기서 사람들 잘 틀리더라” 하는 부분을 찍어 테스트.
   - 공식성은 약하지만 실제론 잘 잡힌다.

## 2-3. 한눈에 보는 표

| 기법 | 핵심 포인트 | 언제 쓰나 |
|------|-------------|-----------|
| 동등 분할 | 입력을 유효/무효 집합으로 나눠 대표값만 테스트 | 범위가 넓을 때 |
| 경계값 분석 | 경계 근처가 위험하다 | 최소/최대가 있는 입력 |
| 결정 테이블 | 조건 조합을 빠짐없이 | 복잡한 규칙·비즈니스 로직 |
| 상태 전이 | 상태에 따라 다르게 동작 | 워크플로, 세션, UI 단계 |
| 원인-결과 그래프 | 조건→결과 논리식 | 조건이 많고 상호 의존할 때 |
| 오류 추정 | 경험으로 찍는다 | 예외, 특수 케이스 |

---

# 📌 3. UML 다이어그램 분류

## 3-1. UML의 큰 분류
UML 다이어그램은 보통 다음 세 덩어리로 나눈다.

1. **구조 다이어그램(Structural Diagram)**  
   - 시스템의 “뼈대”, 즉 정적인 요소를 표현한다.
2. **행위 다이어그램(Behavioral Diagram)**  
   - 시스템이 시간에 따라 어떻게 **동작**하는지 표현한다.
3. **상호작용 다이어그램(Interaction Diagram)**  
   - 객체들 사이에서 **메시지가 오가는 흐름**을 표현한다.  
   - 사실 이건 행위 다이어그램의 하위로 취급되기도 한다.

## 3-2. 문제에서 나온 다이어그램 배치

| UML 분류 | 다이어그램 | 설명 |
|----------|------------|------|
| 구조 다이어그램 | 클래스 다이어그램(Class Diagram) | 클래스, 속성, 연관, 상속 같은 **정적 구조** 표현 |
| 구조 다이어그램 | 객체 다이어그램(Object Diagram) | 클래스 다이어그램의 **그 시점 인스턴스 상태** 표현 |
| 구조 다이어그램 | 컴포넌트 다이어그램(Component Diagram) | 시스템을 구성하는 모듈/컴포넌트 간 의존성 표현 |
| 행위 다이어그램 | 유스케이스 다이어그램(Use Case Diagram) | 액터(사용자)와 시스템 기능의 관계 표현, 요구분석 단계 |
| 행위 다이어그램 | 상태 다이어그램(State Diagram) | 객체가 사건/이벤트에 의해 상태가 어떻게 바뀌는지 표현 |
| 행위 다이어그램 | 활동 다이어그램(Activity Diagram) | 업무 흐름, 분기, 병행을 표현하는 절차도 |
| 상호작용 다이어그램 | 시퀀스 다이어그램(Sequence Diagram) | 시간 흐름에 따라 객체 간 메시지 호출 순서를 표현 |

## 3-3. 헷갈리는 포인트
- 클래스 vs 객체:
  - 클래스 다이어그램: “설계도”  
  - 객체 다이어그램: “그 설계도가 실제로 메모리에 올라간 순간”
- 상태 다이어그램 vs 활동 다이어그램:
  - 상태: “이 객체가 어떤 상태에 있느냐”  
  - 활동: “이 프로세스가 어떤 흐름으로 일을 처리하느냐”

---

# 📌 4. 보안 관련 개념

## 4-1. SIEM (Security Information and Event Management)
- 각종 보안장비(방화벽, IDS/IPS, 서버, DB 등)에서 나오는 **로그와 이벤트를 중앙에서 수집·분석**하는 시스템.
- 기능: 실시간 모니터링, 이상행위 탐지, 경보 발생, 감사 리포트.
- 포인트: “로그 통합”, “보안관제”, “이상징후 탐지”가 뜨면 SIEM.

## 4-2. SSO (Single Sign-On)
- **한 번 로그인하면 여러 시스템을 추가 로그인 없이 쓸 수 있게 하는 방식.**
- 인증 서버(IdP)가 중심이 되어 사용자 인증 상태를 여러 서비스에 전달.
- 장점: 사용자 편의성↑, 계정 관리 중앙화.  
  단점: 인증 서버가 뚫리면 전체 서비스가 한꺼번에 위험해짐.

## 4-3. Trust Zone
- 네트워크를 **신뢰도에 따라 구역으로 나누는 설계 개념.**
- 보통
  - 외부망(비신뢰, untrusted)
  - DMZ(완충지대)
  - 내부망(신뢰구역, trusted)
  로 구분.
- 목적: 접근 통제, 침입 차단, 중요 자산을 덜 노출시키기.

## 4-4. 타이포스쿼팅(Typosquatting)
- 사용자가 **정상 도메인을 오타로 칠 때**를 노려 비슷한 도메인을 미리 등록해두는 공격.
- 예: `google.com` → `gooogle.com`, `goggle.com`, `goog1e.com`
- 목적: 피싱, 악성코드 유포, 광고수익, 계정 탈취.
- 포인트: “정상과 유사한 도메인으로 속이는 공격” → 타이포스쿼팅.

---

# 📌 5. 형상관리 도구의 관리방식 비교

## 5-1. 관리방식 3대 분류
형상관리는 버전관리 도구를 **어떻게 공유하고 어디에 저장하느냐**에 따라 아래 3가지로 많이 나뉜다.

1. 공유폴더 방식
2. 클라이언트/서버($C/S$) 방식
3. 분산저장소 방식

## 5-2. 비교 표

| 관리 방식 | 예시 도구 | 구조/동작 | 장점 | 단점 | 포인트 |
|-----------|-----------|-----------|------|------|--------|
| 공유폴더 방식 | RCS, SCCS | 중앙 서버 없이 **공유 디렉토리**에 파일을 두고 잠금(lock)으로 버전 관리 | 간단, 추가 인프라 거의 없음 | 동시 작업 어려움, 협업 약함 | “공유 디렉토리 기반”이면 이거 |
| 클라이언트/서버 방식 | CVS, **SVN**, ClearCase | 중앙 저장소(Repository)에 모두 저장해두고 클라이언트가 체크아웃/체크인 | 중앙 집중 관리, 백업·권한관리 용이 | 서버 죽으면 전체 작업 중단, 오프라인 불가 | “중앙 저장소 필요” → C/S |
| 분산저장소 방식 | **Git**, Mercurial, Bazaar | 각 클라이언트가 저장소 전체를 **클론**해서 로컬에서도 커밋 가능. 중앙 서버는 협업용 | 오프라인에서도 작업 가능, 속도 빠름, 분산 백업 | 병합 충돌 가능성↑, 중앙 통제 약함 | “로컬에 전체 이력 보유”, “Git” |

## 5-3. 기억 포인트
- Git은 **무조건** “분산저장소 방식”이다.  
  (시험에서 “클라이언트/서버형에 해당하는 것은?” 하고 Git 넣어놓는 건 오답 유도용)
- SVN은 **중앙 집중형(C/S)** 이다.
- 공유폴더형은 이제 실무에서는 거의 안 쓰지만, 시험에서는 “파일 잠금 방식”으로 언급된다.

---
