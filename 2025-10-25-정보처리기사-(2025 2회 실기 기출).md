# 📌 1. 타겟 타이핑과 SAM 변환(Single Abstract Method Conversion)

## 1-1. 핵심 개념 요약

람다식은 **함수형 인터페이스(Functional Interface)** — 즉, **추상 메서드가 하나뿐인 인터페이스**를 간단히 구현하기 위한 문법이다.  
컴파일러는 **타겟 타이핑(Target Typing)** 을 통해 문맥에서 인터페이스 타입을 추론하고,  
이를 **SAM 변환(Single Abstract Method Conversion)** 을 통해 실제 익명 객체로 변환한다.

---

## 1-2. 코드 예제

```java
interface F {
    int app(int n) throws Exception;
}

public class Main {
    public static int run(F f) {
        try {
            return f.app(3);
        } catch (Exception e) {
            return 7;
        }
    }

    public static void main(String[] args) {
        // 람다식으로 인터페이스 구현
        F f = (x) -> {
            if (x > 2) {
                throw new Exception();
            } else {
                return x * 2;
            }
        };

        // 두 번째 람다는 문맥에서 F로 추론됨 (타겟 타이핑)
        System.out.println(run(f) + run(n -> n + 9));
    }
}
```

---

## 1-3. 코드 동작 과정

1. **`interface F` 정의**

   ```java
   interface F {
       int app(int n) throws Exception;
   }
   ```
   - `app(int n)` 하나뿐이므로 함수형 인터페이스.
   - 람다식은 `app(int)`를 구현하는 형태로 자동 매핑된다.

2. **람다식으로 인터페이스 구현**

   ```java
   F f = (x) -> {
       if (x > 2) throw new Exception();
       else return x * 2;
   };
   ```
   실제로는 다음 코드와 같다:
   ```java
   F f = new F() {
       public int app(int x) throws Exception {
           if (x > 2) throw new Exception();
           else return x * 2;
       }
   };
   ```

3. **타겟 타이핑(Target Typing)**

   ```java
   run(n -> n + 9);
   ```
   - `run`의 매개변수 타입이 `F`이므로,  
     `n -> n + 9`는 자동으로 `F`의 구현체로 변환된다.
   - 즉, 아래와 동일한 코드:
     ```java
     run((F)(n -> n + 9));
     ```

4. **SAM 변환(Single Abstract Method Conversion)**  
   - 컴파일러가 `F`의 추상 메서드(`app`)을 구현하는 익명 객체를 생성한다.
   - 이 과정이 “람다가 인터페이스를 구현한다”의 실체이다.

---

## 1-4. 실행 결과

```text
19
```

- `run(f)` → `f.app(3)` 호출 시 `x=3`, `Exception` 발생 → `catch`로 가서 `7` 반환  
- `run(n -> n + 9)` → `app(3)` 실행 → `12` 반환  
- 최종 출력: `7 + 12 = 19`

---

## 1-5. 개념 비교 요약

| 개념 | 설명 | 예시 |
|------|------|------|
| **함수형 인터페이스** | 추상 메서드가 하나뿐인 인터페이스 | `Runnable`, `Callable`, `Comparator`, `F` |
| **SAM 변환** | 함수형 인터페이스를 람다로 구현하는 과정 | `(x) -> x + 1` |
| **타겟 타이핑** | 람다의 타입을 문맥에서 추론하는 과정 | `run(n -> n + 9)` 에서 `F`로 자동 추론 |

---

## 1-6. 비유로 이해하기

| 개념 | 비유 |
|------|------|
| 타겟 타이핑 | 대화 흐름으로 "누가 말하는지" 자동으로 알아차리는 것 |
| SAM 변환 | “한 가지 약속만 지키면 바로 계약 체결이 가능한 계약서” |

---

## 1-7. 핵심 정리 

람다식은 “타겟 타입이 함수형 인터페이스인 문맥”에서  
해당 인터페이스의 **추상 메서드를 구현하는 익명 객체**로 변환된다.  
즉, `n -> n + 9` 자체는 타입이 없지만, `run` 메서드의 파라미터가 `F`이기 때문에  
컴파일러가 **자동으로 `F`로 캐스팅**하여 실행시킬 수 있다.

<br>
<br>
<br>

# 📌 2. C언어 구조체 포인터와 `->` 연산자

## 2-1. 기본 개념

구조체 포인터는 **구조체 변수를 가리키는 포인터**이다.  
`->` 연산자는 “포인터가 가리키는 구조체 내부의 멤버”에 접근할 때 사용한다.  
즉, 다음 두 표현은 완전히 동일하다.

```c
(*p).멤버명  ≡  p->멤버명
```

---

## 2-2. 예시 코드

```c
#include <stdio.h>

struct Person {
    int age;
    double height;
};

int main() {
    struct Person a = {25, 178.5};
    struct Person *p = &a;

    printf("%d\n", (*p).age);  // 괄호 필수
    printf("%d\n", p->age);    // 더 간단한 표현
}
```

### 실행 결과

```
25
25
```

두 줄 모두 동일한 결과를 출력한다.

---

## 2-3. 동작 원리

1. `p`는 구조체 변수 `a`의 주소를 저장한 **포인터**이다.  
2. `*p`는 “포인터 p가 가리키는 구조체 a 자체”를 의미한다.  
3. `(*p).age`는 “구조체 a의 age 멤버”에 접근하는 표현이다.  
4. `p->age`는 이를 간단히 줄인 **축약형 문법**이다.

---

## 2-4. 메모리 관점에서의 관계

```c
struct Point {
    int x, y;
};

struct Point pt = {3, 7};
struct Point *p = &pt;
```

| 표현 | 의미 | 값 |
|------|------|----|
| `pt.x` | 구조체 변수의 멤버 | 3 |
| `p` | 구조체 pt의 주소 | (주소값) |
| `*p` | pt 구조체 자체 | {3, 7} |
| `p->x` | pt.x 와 동일 | 3 |
| `(*p).x` | pt.x 와 동일 | 3 |

---

## 2-5. 구조체 안에 또 다른 구조체가 있을 때

```c
struct Inner {
    int num;
};

struct Outer {
    struct Inner inner;
};

struct Outer o = {{10}};
struct Outer *p = &o;

printf("%d\n", p->inner.num);
```

- `p`가 `Outer`를 가리키고,  
- `p->inner`는 내부 구조체 `Inner`를 의미하며,  
- `p->inner.num`은 `o.inner.num`과 동일하게 동작한다.

---

## 2-6. 정리 문장

- `p->member` 는 `(*p).member` 의 축약형이다.  
- `->` 는 **“구조체 포인터를 통해 구조체 내부 멤버에 접근한다”**는 의미다.  
- 구조체 안에 구조체가 있어도 `p->inner.member` 형태로 단계적으로 접근할 수 있다.

<br>
<br>
<br>

# 📌 3. 구조체의 크기 결정 원리와 정렬(Alignment) 규칙

## 3-1. 기본 원리: 단순 합이 아닌 ‘정렬 규칙’

`sizeof(struct T)`는 멤버들의 단순한 크기 합이 아니다.  
CPU가 데이터를 빠르게 접근하기 위해 **정렬(alignment)** 규칙을 강제하기 때문에,  
중간에 **패딩(padding)** 이 삽입되어 구조체 크기가 커질 수 있다.

---

## 3-2. 정렬과 패딩의 개념

- **정렬 단위 (alignment):**  
  자료형이 메모리에 배치될 때 반드시 특정 배수 주소에서 시작해야 함.  
  예: `int`는 4의 배수 주소, `double`은 8의 배수 주소.

- **패딩 (padding):**  
  다음 멤버가 자신의 정렬 기준을 맞추기 위해 삽입되는 빈 공간.

- **구조체 전체의 정렬 단위:**  
  내부 멤버 중 **가장 큰 정렬 단위**를 따라간다.

---

## 3-3. 예제 A: 기본적인 구조체

```c
struct Point {
    int x;
    int y;
};
```

| 멤버 | 크기 | 정렬 기준 | 패딩 | 시작 주소 (예시) |
|------|------|------------|------|------------------|
| x | 4 | 4 | 없음 | 0 |
| y | 4 | 4 | 없음 | 4 |

가장 큰 정렬 기준은 4바이트이고, 이미 8이 4의 배수이므로 꼬리 패딩 없음.  
👉 `sizeof(struct Point) == 8`

---

## 3-4. 예제 B: 패딩이 생기는 구조체

```c
struct S {
    char c;
    int i;
};
```

| 멤버 | 크기 | 정렬 기준 | 패딩 | 시작 주소 (예시) |
|------|------|------------|------|------------------|
| c | 1 | 1 | 내부 패딩 3 | 0 |
| i | 4 | 4 | 없음 | 4 |

가장 큰 정렬 기준 = 4바이트 → 전체 크기 8바이트.  
👉 `sizeof(struct S) == 8`

---

## 3-5. 예제 C: 더 복잡한 정렬

```c
struct T {
    char c;
    double d;
    char e;
};
```

| 멤버 | 크기 | 정렬 기준 | 패딩 | 시작 주소 (예시) |
|------|------|------------|------|------------------|
| c | 1 | 1 | 내부 패딩 7 | 0 |
| d | 8 | 8 | 없음 | 8 |
| e | 1 | 1 | 꼬리 패딩 7 | 16 |

👉 `sizeof(struct T) == 24`

---

## 3-6. 구조체 배열과 꼬리 패딩의 이유

```c
struct T arr[3];
```

각 원소가 `sizeof(struct T)` 간격으로 배치되므로,  
꼬리 패딩이 있어야 다음 원소가 올바른 정렬 기준(예: 8의 배수)에서 시작할 수 있다.

---

## 3-7. 멤버 순서에 따른 크기 차이

```c
struct Bad { char c; double d; char e; };   // 24바이트
struct Good { double d; char c; char e; };  // 16바이트
```

큰 정렬 단위를 요구하는 멤버를 **앞쪽에 배치**하면 내부 패딩이 줄어들어 전체 크기가 작아진다.

---

## 3-8. 구조체 복사 시 주의점

```c
(*pp)[1] = (*pp)[2];
```

이 문장은 구조체 전체를 통째로 복사한다.  
이때 내부의 **패딩 바이트까지 함께 복사**된다.  
즉, 구조체의 복사는 사실상 `memcpy(sizeof(struct T))`와 같다.

---

## 3-9. 플랫폼별 차이 (LP64 vs LLP64)

| 환경 | long | pointer | 정렬 특성 |
|------|-------|----------|-----------|
| Linux/macOS (LP64) | 8 | 8 | 대부분 8바이트 정렬 |
| Windows (LLP64) | 4 | 8 | 일부 타입 정렬 다름 |

따라서 “int 2개니까 8바이트짜리 구조체”라는 문장은  
대부분의 시스템에서 맞지만, 정확한 크기는 항상 `sizeof(struct T)`로 확인해야 한다.

---

## 3-10. 핵심 정리

- 구조체 크기 = 멤버 크기 합 + 내부 패딩 + 꼬리 패딩  
- 구조체 정렬 = 가장 큰 멤버의 정렬 단위  
- `sizeof(struct T)`는 정렬 단위의 배수  
- 배열 원소 간 간격 = `sizeof(struct T)`  
- 멤버 순서가 크기 효율에 큰 영향을 준다.

---

# 📌 4. 관계대수

## 4-1. 관계대수의 개념

| 특징              | 설명                           |
| --------------- | ---------------------------- |
| **절차적 언어**      | “무엇을”이 아니라 “어떻게 얻을지” 기술      |
| **수학적 기반**      | 집합이론 기반, 튜플은 중복 없음           |
| **SQL의 이론적 뿌리** | SQL 쿼리는 내부적으로 관계대수 연산으로 변환됨  |
| **결과도 릴레이션**    | 연산의 결과 역시 테이블 형태이므로 연속 연산 가능 |


## 4-2. 기본 관계대수 연산

| 분류               | 연산자                | 의미                         |
| ---------------- | ------------------ | -------------------------- |
| 선택(Selection)    | σ<sub>조건</sub>(R)  | 조건에 맞는 행(튜플)만 선택           |
| 프로젝션(Projection) | π<sub>속성</sub>(R)  | 특정 열(속성)만 추출               |
| 집합 연산            | ∪, ∩, −            | 합집합, 교집합, 차집합 (스키마 동일해야 함) |
| 카티션 프로덕트         | R × S              | 두 릴레이션의 모든 조합 (디카르트곱)      |
| rename           | ρ<sub>새이름</sub>(R) | 릴레이션이나 속성 이름 변경            |
| 조인(Join)         | R ⋈<sub>조건</sub> S | 두 릴레이션을 공통 속성 기준으로 결합      |
| division         | R ÷ S              | R에서 S의 모든 속성과 매칭되는 튜플 찾기   |

---

## 4-3. 복합 사용 예시
- R과 S를 Dept 기준으로 join하고 그 테이블에서 location이 seoul인 행들만 모은 뒤에 그 행들에서 name 열만 출력
```pgsql
πName(σLocation='Seoul'(R ⋈Dept=S))
```

# 📌 5. 운영체제 스케줄링

## 5-1. FCFS (First Come, First Serve)

### 원리
- 말 그대로 **먼저 온 순서대로 처리**하는 큐 방식.  
- 프로세스가 도착한 순서대로 실행 → **CPU 점유권을 양보하지 않음 (비선점형)**.

### 내부 동작
- 큐에 먼저 들어온 순서대로 꺼냄 (**FIFO Queue**).  
- 현재 실행 중인 프로세스가 끝날 때까지 다른 프로세스는 대기.

### 장점
- 구현 간단, 처리 순서가 공정해 보임.  
- “배타적 자원”의 **예약형 서비스**에 유리함.

### 단점
- **Convoy Effect(호위 효과)** 발생  
  → 긴 작업 하나 때문에 뒤의 짧은 작업들이 오래 기다림.  
  → CPU 유휴시간 증가, 평균 대기시간 악화.

---

## 5-2. SJF (Shortest Job First)

### 원리
- **실행 시간이 가장 짧은 프로세스**를 먼저 실행.  
- 평균 대기시간을 최소화한다는 점에서 **이론적으로 최적의 스케줄링**.  
- 단, 프로세스의 실행 시간을 **미리 알아야** 한다는 가정이 비현실적.

### 종류
- **비선점형 SJF:** 현재 실행 중인 프로세스가 끝날 때까지 새 프로세스가 와도 기다림.  
- **선점형 SJF(SRTF):** 새 프로세스가 더 짧으면 현재 프로세스를 중단하고 교체.

### 특징
- CPU 버스트(작업 시간)의 분포가 예측 가능할 때 효율적.  
- 짧은 작업에 유리, 긴 작업은 계속 밀려 **Starvation(기아)** 발생.

---

## 5-3. HRN (Highest Response-Ratio Next)

### 원리
- SJF의 기아 문제를 해결하기 위해 **대기시간을 가중치로 고려**.  
- **우선순위 계산식:**  
  $$
  Response\ Ratio = \frac{(대기시간 + 서비스시간)}{서비스시간}
  $$  
- 오래 기다린 프로세스는 실행 시간이 길더라도 점점 점수가 높아져 **언젠가는 실행**된다.

### 특징
- **비선점형** 스케줄링.  
- 짧은 작업은 빠르게, 오래 기다린 작업은 점점 가중치를 얻어 공정성 확보.  
- 실제 시스템보다는 **이론적 완화 모델**로 자주 다뤄짐.

---

## 5-4. RR (Round Robin)

### 원리
- **모든 프로세스에게 CPU를 공평하게 분배.**  
- 각 프로세스는 일정 시간(q, 타임 퀀텀) 동안만 CPU 사용 → 끝나지 않으면 큐 뒤로 이동.  
- **선점형 스케줄링**의 대표 사례.

### 내부 동작
1. 준비 큐에서 첫 번째 프로세스 실행  
2. 타임 퀀텀만큼 실행 후 타이머 인터럽트 발생  
3. 끝나지 않으면 큐 맨 뒤로 보내고 다음 프로세스 실행
4. 만약 할당량보다 작업을 빨리 끝내면 즉시 종료되고 다음으로 넘어감

### 장점
- **공평함**, **응답 시간이 짧음** (인터랙티브 환경에 유리).  
- 사용자 체감 속도가 좋음.

### 단점
- 타임 퀀텀이 너무 짧으면 → **문맥교환(Context Switch)** 오버헤드 증가.  
- 너무 크면 → **FCFS와 비슷**해져 응답성 떨어짐.

---

## 5-5. SRT (Shortest Remaining Time First)

### 원리
- SJF의 **선점형 버전**.  
- 현재 **남은 실행시간**과 새로 도착한 프로세스의 **실행시간**을 비교해서 더 짧은 쪽에 CPU를 할당.

#### 예시
현재 실행 중: 남은 시간 5ms
새로 도착: 실행 시간 2ms
→ 선점 발생 (새 프로세스 실행)

### 특징
- **평균 대기시간 최소화** 측면에서 가장 효율적.  
- 실시간 시스템엔 적합하지 않음(예측 불가성).  
- 실행시간 추정은 과거 실행시간의 **이동평균(Exponential Averaging)**으로 근사.

---

## 5-6. 비교 요약

| 알고리즘 | 선점 여부 | 핵심 기준 | 장점 | 단점 |
|-----------|------------|-------------|--------|--------|
| **FCFS** | 비선점 | 도착 순서 | 단순, 공정 | 긴 작업 → Convoy effect |
| **SJF** | 비선점 | CPU 버스트 시간 | 평균 대기시간 최소 | 실행시간 예측 필요, 기아 발생 |
| **HRN** | 비선점 | 응답 비율 | 공정성 향상 | 계산 복잡 |
| **RR** | 선점 | 시간 할당량 | 응답성 높음 | 문맥교환 오버헤드 |
| **SRT(SJF 선점형)** | 선점 | 남은 실행시간 | 효율 최고 | 기아 가능, 예측 어려움 |


# 📌 6. 플로우차트/알고리즘 경로 분석 (핵심 정리)

## 6-1. 읽는 법
- 다이아몬드: 조건 분기(YES/NO)
- 화살표: 제어 흐름
- 루프 백엣지: 반복 구조

## 6-2. 경로 표기법
- 분기와 루프를 따라 가능한 **유효 경로**를 나열(예: 1→2→3→... 또는 1→2→4→5→6→→1 등).
- 종료 지점(출력/PRINT)에 도달하는 경로들을 특히 명시.

## 6-3. 실전 팁
- 조건문과 루프의 YES/NO 두 갈래를 모두 고려해 경로 생성.
- 경로 수가 많으면 상태-전이 표(transition table)로 정리하면 실수 줄어듦.

---

# 📌 7. 보안 공격 유형 정리

---

## 🧨 1️⃣ 서비스 거부 공격 (DoS, Denial of Service)
> 목표: **서버나 네트워크를 과부하시켜 정상적인 서비스 불가 상태로 만드는 것.**

### (1) Ping of Death
- **매우 큰 패킷(>65,535byte)** 을 전송해 네트워크 스택을 마비시킴.
- 오래된 시스템은 이 비정상적인 크기를 처리하지 못해 **다운**됨.

### (2) SMURF 공격
- ICMP(Echo Request) 브로드캐스트를 이용.
- 공격자는 **출발지 IP를 피해자의 IP로 위조**하여 다수의 호스트로 전송.
- 결과적으로 **피해자에게 수많은 응답(Echo Reply)** 이 몰림 → 과부하 발생.

### (3) Land Attack
- 패킷의 **송신 IP와 수신 IP를 동일하게 위조**.
- 즉, 자기 자신에게 무한히 요청을 보내도록 만들어 시스템 리소스 고갈.

### (4) SYN Flooding
- TCP 3-way Handshake를 악용.  
  클라이언트가 **SYN 요청만 보내고 ACK를 안 보냄**.
- 서버는 연결 대기 상태로 리소스를 계속 점유 → 결국 **연결 대기 큐가 가득 차 마비**됨.

---

## 🕵️‍♂️ 2️⃣ 정보 보안 침해 공격
> 목표: **데이터를 탈취하거나, 시스템 접근 권한을 얻거나, 사용자 행위를 속이는 것.**

### (1) 세션 하이재킹 (Session Hijacking)
- 이미 인증된 **세션 토큰을 가로채** 사용자의 권한을 탈취.
- 예: 로그인된 쿠키를 중간에서 훔쳐서 해당 사용자로 가장.

### (2) ARP 스푸핑
- **MAC 주소를 변조**해 공격자의 장치를 중간자로 끼워넣음.
- 결과적으로 트래픽을 가로채거나 조작할 수 있음.

### (3) 사회 공학 (Social Engineering)
- 기술이 아닌 **인간 심리를 이용한 공격**.  
  예: “보안팀입니다. 비밀번호 알려주세요.”처럼 신뢰를 이용.

### (4) 타이포스쿼팅 (Typosquatting)
- 유명 도메인과 유사한 철자(예: gooogle.com)를 등록해  
  사용자의 실수를 이용한 피싱 사이트 유도.

### (5) 스니핑 (Sniffing)
- 네트워크 상의 **패킷을 도청**하여 ID, 비밀번호 등 민감 정보 탈취.
- 예: HTTP 트래픽 감청, Wi-Fi 패킷 캡처 등.

### (6) 워터링 홀 공격 (Watering Hole Attack)
- 사용자가 자주 방문하는 **정상 웹사이트를 해킹**하여 감염 코드 삽입.
- 방문자들이 악성코드에 자동 감염됨.

### (7) 키로거 공격 (Keylogger Attack)
- 키보드 입력을 기록하여 비밀번호, 카드정보 등 탈취.

### (8) 랜섬웨어 (Ransomware)
- **문서·파일을 암호화**하여 접근 불가 상태로 만들고 금전 요구.

### (9) 백도어 (Backdoor)
- 시스템 설계자나 해커가 몰래 심어놓은 **비인가 접근 통로**.
- 보안을 우회해 내부 접근 가능.

### (10) 웜 (Worm)
- 자기 복제 기능을 통해 네트워크를 타고 확산.
- 실행파일 감염 없이 시스템 자원을 소모시킴.

---

## 💾 3️⃣ 다크 데이터 (Dark Data)
- 기업이나 기관이 **수집했지만 활용되지 않은 데이터**.
- 저장만 되어 있고 분석이나 의사결정에 쓰이지 않음.
- 방치 시 보안 위험 증가 (예: 개인정보 유출 가능성).

---

## 🧠 요약 비교표

| 공격명 | 핵심 원리 | 피해 형태 |
|--------|------------|------------|
| Ping of Death | 비정상적 대용량 패킷 | 네트워크 마비 |
| SMURF | IP 위조 + 브로드캐스트 | 특정 서버 과부하 |
| Land Attack | 송수신 IP 동일 위조 | 자기 자신 공격 |
| SYN Flooding | 연결 요청만 반복 | 서버 대기 큐 마비 |
| 세션 하이재킹 | 세션 탈취 | 인증 우회 |
| ARP 스푸핑 | MAC 위조 | 트래픽 가로채기 |
| 사회 공학 | 인간 심리 이용 | 정보 유출 |
| 타이포스쿼팅 | 유사 도메인 등록 | 피싱 유도 |
| 스니핑 | 패킷 도청 | 계정 정보 탈취 |
| 워터링 홀 | 신뢰 사이트 감염 | 대량 감염 |
| 키로거 | 키보드 입력 수집 | 비밀번호 유출 |
| 랜섬웨어 | 파일 암호화 | 금전 요구 |
| 백도어 | 비인가 통로 | 내부 침입 |
| 웜 | 자기 복제 | 시스템 부하 |
| 다크 데이터 | 미활용 데이터 | 보안 리스크 |

---


# 📌 8. Java 메서드 디스패치 — 인스턴스 vs static 

## 8-1. 원칙
- **인스턴스 메서드**: 가상 호출(virtual) — 런타임에 실제 객체 타입으로 결정(오버라이딩 적용).
- **static 메서드**: 클래스에 귀속 — 컴파일타임에 참조변수의 **정적 타입**으로 결정(‘hiding’).

## 8-2. 결과 예시
- `Parent ref = new Child(); ref.x(2)` → `Child.x(int)` 실행(동적 바인딩).
- `ref.id()` (static) → `Parent.id()` 실행(정적 바인딩).

## 8-3. 팁
- static 메서드는 **클래스명으로 호출**하는 습관을 들이면 혼동 방지.
- 오버로딩(시그니처 기반)은 컴파일타임 결정, 오버라이딩은 런타임 결정.

---

# 📌 9. C — putchar와 연결 리스트(역순 생성)

## 9-1. putchar
- `int putchar(int ch)`는 문자 하나를 stdout으로 출력(버퍼링 포함).
- `putchar('A')`는 `A` 출력.

## 9-2. 역순 리스트 생성 패턴
- 루프에서 새 노드를 만들고 새 노드의 `next`를 현재 머리로 연결 → `head = new`.
- 입력 문자열 "BEST"로 머리삽입하면 리스트는 `T -> S -> E -> B`.

## 9-3. 메모리와 해제
- `malloc`으로 할당한 노드는 사용 후 `free`로 해제해야 메모리 누수 방지.
- 출력하면서 즉시 해제하면 메모리 관리가 간단해짐.

# 📌 10. ip와 icmp
- 프로토콜 = 통신 주체들(프로세스/호스트/장비) 사이에 메시지를 주고받는 방법을 엄격하게 규정한 규칙과 약속의 집합

| 항목      | IP                          | ICMP                      |
| ------- | --------------------------- | ------------------------- |
| 역할      | 패킷 전달(주소·라우팅·프래그먼트)         | 네트워크 오류·진단 메시지 전달         |
| 계층      | 네트워크 계층                     | IP 위에서 동작(네트워크 제어)        |
| 메시지     | 데이터그램(페이로드에 TCP/UDP/ICMP 등) | 제어/오류 메시지(패킷 내부에 포함되어 전달) |
| 프로토콜 번호 | —                           | IP 프로토콜 1 (ICMP)          |

# 11. OSI 7 계층
> 모든 통신을 단계별로 분리하고, 각 단계의 기능과 규칙(프로토콜)을 통일하자!

## 11-1. 핵심철학 - 계층화
- 각 계층은 “자기 바로 위 계층에게 서비스 제공자(provider)”, 그리고 “자기 바로 아래 계층의 사용자(user)” 가 되는 구조.

| 계층    | 목적            | 예시              |
| ----- | ------------- | --------------- |
| 하위 계층 | 데이터의 ‘전달’을 책임 | 물리선, 전송 경로, 주소  |
| 상위 계층 | 데이터의 ‘의미’를 책임 | 메시지, 세션, 표현, 응용 |

- 예를 들면 아래와 같음

| 계층                | 역할                                     | 비유                 |
| ----------------- | -------------------------------------- | ------------------ |
| **3계층 (IP)**      | “패킷을 어디로 보내야 할지” 결정 — 주소 지정, 라우팅       | **도로 지도**          |
| **4계층 (TCP/UDP)** | “그 도로를 따라 데이터를 어떻게 운반할지” — 순서, 흐름, 신뢰성 | **운송 규칙(택배사 매뉴얼)** |

- 구체적으로보면
1. TCP는 세그먼트(segment) 를 만들고, 여기에 순서번호(seq), 확인응답(ACK), 포트번호 등을 붙임.

2. TCP는 “이걸 상대방 호스트까지 보내줘”라고 3계층(IP)에 요청함.
→ 즉, TCP는 경로를 몰라. 목적지 IP만 알려주고 “이 IP로 보내줘!”라고 부탁함.

3. IP는 라우팅 테이블을 보고 “다음 홉(Next Hop)”을 찾아서 패킷을 보냄.

4. 중간 라우터들은 “이건 4계층 TCP 데이터가 들어있는 3계층 패킷이구나”라고 헤더를 보고 처리함.


---

## 🟣 7️⃣ 응용 계층 (Application Layer)

### 1️⃣ HTTP / HTTPS
- **HTTP (HyperText Transfer Protocol)**  
  : 웹 브라우저와 서버 간의 통신 규칙.  
  - 동작 방식: **요청(Request) - 응답(Response)** 구조  
  - 예시: 브라우저가 `GET /index.html` → 서버가 HTML 전송  
  - 기본 포트: **80**
- **HTTPS (HTTP Secure)**  
  : HTTP 위에 **TLS 암호화**를 덧씌운 버전.  
  데이터 전송 시 기밀성, 무결성, 인증을 제공. (TLS를 활용) 
  - 기본 포트: **443**
  
---

### 2️⃣ FTP / SFTP / FTPS
- **FTP (File Transfer Protocol)**  
  : 파일 업로드·다운로드용 표준.  
  - 평문 전송이라 보안 취약.
- **FTPS / SFTP**  
  : 각각 TLS(Secure FTP), SSH 기반 보안 FTP.

---

### 3️⃣ SMTP / POP3 / IMAP
- **SMTP (Simple Mail Transfer Protocol)**  
  : 메일 “보내기” 담당 (서버→서버 전송).  
  - 포트: 25(기본), 587(보안)  
- **POP3 (Post Office Protocol v3)**  
  : 메일 “받기” 담당 (서버에서 삭제 후 수신).  
  - 포트: 110 / 995(SSL)  
- **IMAP (Internet Message Access Protocol)**  
  : 메일 “서버 보관형” — 여러 기기에서 동기화.  
  - 포트: 143 / 993(SSL)

---

### 4️⃣ DNS (Domain Name System)
- **기능:** 사람이 읽는 도메인(google.com)을 IP(142.250.x.x)로 변환.  
- **질의 방식:** 클라이언트 → DNS 서버  
  - 질의(Query): “google.com의 A레코드(IP) 알려줘.”  
  - 응답(Response): “142.250.185.14야.”  
- **포트:** 53 (UDP 기반, 필요 시 TCP)

---

### 5️⃣ SSH / Telnet
- **SSH (Secure Shell):** 원격 접속 시 암호화된 터미널 세션 제공.  
  포트 22, RSA/ECC 공개키 기반 인증.  
- **Telnet:** SSH 이전 세대의 원격 접속 (평문 전송).  

---

## 🟤 6️⃣ 표현 계층 (Presentation Layer)

### 1️⃣ TLS / SSL
- **역할:** 암호화 + 무결성 + 인증  
  - TLS Handshake → 대칭키 교환 → 암호화된 데이터 전송  
  - 사용 알고리즘: RSA, Diffie-Hellman, AES, HMAC 등
- **HTTPS의 근간**이며,  
  표현 계층에서 데이터 자체를 보호함.

-> TLS (Transport Layer Security)는 전송계층 보안을 의미하고 SSL(Secure Sockets Layer)이 발전한 버전이다.
---

### 2️⃣ MIME
- **메일 본문에 파일 첨부, 이미지 삽입 등 ‘형식 정보’를 추가**하기 위한 규격.  
- `Content-Type: text/html`, `image/jpeg` 와 같은 헤더가 바로 MIME의 산물.

---

### 3️⃣ JSON / XML
- **데이터 표현 포맷**.  
  응용 계층 간 메시지 교환 시 구조적 데이터로 표현.  
  - JSON: `{ "name": "Hyungyu", "age": 24 }`  
  - XML: `<user><name>Hyungyu</name></user>`

---

---

## 🟡 5️⃣ 세션 계층 (Session Layer)

### 1️⃣ RPC (Remote Procedure Call)
- **의미:** 네트워크 너머의 함수를 “로컬 함수처럼” 호출하게 해주는 프로토콜(규칙)  
  예: 클라이언트가 `login(user, pass)`를 호출 → 서버가 실행.  
  - 예시 구현: gRPC (HTTP/2 기반), ONC RPC, DCOM

---

### 2️⃣ NetBIOS
- **윈도우 환경에서 컴퓨터 이름 기반 세션 통신**을 제공.  
  - 예: `\\MYPC\SharedFolder` 접근
  - SMB(파일 공유 프로토콜)의 세션 관리 기반.

---

### 3️⃣ PPTP / L2TP
- **VPN 연결용 세션 프로토콜.**  
  데이터 전송 전에 논리적 터널(session)을 먼저 생성.
---

## 🟢 4️⃣ 전송 계층 (Transport Layer)

### 1️⃣ TCP (Transmission Control Protocol)
- **신뢰성 중심, 연결형 전송**  
  특징:
  - 3-Way Handshake로 연결 설정(SYN → SYN/ACK → ACK)
  - 순서제어(Sequence Number)
  - 흐름제어(Window Size)
  - 혼잡제어(Congestion Window)
  - 오류검출(Checksum)
  - 재전송(Retransmission)
- **사용 예시:** HTTP, SMTP, FTP, SSH 등
- **포트번호로 프로세스 구분**  
  (예: 80 → 웹, 22 → SSH, 25 → 메일)

---

### 2️⃣ UDP (User Datagram Protocol)
- **비신뢰성, 비연결형 전송**  
  특징:
  - 빠르고 단순 (헤더 8바이트)
  - 오류검출(Checksum)만 수행
  - 재전송/순서 보장 없음
- **사용 예시:** DNS, VoIP, 온라인 게임, 스트리밍  
  (지연보다 속도가 중요한 서비스에 유리)

---

---

## 🔵 3️⃣ 네트워크 계층 (Network Layer)

### 1️⃣ IP (Internet Protocol)
- **패킷 라우팅의 핵심 프로토콜**  
  - IPv4 주소 예시: 192.168.0.1  
  - IPv6 주소 예시: 2001:db8::1
- 기능:
  - 패킷 분할(Fragmentation)
  - TTL 관리
  - 라우팅(라우터를 통한 경로 선택)
- **비연결형, 비신뢰성** (TCP가 위에서 신뢰성 보완)
- **IP 헤더 주요 필드:**
  - Source/Destination IP
  - TTL(Time To Live)
  - Protocol (상위 계층 지정: 6=TCP, 17=UDP)
  - Header Checksum

---

### 2️⃣ ICMP (Internet Control Message Protocol)
- **IP의 오류 및 진단용 보조 프로토콜**
  - Ping → Echo Request / Echo Reply
  - TTL 초과 → Time Exceeded
  - 목적지 불가 → Destination Unreachable
- **IP의 페이로드로 포함되어 전송**됨.

---

### 3️⃣ ARP / RARP
- **ARP:** IP 주소 → MAC 주소 매핑  
  (예: 192.168.0.5 → 00:1A:2B:3C:4D:5E)
- **RARP:** 반대로 MAC → IP 매핑 (요즘은 DHCP가 대체)

---

### 4️⃣ OSPF / BGP / RIP
- **라우팅 프로토콜** (라우터끼리 경로 정보를 교환)
  - **RIP:** 거리벡터 기반, 홉 수 기준
  - **OSPF:** 링크상태 기반, 내부망용
  - **BGP:** 자율시스템 간 경로 결정(인터넷 백본)

---

---

## 🟠 2️⃣ 데이터링크 계층 (Data Link Layer)

### 1️⃣ Ethernet (IEEE 802.3)
- **LAN(Local Area Network)에서 가장 널리 사용되는 프레임 전송 규칙**
  - MAC 주소 기반 통신 (48비트)
  - CSMA/CD (충돌 감지)
  - 프레임 구성: [Dest MAC | Src MAC | Type | Data | CRC]
  
 -> LAN 구조
```css
[PC1]——┐
        │
[PC2]——─┼──[스위치]──[라우터]──[인터넷]
        │
[프린터]┘
```
---

### 2️⃣ PPP (Point-to-Point Protocol)
- 두 장치 간(모뎀, VPN 등) 직접 연결용
  - 인증 (PAP, CHAP)
  - 압축, 오류 검출

---

### 3️⃣ VLAN (IEEE 802.1Q)
- **하나의 스위치에서 여러 가상 네트워크 분리**  
  - 프레임에 12비트 VLAN ID 삽입 (Tagging)
  - 논리적 분리로 보안·트래픽 관리 용이

---

### 4️⃣ HDLC / LAPB
- WAN(Wide Area Network)에서 쓰이는 링크 제어 프로토콜.  
  안정적인 비트 전송, 오류검출, 재전송 기능.

---

---

## 🔴 1️⃣ 물리 계층 (Physical Layer)

### 1️⃣ Ethernet PHY (10/100/1000BASE-T)
- UTP 케이블로 전기 신호를 주고받는 물리적 사양.
- 8핀(RJ45 커넥터), 전송 거리·속도 규정.

---

### 2️⃣ Wi-Fi (IEEE 802.11)
- 무선 LAN 전송 규격.
  - 802.11a/b/g/n/ac/ax 등 세대별로 속도·주파수 대역 다름.
  - CSMA/CA 방식 사용(충돌 회피).

---

### 3️⃣ Bluetooth (IEEE 802.15)
- 근거리(10m 이내) 저전력 무선 통신.
  - IoT, 무선 이어폰, 주변기기 연결.

---

### 4️⃣ 광섬유 / DSL / SONET / SDH
- **장거리, 고속 통신용 전송 매체.**
  - 광섬유: 빛 신호
  - DSL: 전화선 이용
  - SONET/SDH: 동기식 광전송망 표준

---

### 5️⃣ 부호화(Encoding)
- **비트를 신호로 바꾸는 규칙**  
  - NRZ, Manchester, PAM5 등  
  - 동기화와 오류 검출 효율성을 좌우함.

---

# 📘 정리 요약

| 계층 | 대표 프로토콜 | 주요 역할 |
|------|----------------|------------|
| 7 응용 | HTTP, FTP, DNS, SSH, DHCP | 사용자 서비스 |
| 6 표현 | TLS, MIME, JSON, XML | 암호화·형식·압축 |
| 5 세션 | RPC, NetBIOS, PPTP | 세션 관리 |
| 4 전송 | TCP, UDP, SCTP | 신뢰성, 포트 |
| 3 네트워크 | IP, ICMP, ARP, OSPF, BGP | 주소·라우팅 |
| 2 데이터링크 | Ethernet, PPP, VLAN | 프레임, MAC |
| 1 물리 | Ethernet PHY, Wi-Fi, Fiber | 비트 전송 |

---

 