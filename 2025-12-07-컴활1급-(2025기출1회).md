# 📌 1. InStr 함수와 첫 번째 인수(시작 위치)의 설계 철학

## 1-1. InStr의 기본 형태

- 엑셀/VBA의 `InStr` 형식  
  `InStr([start], string1, string2, [compare])`
- 첫 번째 인수 `start`는 **검색을 시작할 위치**를 의미한다.
- 문자열, 찾을 문자열보다 **검색 시작 지점**을 먼저 적는 것이 특징이다.

## 1-2. 왜 첫 번째 인수가 ‘시작 위치’인가

1. **자연어(영어 문장)처럼 읽히도록 설계**
   - “이 위치(start)부터 이 문자열(string1) 안에서 저 문자열(string2)을 찾아라(compare)”  
   - `start → 대상 문자열 → 찾을 문자열` 순으로 읽히게 하려는 언어 철학.

2. **초기 BASIC 계열 언어의 전통**
   - 문자열은 배열처럼 다루었고, 검색의 핵심은 “어디서부터 읽을 것인가”였다.
   - `INSTR(start, text$, pattern$)` 구조가 오래된 전통으로 남아 VBA까지 이어짐.

3. **매개변수 생략(옵션 인수) 처리의 용이성**
   - `start` 인수를 생략하면 기본값으로 1을 쓴다.
   - 맨 앞에 있는 선택적 인수라, 생략/지정이 명확하다.

정리하면, `InStr`은 **검색의 출발점(start)을 가장 중요한 정보로 본 설계 철학 + 과거 BASIC 계열의 역사** 때문에 첫 인수 자리에 시작 위치가 온다.

---

# 📌 2. 숫자(Number) 형식 필드를 ‘일련번호(Autonumber)’로 바꿀 수 없는 이유

## 2-1. Number와 Autonumber의 본질적 차이

- **Number(숫자 형식)**
  - 사용자가 입력/수정하는 **의미 있는 값**.
  - 계산, 정렬, 비교가 목표.
- **Autonumber(일련번호)**
  - Access 엔진이 자동 생성하는 **고유 식별자(Primary Key 후보)**.
  - 사용자가 직접 입력/수정 불가.
  - 값 자체는 **의미가 없는 ID**.

두 형식은 이름만 비슷하지, **“의미”와 “역할”이 완전히 다르다.**

## 2-2. 내부 엔진 관점

- Autonumber는:
  - **ID 생성기(generator)** 와 연결.
  - 테이블마다 고유한 증가 규칙을 가짐.
  - 레코드 저장 시점에 자동 부여.
- Number는:
  - 단순 저장값.
  - 중복/수정 허용.

이미 값이 들어 있는 숫자 필드를 Autonumber로 바꾸면:

- 중복된 값, 음수, 불규칙한 값이 있을 수 있음.
- Autonumber의 “고유성/일관성”이 깨짐.
- 엔진은 “이 값이 진짜 자동 생성된 ID인지” 보장할 수 없음.

그래서 Access는 구조적으로 **변환을 아예 금지**한다.

---

# 📌 3. 범례, 데이터표 vs 목표값 찾기, Alt+화살표, ESC와 그룹 해제

## 3-1. 범례 순서 변경은 왜 “범례 서식”이 아니라 “데이터 선택”에서 하나

- **범례(legend)** 는 “계열 목록을 **그대로 보여주는 표시 객체**”일 뿐, 자체적인 순서를 가진 구조가 아니다.
- 차트에서 진짜 데이터를 가진 것은 **계열(Series)** 이고, 범례는 계열을 반영한다.
- 따라서 **순서를 바꾸려면 계열의 순서를 바꿔야 하고**, 계열을 조작하는 창이 바로 **[데이터 선택(Select Data)]** 이다.
- [범례 서식]은 글꼴, 테두리, 배치 등 **시각적 장식만 담당**하므로 순서가 바뀌지 않는다.

요약:  
> “범례는 데이터의 거울이다. 순서는 거울이 아니라 데이터(계열) 쪽에서 바꿔야 한다.”

## 3-2. 데이터표(Data Table)와 목표값 찾기(Goal Seek)의 근본 차이

- **데이터표(Data Table)**
  - 하나의 수식 결과를 기준으로,  
    입력값을 여러 값으로 바꿔 가며 **여러 결과를 표 형태로 계산**하는 도구.
  - “여러 시나리오를 한 번에 비교하는 자동 시뮬레이션”.

- **목표값 찾기(Goal Seek)**
  - 어떤 수식의 결과를 **특정 값으로 만들기 위해**  
    하나의 입력셀 값을 역으로 계산하는 도구.
  - “단 하나의 해(입력값)를 역산하는 방정식 풀이.”

정리:

| 기능 | 데이터표 | 목표값 찾기 |
|------|-----------|-------------|
| 목적 | 여러 입력값에 대한 결과표 생성 | 결과를 특정 값으로 만드는 입력값 찾기 |
| 입력 셀 수 | 1~2개 | 1개 |
| 결과 개수 | 여러 개 | 1개 |
| 개념 | 시나리오 비교 | 역산(해 찾기) |

## 3-3. Alt + 화살표(↓)는 드롭다운 “생성”이 아니라 “펼치기”

- Alt + ↓ 는 **이미 존재하는 드롭다운 목록(데이터 유효성 목록)** 을 **펼치는 단축키**이다.
- “새 드롭다운을 만드는 기능”이 아니라,  
  이미 “데이터 유효성 검사 → 목록”으로 설정된 셀의 목록을 **키보드로 열어주는 기능**이다.

## 3-4. ESC 두 번 누르면 그룹이 해체된다는 말이 왜 틀렸는지

- ESC의 진짜 동작:
  - 1회: 현재 편집/작업 취소.
  - 2회: 선택 상태 취소.
- **“그룹 해제(ungroup)” 기능은 아님**.
  - 도형 그룹 해제: `Ctrl + Shift + G`.
  - 행/열 그룹(아웃라인) 해제: 메뉴에서 [그룹 해제].

“ESC 두 번 = 그룹 해체”는  
> “선택이 풀려서 어쩌다 그룹이 풀린 듯이 보이는 착각”일 뿐, 설계상 완전히 틀린 설명이다.

---

# 📌 4. ClearContents vs ClearComments

## 4-1. 엑셀 셀은 여러 ‘레이어’를 가진 복합 객체

셀 내부에는 여러 층이 있다:

- 값(Value)
- 수식(Formula)
- 서식(Formatting)
- 주석/메모(Comment/Note)
- 데이터 유효성
- 조건부 서식
- 하이퍼링크 등

각 레이어를 독립적으로 지우기 위해 여러 Clear 계열 명령이 존재한다.

## 4-2. ClearContents

- **값/수식만 삭제**하고 나머지(서식, 주석, 유효성 등)는 유지.
- 데이터만 초기화하고, **양식/템플릿 구조는 유지**하고 싶을 때 사용.

## 4-3. ClearComments

- **주석/메모(Comment/Note)** 객체만 삭제.
- 값, 수식, 서식, 유효성 등은 그대로 남겨둔다.

요약:

| 기능 | 값/수식 | 서식 | 주석 | 유효성/조건부 서식 |
|------|--------|------|------|--------------------|
| ClearContents | 삭제 | 유지 | 유지 | 유지 |
| ClearComments | 유지 | 유지 | 삭제 | 유지 |

---

# 📌 5. 데이터 가져오기에서 DOC 파일을 지원하지 않는 이유

## 5-1. 파워쿼리/데이터 가져기의 전제: “구조화된 데이터”

데이터 가져오기 기능은 **표 형태(행·열 구조)** 를 가진 데이터를 읽기 위한 기능이다. 예:

- CSV, TXT(구분자 기반)
- Excel 파일
- XML, JSON
- DB, 웹표 등

이들은 기본적으로 **테이블 구조**를 갖는다.

## 5-2. DOC는 ‘비정형 이진 문서’ 포맷

- `.doc` (워드 구버전)은 내부적으로 **복잡한 바이너리 포맷**이다.
- 텍스트, 스타일, 이미지, 표, 주석 등이 섞여 저장되어 있으며  
  “테이블”이 아니라 **페이지 레이아웃 중심** 구조이다.
- 엑셀/파워쿼리는 DOC를 해석할 전용 **데이터 파서(parser)** 를 갖고 있지 않다.

그래서 엑셀 입장에서는 DOC 파일을 **“데이터 소스(표 데이터)”로 인식할 수 없기 때문에**  
데이터 가져오기 대상에서 제외한다.

---

# 📌 6. TYPE, ISERROR, ISERR, #N/A의 의미

## 6-1. TYPE 함수

- 셀 값의 **내부 데이터 타입**을 숫자로 반환:

| TYPE 결과 | 의미 |
|-----------|------|
| 1 | 숫자 |
| 2 | 텍스트 |
| 4 | 논리값 |
| 16 | 오류 값 |
| 64 | 배열 |

서식이 아니라, 엑셀이 내부적으로 인식한 타입을 보여주는 함수.

## 6-2. ISERROR 함수

- 값이 **어떤 종류의 오류든** (#N/A 포함) 오류면 TRUE.
- “모든 오류 잡기”용.

## 6-3. ISERR 함수가 #N/A만 제외하는 이유

엑셀은 오류값을 크게 두 부류로 나눈다:

- “진짜 계산/참조 오류”
  - #DIV/0!, #VALUE!, #REF!, #NUM!, #NAME?, #NULL!
- “데이터 부재(정상적인 예외 상황)”
  - **#N/A (Not Available)**

#N/A는 특히 VLOOKUP, MATCH 등에서  
“찾는 값이 없음”이라는 **정상적인 결과**로 자주 사용되기 때문에,  
대부분의 경우 계산 오류와 **구분해서 처리**해야 한다.

그래서:

- **ISERR**: #N/A를 제외한 나머지 오류만 TRUE.
- **ISNA**: #N/A만 TRUE.
- **ISERROR**: 모든 오류(TRUE).

요약:

> ISERR는 “계산/참조가 깨진 오류”만 잡고,  
> “데이터가 없다는 신호(#N/A)”는 따로 분리할 수 있도록 설계되었다.

## 6-4. 날짜 2칸 + Ctrl + 자동채우기 시 값이 복사되는 이유

- 엑셀 자동채우기는 기본적으로 **패턴 인식 기반**이다.
  - 두 날짜의 차이가 일정하면 → 날짜 증분 패턴으로 인식 → 증가.
- 하지만 **Ctrl을 누르고 드래그**하면:
  - “패턴을 무시하고 원본을 그대로 반복 복사하라”는 모드로 동작.
- 그래서 날짜 2칸을 선택하고 Ctrl + 드래그를 하면  
  증가가 아니라 **A, B, A, B, …** 패턴으로 복사된다.

---

# 📌 7. 텍스트 필드 vs 레이블/단추/확인란, 대출 미래가치 0, 원형차트 2계열 불가, 매크로 보안

## 7-1. 텍스트 필드에 매크로를 직접 연결할 수 없는 이유

- 텍스트 박스(Text Box):
  - 주 목적: **데이터 입력/표시** (데이터 바인딩 컨트롤).
  - 이벤트도 대부분 “입력/포커스/변경” 중심.
- 레이블(Label), 단추(Button), 확인란(CheckBox):
  - 주 목적: **사용자 행동(클릭/체크)을 트리거하는 UI 컨트롤**.
  - `On Click` 같은 이벤트가 매크로 연결에 적합.

그래서 설계상:

- 텍스트 박스는 “데이터용 컨트롤”  
- 버튼/레이블/확인란은 “행위(Action) 컨트롤”  
→ 매크로 연결 대상이 후자 위주로 설계된다.

## 7-2. 대출금의 미래가치(FV)가 0인 이유

엑셀 금융 함수에서 **대출(loan) 모델**은 기본적으로:

- 현재 대출금(pv)을 빌려서
- 일정 기간 동안(pmt) 상환해서
- **최종적으로 남는 잔액(FV)이 0이 되도록** 설계된다.

즉, 대출의 미래가치는 “돈이 남는 것”이 아니라  
“부채가 최종적으로 얼마 남는가”를 의미하므로  
**상환을 다 끝냈을 때 FV = 0** 이 자연스러운 기본 설정이다.

## 7-3. 원형 차트에 2개 계열을 넣을 수 없는 이유

- 원형(Pie) 차트의 본질:
  - “하나의 전체(100%)를 여러 조각으로 나눈 비율” 표현.
  - 한 번에 **한 계열의 합계**만을 100%로 본다.
- 두 계열을 동시에 표현하면:
  - 100%가 2개 생겨버림 → 모델 붕괴.
- 따라서 엑셀은 Pie 차트를 “단일 계열 전용”으로 제한한다.

## 7-4. 매크로 기록 대화상자에서 보안 옵션을 못 건드리는 이유

- 매크로 보안 설정은:
  - 통합 문서 한 개의 문제가 아니라
  - **엑셀 전체/시스템 전체 보안 정책**에 해당.
- 기업/기관 환경에서는 그룹 정책(GPO)로 잠겨 있을 수 있음.
- “매크로 기록”은 단순히 동작을 기록할 뿐이고,  
  보안은 “실행을 허용할지 여부”를 결정하는 상위 정책이기 때문에  
  **기록 대화상자 수준에서 바꾸지 못하게 설계**되어 있다.

---

# 📌 8. F10, F1, Ctrl+F10, Ctrl+F1의 설계 의도

## 8-1. Ctrl + F10

- 현재 엑셀 창을 **최대화/복원**하는 Windows 공통 단축키.
- 개별 프로그램이 아니라 **“창 프레임(Window Frame)”을 조작**하는 시스템 레벨 단축키.

## 8-2. Ctrl + F1

- 엑셀의 **리본(Ribbon) 표시/숨기기 토글**.
- 화면 공간 확보를 위해 리본을 접었다 펼치는 용도.
- F1이 “정보 계층(도움말)”과 관련된 키라면,  
  Ctrl+F1은 “UI 레이아웃(리본)을 제어하는 키”로 확장된 셈.

## 8-3. F10

- 메뉴/리본에 키보드 포커스를 주는 기능.
- Alt와 비슷하게 **메뉴 탐색 모드**로 전환.
- 전통적으로 Windows에서 “메뉴바 접근용 키” 역할을 해왔고,  
  리본 환경에서도 이 철학을 계승한다.

## 8-4. F1

- 도움말(Help)을 여는 전 세계 표준 단축키.
- “막힐 때 바로 도움을 요청할 수 있게 한다”라는 UI 철학의 결정체.

요약:

- **F10**: UI 탐색(메뉴 포커스) 계층 진입.
- **F1**: 도움말(Information Layer) 진입.
- **Ctrl + F10**: 창 크기 제어(시스템 레벨).
- **Ctrl + F1**: 리본 표시/숨김(UI 레이아웃 제어).

---

# 📌 9. MATCH와 INDEX의 역할 분담

## 9-1. MATCH — 위치를 찾는 함수

- `MATCH(찾을 값, 범위, [일치 유형])`
- 반환값: **해당 값이 범위 안에서 몇 번째 위치인지** (인덱스 번호).
- 예:  
  `MATCH("사과", A1:A5, 0)` → “사과가 세 번째라면” 3 반환.

## 9-2. INDEX — 위치로부터 값을 꺼내는 함수

- `INDEX(범위, 행번호, [열번호])`
- 반환값: **해당 위치에 있는 실제 셀 값**.
- 예:  
  `INDEX(A1:A5, 3)` → A3의 값.

## 9-3. MATCH + INDEX 조합의 철학

- MATCH: “지도에서 좌표 찾기”
- INDEX: “좌표로 가서 값 읽어오기”

즉:

> MATCH = 위치(인덱스)  
> INDEX = 그 위치의 값

이 둘을 조합하면 VLOOKUP의 한계를 넘는,  
범용적인 **검색 + 참조 구조**를 만들 수 있다.

---

# 📌 10. “행 단위로 정렬된다”의 정확한 의미

## 10-1. 행 단위 정렬이란?

- 정렬 기준은 **열(세로 값)** 이지만,  
- 정렬 시 실제로 **이동하는 단위는 행 전체**이다.

예:

| 이름 | 나이 |
|------|------|
| 철수 | 30 |
| 영희 | 25 |
| 민수 | 40 |

나이 기준 오름차순 정렬 → 행 전체가 이동:

| 이름 | 나이 |
|------|------|
| 영희 | 25 |
| 철수 | 30 |
| 민수 | 40 |

즉,  
열의 값을 비교하지만, **레코드(행)** 단위로 순서를 재배열하는 것.

## 10-2. “행이 쌓이는 방향으로 정렬된다”는 표현이 왜 부정확한지

- 정렬은 “새 데이터가 아래로 쌓인다”는 의미가 아니라,
- 이미 있는 행들의 **순서를 다시 배열하는 작업**이다.
- 따라서 올바른 이해:
  > “행 전체가 위아래로 재배치된다”  
  > (각 행은 하나의 레코드로 취급됨)

---

# 📌 11. 표 범위 자동 인식과 정렬 범위

## 11-1. “표 범위 안에 커서를 두고 정렬하면 표 전체가 정렬된다”의 의미

- 엑셀은 **연속된 데이터 블록(중간에 빈 행/열이 없는 영역)** 을 하나의 “표”로 인식한다.
- 정렬 범위를 따로 지정하지 않고, 그 블록 안의 셀 하나만 선택해도:
  - 엑셀은 자동으로 “이 전체가 하나의 표구나”라고 판단.
  - 정렬 범위를 **표 전체(연속 블록)** 로 확장해서 처리한다.

## 11-2. 표 범위의 경계: 어디까지인가?

- **빈 행 또는 빈 열이 나오기 전까지의 연속된 영역**이 하나의 표.
- 예:

  - A1:B10에 데이터, A11은 빈 행, A12:B20에 다시 데이터라면:
    - A1:B10 = 첫 번째 표
    - A12:B20 = 두 번째 표

- A2에서 정렬하면 A1:B10만 영향을 받고, A12:B20은 그대로 남는다.

## 11-3. 왜 이런 자동 확장을 하는가?

- 정렬 시 열만 따로 움직이면 **데이터 관계가 붕괴**된다.
- 엑셀은 한 행을 **하나의 레코드(묶인 데이터)** 로 보는 철학을 갖고 있기 때문에:
  - 정렬 기준은 열이지만
  - 움직이는 단위는 항상 **행 전체**이며
  - 그 범위를 자동으로 **연속 데이터 영역 전체**로 잡아준다.

---