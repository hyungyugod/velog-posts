# 📌 1. kaggle 문제 풀이
### 1-1. 이상치를 찾아라
- 출처: https://www.kaggle.com/code/agileteam/py-t1-1-iqr-expected-questions
- 포인트는 quantile 함수로 리스트를 제공하면 해당하는 사분위수를 바로 받을 수 있다는 점과 mask를 따로 분리하는 것 그리고 iqr을 직접 식을 세워서 계산하는 것이 있다.
```py
# 라이브러리 및 데이터 불러오기
import pandas as pd
import numpy as np
df = pd.read_csv("../input/titanic/train.csv")

# 간단한 탐색적 데이터 분석 (EDA)
df["Fare"].isna().sum()
df.info()
df.shape

# IQR 구하기
q1, q3 = df["Fare"].quantile([0.25, 0.75])
iqr = q3 - q1

top = 1.5 * iqr + q3
bottom = q1 - 1.5 * iqr 

# 이상치 데이터 구하기
mask = (df["Fare"] > top) | (df["Fare"] < bottom)
masked_df = df[mask]

# 이상치 데이터에서 여성 수 구하기, 출력하기 print()
print(len(masked_df[masked_df["Sex"] == "female"]))
```
- 힌트에서 넘파이를 사용하면 아래처럼 사분위수를 가져올 수 있는데 이때 percentile인 것을 유의해야할 것 같다.
- 또 sum(outdata2['Sex'] == 'female') 이런 식으로 한번에  boolean serise에서 sum을 이용해 개수를 구하는 방법이 연산을 한번 덜 할 수 있어서 좋은 것 같다.
```py
# numpy 활용시
Q1 = np.percentile(df['Fare'], 25)
Q3 = np.percentile(df['Fare'], 75)

print(sum(outdata2['Sex'] == 'female'))
```

# 📌 2. SVR에서 ε(엡실론) 영역과 피팅 영향

## 2-1. ε 튜브의 의미  
- SVR(Support Vector Regression)은 회귀선을 중심으로 ±ε 만큼의 허용 범위를 둔다.  
- 이 범위 안의 데이터는 "충분히 잘 예측된 것"으로 간주되어 손실(loss)을 0으로 처리한다.  

## 2-2. 피팅에 영향을 주지 않는 이유  
- 모델은 손실을 최소화하도록 파라미터를 조정한다.  
- 손실이 0이면 기울기(gradient)도 0이 되어 파라미터 업데이트에 기여하지 않는다.  
- 즉, ε 안의 데이터는 직선 위치를 바꾸는 데 영향을 주지 않는다.  
- 결국 회귀선은 ε 밖(손실이 생기는 영역)의 데이터만 고려하여 결정된다.  
- 이 데이터들이 바로 "서포트 벡터"이며, 회귀선을 "지지"한다.

---

# 📌 3. Logistic Regression에서 max_iter의 의미

## 3-1. 반복(iteration)과 수렴  
- 로지스틱 회귀는 경사하강법이나 뉴턴 방법과 같은 반복적 최적화 알고리즘으로 파라미터를 학습한다.  
- 손실이 줄어들 때까지 반복하며, 이 반복 횟수를 제한하는 것이 `max_iter`이다.

## 3-2. max_iter의 역할  
- `max_iter`는 파라미터 업데이트를 위한 최대 반복 횟수를 지정한다.  
- 지정한 횟수 내에 수렴하지 않으면 경고가 발생하고 학습이 중단된다.  
- 데이터가 복잡하거나 학습률이 작을 경우 반복 횟수를 늘려야 할 수 있다.  
- 반복 횟수보다 더 중요한 것은 데이터 스케일링, 학습률 조절 등의 전처리이다.

---

# 📌 4. 불균형 데이터와 소수 클래스의 중요성

## 4-1. 불균형 상황에서의 문제  
- 예: 정상 990명, 질병 10명 → 모든 사람을 "정상"이라고 예측해도 정확도는 99%  
- 하지만 소수 클래스(질병 환자)를 놓치면 모델의 실제 목적을 달성하지 못한다.

## 4-2. 소수 클래스 분류의 중요성  
- 혼동행렬에서 중요한 것은 TP(진짜 질병을 질병이라 예측)와 FN(질병을 놓친 경우)이다.  
- 소수 클래스를 명확히 분류한다는 것은 TP를 늘리고 FN을 줄이는 것과 같다.  
- 이를 위해 정확도보다 재현율(Recall), 정밀도(Precision), F1-score, AUC 등의 지표를 중시한다.  
- 재현율이 특히 중요한 이유는 실제 양성을 놓치지 않는 것이 핵심이기 때문이다.

---

# 📌 5. predict_proba에서 proba의 의미

## 5-1. 용어 의미  
- `proba`는 **probability(확률)**의 약자이다.  
- `predict_proba()`는 각 클래스에 속할 **확률**을 반환하는 함수이다.

## 5-2. 활용과 해석  
- 단순히 어떤 클래스로 분류되는지(`predict`)가 아니라 각 클래스의 확률을 알 수 있다.  
- 이를 통해 모델의 예측 "확신 정도"를 파악하거나 임계값(threshold)을 조절할 수 있다.  
- 예: 이진 분류에서 `[0.1, 0.9]`는 두 번째 클래스일 확률이 90%라는 의미이다.  
- 다중 클래스의 경우 각 클래스별 확률을 모두 반환한다.

---
