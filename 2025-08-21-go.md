# 📌 0. 구조체와 메서드
### 📌 0-1. 수신자 개념
- 구조체 개념이 있는 언어들은 값복사만 지원한다는게 참조하고 싶으면 그냥 포인터를 넘기는 식으로 구현하면 되기 때문이다.
- 자바 같은 경우에는 그냥 넣었을때 포인터 개념이 없으므로 스택을 거쳐 참조를 구현해야한다.

| 구분          | 값 수신자 (Value Receiver)                  | 포인터 수신자 (Pointer Receiver)                          |
|---------------|---------------------------------------------|---------------------------------------------------------|
| 선언          | `func (c GameCharacter) ...`                | `func (c *GameCharacter) ...`                           |
| 동작 원리     | 메서드 호출 시 **데이터의 복사본**이 전달됨 | 메서드 호출 시 **데이터의 원본 주소(포인터)**가 전달됨 |
| Java 비유     | 원시 타입을 메서드 인자로 넘기는 것과 유사  | 객체를 메서드 인자로 넘겨 `this`로 필드를 변경하는 것과 유사 |
| 주 사용처     | 원본 데이터를 수정할 필요가 없을 때 (예: 정보 출력) | 원본 데이터를 수정해야 할 때 (예: 상태 변경)              |

### 📌 0-2. 생성자 개념
- go에는 객체지향 프로그래밍의 클래스와 같은 개념이 없기 때문에 당연히 클래스 생성자라는 개념도 없지만 단지 구조체를 생성하고 해당 구조체의 포인터를 반환하여 구조체의 정보를 직접 변경할 수 있게 함으로서 간접적으로 객체처럼 사용할 수 있게 구현하는 것을 의미한다.
- 물론 이는 객체 개념처럼 클래스의 구조를 가지고 새로 메모리에 올린게 아니라 직접 클래스에 접근하는 개념과 더 가깝다.

| 구분      | Go 생성자 함수                                | Java 생성자                                |
|-----------|-----------------------------------------------|--------------------------------------------|
| 정의 방식 | `func NewTypeName() *TypeName`                | `public ClassName() { ... }`               |
| 특징      | 관례적으로 `New`로 시작하는 일반 함수          | 클래스 이름과 동일한 특수 메서드            |
| 반환값    | 보통 **포인터를 반환**                        | 반환값 없음 (객체 자동 생성)                |
| 유연성    | 다양한 생성자 함수 정의 가능                   | 오버로딩으로 다양한 생성자 정의              |

```go
// GameCharacter 구조체 정의
type GameCharacter struct {
    Name string
    Level int
    HP int
    MP int
    Class string // 직업 필드 추가
}
// 기본 캐릭터 생성자 함수
// Go의 관례에 따라 'New' + 타입명으로 함수명을 정함
// 포인터를 반환하여 메모리 효율성을 높임
func NewGameCharacter(name, class string) *GameCharacter {
    return &GameCharacter{
    Name: name,
    Level: 1, // 기본 레벨 1로 시작
    HP: 100, // 기본 체력 100
    MP: 50, // 기본 마나 50
    Class: class,
    }
}
// 고급 캐릭터 생성자 함수 (커스텀 스탯)
// Java의 생성자 오버로딩과 유사한 효과
func NewAdvancedCharacter(name, class string, level, hp, mp int) *GameCharacter {
    return &GameCharacter{
    Name: name,
    Level: level,
    HP: hp,
    MP: mp,
    Class: class,
    }
}
```

### 📌 0-3. 구조체 임베딩

| 구분        | Go 임베딩                                   | Java 상속                                      |
|-------------|---------------------------------------------|------------------------------------------------|
| 키워드      | 별도 키워드 없음 (**익명 필드** 사용)        | `extends`                                      |
| 메서드 호출 | 임베딩된 필드의 메서드가 **자동으로 승격** (promotion) | `super.method()` 또는 직접 호출                 |
| 다중 상속   | **지원** (여러 구조체를 동시에 임베딩 가능)   | **미지원** (단일 상속만 가능, 대신 인터페이스 다중 구현 지원) |
| 오버라이딩  | 동일한 메서드명을 정의하여 재정의             | `@Override` 어노테이션을 사용하여 명시적 재정의   |

- BaseCharacter 라는 구조체를 Warrior 구조체 안에 그냥 선언하면 BaseCharacter의 모든 내부 변수들이 딸려 들어간다.
- 즉 BaseCharacter의 값이 복사되는 것이고 이는 BaseCharacter BaseCharacter로 선언한 것과 같다.
- 자동 승격(Promotion) 효과: Go는 임베딩된 구조체의 필드와 메서드를 자동으로 승격시켜서 마치 Warrior의 고유 필드인 것처럼 접근할 수 있게 해준다.
```go
type BaseCharacter struct {
    Name string
    Level int
    HP int
    MP int
}
type Warrior struct {
    BaseCharacter // 익명 필드로 임베딩
    Strength int // 전사만의 고유 필드
    Armor int // 방어력
}
```
- 만약 메서드 오버라이딩을 한다면 그냥 새로운 구조체를 가리키면서 재정의하면 된다. 오버로드와 오히려 같다. 그런데 오버로드라는 것도 사실 없어서 재정의로 그냥 느낌만 내는거다
```go
func (bc *BaseCharacter) LevelUp() {
    bc.Level++
    bc.HP += 10
    bc.MP += 5
    fmt.Printf("%s가 레벨업! (레벨: %d)\n", bc.Name, bc.Level)
}

// 메서드 오버라이딩 (BaseCharacter의 LevelUp을 재정의)
func (w *Warrior) LevelUp() {
    w.BaseCharacter.LevelUp() // 부모의 메서드 호출
    w.Strength += 3 // 전사만의 추가 스탯 증가
    w.Armor += 2
    fmt.Printf("전사 스탯 증가: 힘 +3, 방어력 +2\n")
}
```

### 📌 0-4. 매서드 체이닝
- 그냥 빌더 패턴을 하드코딩하여 구현한다.
- 구조체를 만들고 set함수들을 만든다음 값을 세팅하고 구조체의 포인터를 반환하도록 만들어 포인터에 계속 접근하여 값을 수정할 수 있도록 하는 것이다.
- 최종적으론 cb.character // 같은 포인터를 그대로 내보낸다.
- 여러 서로 다른 빌더 구조체를 사용해서 만들어진 구조체들은 서로 독립이다.
```go
// 새로운 빌더 생성
func NewCharacterBuilder() *CharacterBuilder {
    return &CharacterBuilder{
    character: &GameCharacter{
    Level: 1,
    HP: 100,
    MP: 50,
    Skills: make([]string, 0),
    },
}
}
// 체이닝 메서드들 (모두 *CharacterBuilder를 반환)
func (cb *CharacterBuilder) SetName(name string) *CharacterBuilder {
    cb.character.Name = name
    return cb // 자기 자신을 반환하여 체이닝 가능
}
func (cb *CharacterBuilder) SetClass(class string) *CharacterBuilder {
    cb.character.Class = class
    return cb
}
func (cb *CharacterBuilder) SetLevel(level int) *CharacterBuilder {
    cb.character.Level = level
    return cb
}
func (cb *CharacterBuilder) SetStats(hp, mp int) *CharacterBuilder {
    cb.character.HP = hp
    cb.character.MP = mp
    return cb
}
func (cb *CharacterBuilder) AddSkill(skill string) *CharacterBuilder {
    cb.character.Skills = append(cb.character.Skills, skill)
    return cb
}
// 최종 캐릭터 반환
func (cb *CharacterBuilder) Build() *GameCharacter {
    return cb.character
}
```

### 📌 0-5. 수신자별 성능에 대하여
- 이론적으론 포인터로 찾아가는게 빠른 것이 자연스러워 보이지만 실제론 값을 복사하는게 속도 자체는 더 빠르다.
```go
// 큰 구조체 예제
type LargeStruct struct {
    Data [1000]int
    Name string
    ID int
}
// 값 수신자 메서드
func (ls LargeStruct) ProcessWithValue() int {
    sum := 0
    for _, v := range ls.Data {
        sum += v
    }
    return sum
}
// 포인터 수신자 메서드
func (ls *LargeStruct) ProcessWithPointer() int {
    sum := 0
    for _, v := range ls.Data {
        sum += v
    }
    return sum
}
```

### 📌 0-6. go언어 인터페이스
- Go의 접근 방식은 "덕 타이핑(Duck Typing)" 철학을 따름. "만약 어떤 새가 오리처럼 걷고, 오리처럼 꽥꽥거린다면, 나는 그 새를 오리라고 부르겠다"는 의미처럼, 실제 타입이 무엇인지보다 어떤 메서드를 가지고 있는지가 더 중요함.
- 아래에서 Notifier라는 타입은 Send 메서드와 연계된 구조들을 지칭하게된다.
```go
type Notifier interface {
    Send(message string)
}
```
- 아래처럼 구조체를 만들고 func (e *EmailNotifier) Send(message string)처럼 포인터 리시버를 받는 send를 정의했다면 이는 Notifier 인터페이스의 요구사항을 만족켰다고 볼 수 있다.
```go
type EmailNotifier struct {
    Recipient string
}
// EmailNotifier 타입에 대한 Send 메서드를 구현.
// 이 메서드는 Notifier 인터페이스의 요구사항을 만족시킴.
// (e *EmailNotifier)는 포인터 리시버로, 메서드 내에서 구조체 필드 변경이 가능함을 의미.
func (e *EmailNotifier) Send(message string) {
// fmt.Printf를 사용하여 포맷팅된 문자열을 콘솔에 출력.
fmt.Printf("'%s' 주소로 이메일 발송: %s", e.Recipient, message)
}
```
- interface{} 이런 식으로 빈 인터페이스를 쓴다는 것은 이 인터페이스가 되기 위한 조건이 없다. 어떤타입이던 이 인터페이스로 친다는 것을 의미한다.
```go
func PrintAnything(v interface{}) {
    fmt.Printf("값: %v, 타입: %T", v, v)
}
```

### 📌 0-7. 타입어설션
- 빈 인터페이스를 받아 특정 타입으로 변환하기위해 사용하는 문법이다. 
- 인터페이스에 .(T)로 해당 타입으로 변환한다.
```go
func CheckType(v interface{}) {
fmt.Printf("입력 값: %v\n", v)
// 1. "value, ok" 패턴을 사용한 안전한 타입 어설션
// v를 string 타입으로 변환 시도
str, ok := v.(string)
    if ok {
fmt.Printf(" (ok) 이 값은 문자열입니다: %s\n", str)
} else {
    fmt.Println(" (ok) 이 값은 문자열이 아닙니다.")
}

// 2. switch 문을 사용한 타입 어설션 (Type Switch)
// 여러 타입을 검사할 때 훨씬 간결하고 효율적임.
switch t := v.(type) {
case int:
    fmt.Printf(" (switch) 이 값은 정수이며, 2를 곱하면 %d 입니다.\n", t*2)
case string:
    fmt.Printf(" (switch) 이 값은 문자열이며, 길이는 %d 입니다.\n", len(t))
case bool:
    fmt.Printf(" (switch) 이 값은 불리언입니다: %t\n", t)
default:
// t의 타입은 v의 타입과 동일
    fmt.Printf(" (switch) 처리할 수 없는 타입입니다: %T\n", t)
}
    fmt.Println("--------------------")
}
```

# 📌 1. 모듈과 패키지
### 📌 1-1. 모듈과 패키지 구조
- Go 모듈은 의존성 관리를 위한 시스템임.
- 모듈 폴더 위치에서 명령프롬프트를 열고 다음 명령어를 수행 (go mod init hello-go) -> go.mod 파일 생성 이러면 모듈의 이름, go버전, 프로젝트가 의존하는 다른 모듈이나 패키지의 목록을 관리하게 된다.
- 패키지는 이 모듈 단위 내부의 폴더들을 의미한다.
- 특이한 점은 main에서 import로 가져올때 패키지 단위로 가져오고 main에서 함수를 사용할때도 package.함수이름으로 함수가 작성된 파일명은 생략하고 진행한다.
- 모듈을 전체 폴더에서 실행하기위해 실행위치를 현재 폴더로 옮기는 설정을 vs코드에서 해주면 좋다.
- code-runner.executorMap에 "go": "cd $dir && go run $fileName"를 추가한다.구
```go
// main.go
package main

import (
	"fmt"
	"hello-go/myapp" // 우리가 만든 mymath 패키지를 import
)

func main() {
	// mymath 패키지의 Add 함수 호출
	sum := myapp.Add(5, 3)
	fmt.Printf("5 + 3 = %d", sum)
	// 아래 코드는 컴파일 에러를 발생시킴
	// mymath 패키지의 subtract 함수는 소문자로 시작하여 외부에서 접근할 수 없기 때문
	// diff := mymath.subtract(5, 3)
	// fmt.Printf("5 - 3 = %d", diff)
}
```
