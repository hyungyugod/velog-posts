# 0. numpy 배열 등
### 0-1. numpy와 pandas의 관계
- numpy: 다차원 배열(ndarray) 라이브러리. 수치 계산에 특화. -> 행렬, 벡터연산 최적화
- pandas: numpy 배열을 기반으로 "표 형태" (Series, DataFrame)를 제공하는 라이브러리.
- pandas의 내부 데이터를 보면 사실상 대부분 numpy.ndarray가 깔려 있음.
- 즉, pandas의 Series는 "라벨 붙은 numpy 배열"이라고 보면 됨.
- 정확한 구조차이는 아래와 같다.
- numpy.ndarray: 그냥 "숫자 뭉치(배열)"
- pandas.Series: 
- 값(.values) → 사실상 numpy.ndarray (혹은 확장 배열)
- 인덱스(.index) → 라벨 (row 이름 같은 역할)
- 메타데이터 + 다양한 메서드
- 즉, Series는 ndarray를 직접 상속한 게 아니라, 내부적으로 ndarray를 감싸고(wrap) 그 위에 라벨과 편의 기능을 덧붙인 구조이다.

### 0-2. arg가 인덱스라는 의미를 갖는 이유
- 즉, arg가 인덱스라는 의미를 갖게 되는 건,
- 수학적 전통에서 argument가 입력값을 의미하기 때문이고,
- 배열 세계에서 입력(argument)은 곧 인덱스라서 자연스럽게 그렇게 굳어진 것이다.

### 0-3. 배열 생성과 전치
- reshape: 주어진 행의 크기 단위로 잘라 내려서 행렬을 구성한다.
- transpose 옵션
- 축 0: 배치(3차원 중 가장 바깥, 예를 들어 사진 여러 장 모음집)
- 축 1: 행(row)
- 축 2: 열(column)
```py
# 빈 행렬 생성
np.zeros((2,2)) # 2by2 행렬 생성

# 채워진 행렬 생성 -> n차원 행벡터를 만들고 이를 주어진 행의 크기 단위로 잘라 내려서 행렬을 구성한다.
# 행벡터 하나가 데이터 하나이다.
np.arange(1,5).reshape(2,2)

# 3차원 배열 표현 -> 축이 3개
mat1 = np.arange(7,13).reshape(2,3)
mat2 = np.arange(1,7).reshape(2,3)

mat3 = np.array([mat1, mat2])

# 차원의 변경 -> transpose()
# 축 0: 배치(3차원 중 가장 바깥, 예를 들어 사진 여러 장 모음집)
# 축 1: 행(row)
# 축 2: 열(column)
mat3.transpose(0,2,1) # 행과 열을 교환해서 전치시킴
```

### 0-4. ndarray 집계 연산 함수
- axis=0은 열기준, axis=1은 행기준이다.
```py
# sum, mean, max, min, std, var, cumsum, cumprod, argmax, argmin, flatten
# axis=0은 열기준, axis=1은 행기준이다.
mat1 = np.arange(1, 10).reshape(3,3)

mat1.sum() # 결과는 numpy 연산이 최적화된 int -> np.int64(45)
mat1.mean() # np.float64(5.0)
mat1.max()
mat1.min()
mat1.std()
mat1.var()
mat1.cumsum(axis=0)
mat1.cumprod(axis=0) # 누적 곱
mat1.argmax(axis=0) # 최대값 인덱스
mat1.argmin(axis=0) # 최소값 인덱스
mat1.flatten() # 배열 평탄화
```

### 0-5. ndarray 조작 함수
- clip: 모든 원소를 최소값, 최대값으로 맞춤, 넘치면 경계값으로
- copy: 배열을 깊은 복사함
- sort: 오름차순 정렬
- argsort: 정렬된 인덱스를 반환
```py
# clip, tolist, astype, copy, sort, argsort
mat1.clip(2,4) # 모든 원소를 최소값 2, 최대값 4로 맞춤, 넘치면 경계값으로
mat1.tolist() # ndarray를 순수 파이썬 리스트로 변환 -> json으로 변환하거나 파이썬 함수를 사용할 때 사용한다.
mat1.astype(float) # 배열 내부 원소들의 데이터 타입을 바꿔준다.
mat1.copy() # 배열을 깊은 복사하여 반환

mat2 = np.arange(1,10)
mat2.sort() # 오름차순만 지원하므로 [::-1]로 뒤집어야한다.
mat2.argsort() # 정렬된 인덱스를 반환
```

### 0-6. fancy indexing
- ndarray에서만 가능한 인덱싱으로 배열로 인덱싱을 할 수 있고 행과 열을 각각 어떻게 선택할 것인지 결정할 수 있다.
- [[1,3,4], :]는 행 인덱스 fancy indexing을 의미한다.
- [1,3,4] → 1행, 3행, 4행을 가져옴
- : → 모든 열을 가져옴
- mat2[:,2]
- : → 모든 행
- 2 → 세 번째 열(column index 2)
- 즉, mat2의 세 번째 열 벡터만 추출.
- mat2[mat2[:,2] > 3, :]: 여기서 mat2[:,2] > 3 → [True, True, True]
```py
mat1 = np.array([8,10,7,8,2,4,5,5,7,6,1,7,2,6,8,6,9,3,4,2]).reshape(5,4)
mat2 = mat1[[1,3,4], :]
mat2[mat2[:,2] > 3, :]
```
- 아래는 이를 이용하여 행별합계가 20이 넘는 행들만 골라서 배열로 만든 예제이다.
```py
mat1[np.sum(mat1, axis=1) >= 20, :]
```

### 0-7. ndarray에서 조건을 만족하는 원소의 인덱스만 반환
- np.where(condition)은 **"조건을 만족하는 원소들의 인덱스를 튜플"**로 반환 -> (array([1, 2]),)
- 1차원 배열 조건 → 튜플 안에 배열 1개
- 2차원 배열 조건 → 튜플 안에 배열 2개 (행 인덱스, 열 인덱스 따로)
- [0]번 원소로 꺼내주기
```py
np.where(np.mean(mat1,axis=0) > 5)[0]
```

### 0-8. 행별로 7이상인 원소가 하나라도 있는 행만 남겨서 추출하기
- np.sum(mat1 > 7, axis=1) -> array([3, 0, 0, 1, 1]) 에서 1이상인 순서만 선택하면 되므로 
- np.sum(mat1 > 7, axis=1) > 0 -> array([ True, False, False,  True,  True])
- mat1[np.sum(mat1 > 7, axis=1) > 0, :] 위를 기준으로 행을 마스킹하면 옆과 같고 True인 행들만 남게 된다.
```py
mat1[np.sum(mat1 > 7, axis=1) > 0, :]
```

### 0-9. np.select
- 조건문과 해당 조건문을 실행할 리스트를 같이 제공해서 x 리스트에 대해 처리된 리스트를 반환하는 문법이다.
```py
x = np.arange(10)
condlist = [x<3, x>5]
choicelist = [x, x**2]
np.select(condlist, choicelist)
```

### 0-10. zip 함수로 리스트 조작하기
- 이건 파이썬 기본 구문이다.
- zip을 통해 두 iterable의 같은 인덱스끼리 매칭한 후 리스트로 반환한다.
- 이를 포멧팅한 문장에 리스트컴프리헨션으로 집어넣는다.
```py
names = ["john","Alice"]
ages = [20,30]

[f"hi my name is {name} and i am {age} years old" for name, age in zip(names,ages)]
```