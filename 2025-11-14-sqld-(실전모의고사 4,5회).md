
# 📌 1. 문자열 함수와 정규식 함수 개념 정리

## 1-1. INITCAP 함수의 동작 원리

- INITCAP는 입력된 문자열을 **단어 단위**로 나누어 각 단어의 첫 글자만 대문자로, 나머지 글자는 소문자로 변환하는 함수이다.
- 단어 구분 기준은 공백(SPACE)이다.
- 예시:
  - `INITCAP('sQl d')`  
    - 단어 1: `sQl` → `Sql`  
    - 단어 2: `d` → `D`  
    - 최종 결과: `Sql D`
- 포인트:
  - 전체를 한 번에 UPPER/LOWER 하는 함수가 아니라 **단어별로** 적용되는 문자 함수이다.

## 1-2. REGEXP_SUBSTR 인자 구조와 의미

일반 형식:

```sql
REGEXP_SUBSTR(
  source_string,
  pattern,
  start_position,
  occurrence,
  match_parameter,
  subexpr
)
```

각 인자의 의미:

1. **source_string**  
   - 검색 대상 문자열.
   - 예: `'010-1234-5678'`.

2. **pattern**  
   - 정규 표현식 패턴.
   - 괄호 `()`로 **그룹**을 만들 수 있다.
   - 예:  
     - `'([0-9]{3})-([0-9]{4})-([0-9]{4})'`  
     - 1번 그룹: `[0-9]{3}` → `010`  
     - 2번 그룹: `[0-9]{4}` → `1234`  
     - 3번 그룹: `[0-9]{4}` → `5678`

3. **start_position**  
   - 몇 번째 문자부터 정규식 매칭을 시작할지 지정한다.
   - 기본값은 1이다.
   - 예: 1이면 문자열 처음부터 패턴을 찾는다.

4. **occurrence (네 번째 인자)**  
   - **문자열 전체에서 패턴이 몇 번째로 매칭된 결과를 반환할지** 지정하는 인자이다.
   - 즉, **패턴 전체의 매칭 순서**를 뜻한다.
   - 예를 들어:
     - 문자열: `'ab12cd34ef56'`
     - 패턴: `'[0-9]{2}'`
     - 매칭 결과: `12`(1번째), `34`(2번째), `56`(3번째)
       - `occurrence = 1` → `12`
       - `occurrence = 2` → `34`
       - `occurrence = 3` → `56`
   - 중요한 점:
     - **occurrence는 괄호 그룹 번호와 전혀 상관이 없다.**
     - “몇 번째 괄호”가 아니라 “몇 번째 패턴 매칭”을 의미한다.

5. **match_parameter**  
   - 대소문자 구분, 여러 줄 모드 등 정규식 옵션을 설정한다.
   - 여기서는 대부분 `NULL` 또는 생략.

6. **subexpr (여섯 번째 인자)**  
   - **선택된 매칭 안에서 몇 번째 괄호 그룹을 반환할지** 지정한다.
   - 그룹 번호는 패턴에서 왼쪽부터 1, 2, 3, … 순서로 매겨진다.
   - 예: `subexpr = 2` → 두 번째 괄호 그룹을 반환.

### 1-3. 예시로 다시 해석하기

```sql
REGEXP_SUBSTR(
  '010-1234-5678',
  '([0-9]{3})-([0-9]{4})-([0-9]{4})',
  1,
  1,
  NULL,
  2
)
```

- 대상 문자열: `'010-1234-5678'`
- 패턴: `'([0-9]{3})-([0-9]{4})-([0-9]{4})'`
  - 1번 그룹: `010`
  - 2번 그룹: `1234`
  - 3번 그룹: `5678`
- 시작 위치: `1` → 처음부터 검색
- 4번째 인자 occurrence: `1`
  - 전체 패턴이 문자열에서 매칭되는 **첫 번째** 결과를 사용한다.
  - 이 문자열에서는 전화번호 패턴이 **단 한 번만** 매칭되므로, 첫 번째 매칭 = `'010-1234-5678'`.
- 6번째 인자 subexpr: `2`
  - 위에서 선택된 매칭 `'010-1234-5678'` 안에서 **두 번째 그룹**을 반환한다.
  - 두 번째 그룹은 `1234`.

따라서 최종 결과는 `1234`이다.

정리하면:

- 4번째 인자: “전화번호 전체가 몇 번째로 등장했는가?”  
- 6번째 인자: “그 전화번호 안에서 몇 번째 괄호 그룹을 가져올까?”

둘은 전혀 다른 역할을 한다.

## 1-4. REGEXP_LIKE 에서 마침표(.) 찾기

- 정규식에서 `.` 은 “임의의 문자 1개”를 의미하는 **메타 문자**이다.
- 실제 문자 `.` 자체를 찾으려면 `\.` 처럼 **이스케이프**해야 한다.
- `REGEXP_LIKE(이름, '\.')` 의 의미:
  - 이름 컬럼에 **마침표 문자를 하나라도 포함하는 행**을 찾는다.

LIKE 와의 차이:

- `LIKE`:
  - `%` 와 `_` 가 와일드카드.
  - `.` 는 그냥 일반 문자.
  - 예: `WHERE 이름 LIKE '%.%'` → 마침표를 포함한 문자열.
- `REGEXP_LIKE`:
  - 정규식 규칙을 따르고, `.` 를 일반 문자로 쓰려면 `\.` 를 사용.
  - 부분 매칭이 기본이기 때문에 `%` 를 쓰지 않아도 문자열 어딘가에 `\.` 가 있으면 매칭된다.

---

# 📌 2. 집계 함수, NULL, NVL/NVL2, 형변환

## 2-1. 집계 함수와 공집합 결과

- `WHERE 1 = 0` 같은 조건은 **항상 거짓**이므로, 결과가 공집합이 된다.
- 공집합에서 집계 함수의 결과:
  - `MAX`, `MIN`, `SUM`, `AVG` 등은 **NULL** 을 반환한다.
- 예:
  - `SELECT MAX(COL1) FROM TAB WHERE 1 = 0;` → 결과는 NULL.

이후 NVL과 결합:

```sql
SELECT NVL(MAX(COL1), 0) + 1
FROM   TAB
WHERE  1 = 0;
```

- `MAX(COL1)` → NULL
- `NVL(NULL, 0)` → 0
- `0 + 1` → 1  
따라서 결과는 1이 된다.

## 2-2. NVL, NVL2, COALESCE, NULLIF

- `NVL(expr, value)`  
  - expr 이 NULL이면 value 를 반환, 아니면 expr 그대로 반환.
- `NVL2(expr1, expr2, expr3)`  
  - expr1 이 NOT NULL 이면 expr2,  
  - expr1 이 NULL 이면 expr3.
- `COALESCE(a, b, c, ...)`  
  - 왼쪽부터 차례대로 평가해서 처음 만나는 NOT NULL 값을 반환.
  - 여러 인자 중 첫 번째 유효값을 고를 때 쓰기 좋다.
- `NULLIF(a, b)`  
  - $a = b$ 이면 NULL 반환, 아니면 a 를 반환.

시험 기준으로 자주 나오는 포인트:

- 집계 결과가 NULL일 수 있음을 항상 떠올리고,
- NVL/NVL2/COALESCE 로 적절히 기본값을 채울 수 있어야 한다.

## 2-3. 문자형 컬럼에 MAX 함수 사용

예시:

```sql
CREATE TABLE TAB (
  COL1 VARCHAR2(10)
);

INSERT INTO TAB VALUES('50');
INSERT INTO TAB VALUES('100');
INSERT INTO TAB VALUES('90');

SELECT 100 + MAX(COL1) FROM TAB;
```

- COL1 은 문자형(VARCHAR2)이므로 `MAX(COL1)` 은 **문자 비교(사전식 비교)** 기준으로 최댓값을 찾는다.
- 문자열 `'50'`, `'100'`, `'90'` 의 첫 문자만 비교해도:
  - `'1'` < `'5'` < `'9'`
  - 따라서 문자 기준 최댓값은 `'90'`.

이후 산술 연산:

- `100 + MAX(COL1)` 은 숫자 연산이라 **숫자 쪽이 우선**된다.
- Oracle 은 문자를 숫자로 바꾸려고 시도한다:  
  - `TO_NUMBER('90')` → 90
- 실제 내부 동작은 다음과 같다:
  - `100 + TO_NUMBER('90') = 190`

시험에서 기억할 핵심:

- 산술 연산에 문자가 끼면, 문자를 **숫자로 암시적 형변환**하려고 한다.
- 문자열 연결 연산(`||`)에 숫자가 끼면, 숫자를 **문자로 형변환**한다.

## 2-4. 형변환 우선순위(단순 시험용 기억)

- 숫자 > 문자 > 날짜  
- 숫자 연산에 문자열이 섞이면 **문자 → 숫자** 변환을 시도하는 쪽이 우선.

---

# 📌 3. GROUP BY, GROUPING SETS 의 동작 논리

## 3-1. GROUP BY 와 GROUPING SETS 조합

예시 구문:

```sql
GROUP BY COL1,
         GROUPING SETS (COL1, (COL1, COL2), ())
```

설명:

- 바깥 `GROUP BY COL1` 은 **공통 그룹 컬럼**이다.
- 안쪽 `GROUPING SETS` 는 여러 그룹핑 조합을 명시한다.
  - `COL1`
  - `(COL1, COL2)`
  - `()` → 전체(총계)

실제 동작은:

- 바깥 COL1이 **각 GROUPING SET과 조합**되어 새로운 그룹 집합을 만든다.
- 조합 결과:
  - COL1 + COL1 → COL1
  - COL1 + (COL1, COL2) → (COL1, COL2)
  - COL1 + () → COL1
- 중복 제거 후 실제 그룹 집합:
  - `GROUP BY COL1`
  - `GROUP BY COL1, COL2`

즉, 다음 두 쿼리를 `UNION ALL` 한 효과와 같다:

```sql
SELECT ...
FROM   ...
GROUP BY COL1

UNION ALL

SELECT ...
FROM   ...
GROUP BY COL1, COL2;
```

핵심 정리:

- 밖 `GROUP BY` 컬럼은 `GROUPING SETS` 안의 모든 집합에 **분배**되어 실제 그룹 집합을 만든다.
- “한 번만 합쳐지는 것”이 아니라, **각 그룹핑셋마다 조합**된다는 점이 중요하다.

---

# 📌 4. 계층 쿼리(Oracle CONNECT BY) 개념

## 4-1. CONNECT BY 와 PRIOR 의 위치

형식:

```sql
SELECT *
FROM   EMP
START WITH <루트 조건>
CONNECT BY PRIOR 부모컬럼 = 자식컬럼;
```

- `PRIOR` 가 붙은 컬럼: **부모 행의 값**을 의미한다.
- `PRIOR` 가 없는 컬럼: **자식 행의 값**을 의미한다.

예시: KING(EMPNO=100)의 하위 직원을 찾는 문제

- EMPNO: 사번
- MGR: 상사의 사번

정답 쿼리:

```sql
SELECT *
FROM   EMP
START WITH EMPNO = 100        -- 루트: KING
CONNECT BY PRIOR EMPNO = MGR; -- 부모의 EMPNO = 자식의 MGR
```

설명:

1. `START WITH EMPNO = 100` 으로 KING 행을 찾는다.
2. 다음 단계에서 `PRIOR EMPNO = MGR` 조건을 만족하는 행을 찾는다.
   - 부모(이전 행)의 EMPNO 와
   - 자식(현재 행)의 MGR 이 같은 행.
3. 이런 식으로 계속 내려가며 하위 직원들을 찾는다.

핵심:

- `PRIOR` 는 **항상 부모 쪽 컬럼**에 붙인다.
- 잘못해서 `CONNECT BY PRIOR MGR = EMPNO` 이런 식으로 쓰면 구조가 완전히 뒤틀린다.

---

# 📌 5. OUTER JOIN, SELECT 컬럼, 결과 해석

## 5-1. LEFT/RIGHT JOIN + UNION 예시

문제 쿼리:

```sql
SELECT T1.ID, NAME, LOC
  FROM T1 LEFT OUTER JOIN T2
    ON T1.ID = T2.ID

UNION

SELECT T1.ID, NAME, LOC
  FROM T1 RIGHT OUTER JOIN T2
    ON T1.ID = T2.ID;
```

T1:

| ID | NAME |
|----|------|
| 1  | A    |
| 2  | B    |

T2:

| ID | LOC   |
|----|-------|
| 1  | SEOUL |
| 3  | BUSAN |

1) LEFT JOIN 부분

- T1 기준으로 모두 살림.
- 결과:
  - (1, A, SEOUL)
  - (2, B, NULL)

2) RIGHT JOIN 부분

- T2 기준으로 모두 살림.
- 결과:
  - (1, A, SEOUL)
  - (NULL, NULL, BUSAN)  
    - ID=3 은 T1에 없기 때문에 T1.ID, NAME 은 NULL, LOC 는 BUSAN.

3) 두 결과를 UNION (중복 제거) 하면:

- (1, A, SEOUL)
- (2, B, NULL)
- (NULL, NULL, BUSAN)

여기서 시험 포인트:

- OUTER JOIN 문제를 풀 때는
  1. 어느 테이블이 기준(LEFT/RIGHT/FULL)인가,
  2. JOIN 조건이 무엇인가,
  3. **SELECT 절에서 어느 테이블의 컬럼을 뽑고 있는가**
- 특히 기준 테이블이라도 SELECT 에서 반대쪽 테이블 컬럼을 뽑으면 NULL 이 나올 수 있다.

---

# 📌 6. 정규화: 1NF, 2NF, 3NF, BCNF 개념 포인트

## 6-1. 1정규형(1NF)

- 속성의 **원자성(Atomicity)** 을 보장한다.
- 각 칸에는 더 이상 나눌 수 없는 값 1개만 들어가야 한다.
- 반복 그룹, 다중 값 속성이 있으면 1NF 위반.

## 6-2. 2정규형(2NF)

- 이미 1NF를 만족해야 하며,
- **부분 함수 종속**을 제거한다.
- 기본 키가 복합키인 경우,
  - 어떤 속성이 키의 일부에만 종속하면 부분 함수 종속이다.
  - 이런 속성들은 별도 테이블로 분해.

## 6-3. 3정규형(3NF)

- 이미 2NF를 만족해야 하며,
- **이행 함수 종속**을 제거한다.
- $X \to Y$, $Y \to Z$ 가 있을 때 $X \to Z$ 로 인해
  - 기본키 아닌 일반 속성끼리 종속 관계가 생기면 이행 종속이다.
- 3NF의 형식적 조건:
  - 모든 $X \to Y$ 에 대해, 아래 중 하나를 만족해야 한다.
    1. $X \to Y$ 가 trivial (즉 $Y \subseteq X$),
    2. $X$ 가 후보키,
    3. $Y$ 가 프라임 속성(어떤 후보키에 속한 속성).

여기서 중요한 포인트:

- 3NF는 **예외**를 허용한다.
- $X$ 가 후보키가 아니어도, $Y$ 가 프라임 속성이면 3NF 조건을 통과할 수 있다.
- 따라서 3NF 에서는 “후보키가 아닌 결정자”가 일정 조건 하에 **존재할 수 있다**.

## 6-4. BCNF (Boyce-Codd Normal Form)

- 보다 강한 정규형.
- 조건:
  - 모든 함수적 종속 $X \to Y$ 에서, **$X$ 는 반드시 슈퍼키**여야 한다.
- 즉:
  - 후보키, 또는 후보키에 불필요한 속성이 더해진 상위키(superkey)만 결정자가 될 수 있다.
  - 3NF 처럼 “$Y$ 가 프라임 속성이면 예외 허용” 같은 조건이 없다.

### 6-5. 3NF와 BCNF의 차이 핵심 정리

- 3NF:
  - $X$ 가 후보키가 아니어도, $Y$ 가 프라임 속성이면 허용.
  - 즉, “비후보키 결정자”가 일부 케이스에서 존재할 수 있다.
- BCNF:
  - 모든 결정자 $X$ 가 슈퍼키여야 한다.
  - 후보키가 아닌 결정자는 **무조건 허용되지 않는다**.

그래서:

- “3NF는 비후보키가 결정자가 되는 것을 완전히 막는다”는 말은 **틀린 요약**이다.
- 3NF는 프라임 속성 예외 때문에 **일부** 비후보키 결정자를 허용한다.
- BCNF는 그 예외까지 제거해서, 결정자는 반드시 슈퍼키만 되도록 강제한다.

---

# 📌 7. DDL, DEFAULT, 제약조건, 컬럼 길이

## 7-1. ALTER TABLE ADD 와 DEFAULT, CONSTRAINT

예:

```sql
ALTER TABLE EMP
  ADD GENDER CHAR(1) DEFAULT 'M' NOT NULL;
```

- `DEFAULT 'M'`:
  - 컬럼의 기본값 속성이다.
  - INSERT 시 GENDER 값을 생략하면 'M'이 자동 입력된다.
- `NOT NULL`:
  - 제약조건이지만 별도 이름 없이 바로 사용 가능하다.
- `CONSTRAINT` 키워드는
  - PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK, (이름을 붙인) NOT NULL 등에 사용된다.
- 중요한 점:
  - DEFAULT 자체를 `CONSTRAINT` 로 정의하지 않는다.
  - DEFAULT는 컬럼의 속성이지, 제약조건의 일종으로 보지 않는다.

## 7-2. 문자 길이 제약과 PK/FK

예시 정의:

```sql
CREATE TABLE DEPT (
  DEPT_ID   VARCHAR2(10),
  DEPT_NAME VARCHAR2(50),
  CONSTRAINT PK_DEPT PRIMARY KEY (DEPT_ID)
);

CREATE TABLE EMP (
  EMP_ID   VARCHAR2(10),
  EMP_NAME VARCHAR2(10),
  DEPT_ID  VARCHAR2(10),
  CONSTRAINT PK_EMP PRIMARY KEY (EMP_ID),
  CONSTRAINT FK_EMP_DEPT FOREIGN KEY (DEPT_ID)
    REFERENCES DEPT(DEPT_ID)
);
```

중요 포인트:

1. PK와 FK 컬럼의 타입과 길이는 **반드시 일치**해야 한다.
   - 둘 다 `VARCHAR2(10)` 으로 맞춰져 있어야 함.
2. `VARCHAR2(10)` 이면 최대 10글자까지 저장 가능.
   - 11글자를 넣으면 길이 초과 에러 발생.
3. FK 체크 순서:
   - 길이/타입이 먼저 검사된다.
   - 그 다음에 부모 테이블에 값이 존재하는지 확인한다.

---

# 📌 8. MERGE 문과 WHEN MATCHED / WHEN NOT MATCHED

MERGE 기본 구조:

```sql
MERGE INTO 대상테이블 T
USING 소스테이블 S
ON (T.key = S.key)
WHEN MATCHED THEN
    UPDATE SET ...
WHEN NOT MATCHED THEN
    INSERT (col1, col2, ...)
    VALUES (...);
```

- `WHEN MATCHED THEN`:
  - ON 조건을 만족하는 행이 **이미 존재**할 때 실행된다 → UPDATE, 필요하면 DELETE 조건도 포함 가능.
- `WHEN NOT MATCHED THEN`:
  - ON 조건에 맞는 행이 **존재하지 않을 때** 실행된다 → INSERT.

시험에서 주로 묻는 것:

- MERGE 구조의 순서와 각 절의 역할.
- MATCHED / NOT MATCHED 의 의미 구분.

---

# 📌 9. WHERE 절과 SELECT 별칭, ORDER BY 기준

## 9-1. WHERE 절에서는 SELECT 별칭 사용 불가

예:

```sql
SELECT col1 AS c1
FROM   tab1
WHERE  c1 = 10;   -- 오류
```

이유:

- SELECT 절은 **WHERE 이후**에 실행된다.
- WHERE 절 평가 시점에는 `c1` 이라는 별칭이 아직 존재하지 않는다.
- 따라서 WHERE 에서는 **원래 컬럼명**만 사용해야 한다.

반면, ORDER BY 에서는 별칭 사용 가능:

```sql
SELECT col1 AS c1
FROM   tab1
ORDER BY c1;      -- 정상
```

- ORDER BY 는 SELECT 결과가 만들어진 후 실행된다.
- 이때는 `c1` 이라는 별칭이 이미 존재하므로 사용 가능하다.

## 9-2. SELECT 에 없는 컬럼도 ORDER BY 기준이 될 수 있음

예:

```sql
SELECT col1, col2
FROM   tab1
ORDER BY col3;
```

- `col3` 가 **테이블에 존재**한다면, SELECT 목록에 없어도 정렬 기준으로 사용할 수 있다.
- 정렬은 실제 테이블의 컬럼을 참조하기 때문.

50번 문제에서의 핵심:

1. WHERE 절에는 SELECT 별칭 사용 불가.
2. ORDER BY 절은
   - 컬럼 이름,
   - 컬럼 번호,
   - SELECT 별칭
   중 하나를 사용할 수 있고,
   - **SELECT 목록에 없는 컬럼이라도 테이블에 존재하면 기준이 될 수 있다.**

---

