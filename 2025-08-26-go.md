# ğŸ“Œ 0. goì–¸ì–´ ë„¤íŠ¸ì›Œí‚¹
### ğŸ“Œ 0-1. ë„¤íŠ¸ì›Œí‚¹ ê¸°ì´ˆ
- goì–¸ì–´ëŠ” ê·¸ ìì²´ë¡œ HTTP ì„œë²„ ê¸°ëŠ¥ì„ í¬í•¨í•˜ê³  ìˆë‹¤.
- *http.Request : ë“¤ì–´ì˜¨ ìš”ì²­ ì „ì²´(ë©”ì„œë“œ, URL, í—¤ë”, ë°”ë”” ë“±)ë¥¼ ë‹´ì€ êµ¬ì¡°ì²´ í¬ì¸í„°ë¡œ ë©”ëª¨ë¦¬ì— ì €ì¥ëœ ìš”ì²­ êµ¬ì¡°ì²´ì— ì ‘ê·¼í•  ìˆ˜ ìˆë„ë¡í•´ì¤€ë‹¤.
- http.ResponseWriter : ì‘ë‹µì„ ì“°ëŠ” ì¶œë ¥ í†µë¡œë¡œ io.Writerë¥¼ ë§Œì¡±í•˜ë¯€ë¡œ fmt.Fprint(w, ...)ì²˜ëŸ¼ ë°”ë¡œ ì“¸ ìˆ˜ ìˆë‹¤.
- io.Writerë¥¼ ë§Œì¡±í•œë‹¤ëŠ” ë§ì€ io.Writer ì¸í„°í˜ì´ìŠ¤ì˜ ì¡°ê±´ì¸ Write ë©”ì„œë“œ ë³´ìœ ë¥¼ ë§Œì¡±í•œë‹¤ëŠ” ì˜ë¯¸ì´ë‹¤.
- fmt.FprintëŠ” ì²«ë²ˆì§¸ ì¸ìë¡œ io.Writer ì¸í„°í˜ì´ìŠ¤ë¥¼ ìš”êµ¬í•˜ë©° ì´ io.Writer ì¸í„°í˜ì´ìŠ¤ì™€ ë¬¸êµ¬ë¥¼ ì£¼ë©´ í•´ë‹¹ ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ê¸€ì„ ì¨ì¤€ë‹¤.
- http.HandleFunc("/", handler)ë¥¼ í†µí•´ ê²½ë¡œ íŒ¨í„´ê³¼ í•¸ë“¤ëŸ¬ í•¨ìˆ˜ë¥¼ ê¸°ë³¸ ë¼ìš°í„°ì— ë“±ë¡í•œë‹¤. í•´ë‹¹ ê²½ë¡œë¡œ ìš”ì²­ì´ ì˜¤ë©´ ì´ í•¸ë“¤ëŸ¬ í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ê²Œ ëœë‹¤.
- log.Fatal(http.ListenAndServe(":8080", nil))ì—ì„œ log.Fatalì€ ì¸ìì˜ í•¨ìˆ˜ê°€ ì—ëŸ¬ë¥¼ ë°˜í™˜í•˜ë©´ ê·¸ ë‚´ìš©ì„ ë¡œê·¸ë¡œ ì¶œë ¥í•˜ê³  í”„ë¡œì„¸ìŠ¤ë¥¼ ì¢…ë£Œí•˜ëŠ” ì—­í• ì„ í•œë‹¤.
- http.ListenAndServe(":8080", nil)ì€ í¬íŠ¸ë²ˆí˜¸ì™€ ë¼ìš°í„°ë¥¼ ì—°ê²°í•˜ëŠ”ê±´ë° nilì€ ê¸°ë³¸ ë¼ìš°í„°ì´ë‹¤. ì´ ì˜ë¯¸ëŠ” ëª¨ë“  ë„¤íŠ¸ì›Œí¬ ì¸í„°í˜ì´ìŠ¤ë¥¼ 8080í¬íŠ¸ì— ì—°ê²° ì¦‰ ëª¨ë“  ë„¤íŠ¸ì›Œí¬ ìš”ì²­ì„ 8080í¬íŠ¸ë¡œ ë°›ê² ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤.
```go
import (
"fmt"
"log"
"net/http"
)
// 1. ìš”ì²­ì„ ì²˜ë¦¬í•  í•¸ë“¤ëŸ¬ í•¨ìˆ˜ ì •ì˜
func handler(w http.ResponseWriter, r *http.Request) {
    // 2. ResponseWriterì— ì‘ë‹µ ë‚´ìš©ì„ ì”€
    fmt.Fprint(w, "Hello, World!")
}

func main() {
    // 3. "/" ê²½ë¡œì™€ í•¸ë“¤ëŸ¬ í•¨ìˆ˜ë¥¼ ë§¤í•‘
    http.HandleFunc("/", handler)
    fmt.Println("Server starting on port 8080...")
    // 4. 8080 í¬íŠ¸ì—ì„œ ì„œë²„ë¥¼ ì‹œì‘
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

### ğŸ“Œ 0-2. getìš”ì²­í•˜ê¸°
- url := "https://jsonplaceholder.typicode.com/todos/1"ì´ëŠ” í…ŒìŠ¤íŠ¸ìš© JSON apiì£¼ì†Œì´ê³  JSONì„ ë°˜í™˜í•œë‹¤.
- http.Get(url) : í•´ë‹¹ URLë¡œ GET ìš”ì²­ì„ ë³´ë‚¸ë‹¤.
- defer resp.Body.Close() ì´ëŠ” ë©”ëª¨ë¦¬, ì†Œì¼“ ëˆ„ìˆ˜ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ ì‚¬ìš©ì´ ëã„´ë©´ ë„¤íŠ¸ì›Œí¬ë¥¼ ë‹«ëŠ” ì—­í• ì„ í•œë‹¤. resp.BodyëŠ” ë„¤íŠ¸ì›Œí¬ ì—°ê²°ê³¼ ê´€ë ¨ëœ ë¦¬ì†ŒìŠ¤ì´ë‹¤.
- body, err := io.ReadAll(resp.Body): resp.BodyëŠ” ìŠ¤íŠ¸ë¦¼ì´ê¸° ë•Œë¬¸ì— ë°”ë¡œ ë¬¸ìì—´ì²˜ëŸ¼ ì“¸ ìˆ˜ ì—†ê³  io.ReadAllì„ ì¨ì„œ í•œ ë²ˆì— ë‹¤ ì½ì–´ì„œ []byteë¡œ ë³€í™˜í•œë‹¤.
- fmt.Println(string(body))ì´ë ‡ê²Œ ë°”ì´íŠ¸ ë°°ì—´ì„ stringìœ¼ë¡œ ë³€í™˜í•˜ì—¬ ë¬¸ìì—´ë¡œ ì¶œë ¥í•œë‹¤.
```go
import (
    "fmt"
    "io"
    "log"
    "net/http"
)
func main() {
    url := "https://jsonplaceholder.typicode.com/todos/1"

    // 1. http.Get í•¨ìˆ˜ë¡œ GET ìš”ì²­ ì „ì†¡
    resp, err := http.Get(url)
    if err != nil {
        log.Fatalf("Error fetching URL: %v", err)
    }

    // 2. í•¨ìˆ˜ ì¢…ë£Œ ì‹œì ì— ì‘ë‹µ ë³¸ë¬¸ì„ ë‹«ë„ë¡ ì˜ˆì•½
    defer resp.Body.Close()

    // 3. ì‘ë‹µ ë³¸ë¬¸ì„ ëª¨ë‘ ì½ìŒ
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        log.Fatalf("Error reading response body: %v", err)
    }

    // 4. ì½ì€ ë³¸ë¬¸ì„ ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ì—¬ ì¶œë ¥
    fmt.Println(string(body))
}
```

### ğŸ“Œ 0-3. post ìš”ì²­í•˜ê¸°
- formData := url.Values{}ë¡œ ë¹ˆ formDataë¥¼ ë§Œë“¤ê³  ì•ˆì— formData.Setìœ¼ë¡œ í‚¤:ê°’ ìŒì„ ì €ì¥í•œë‹¤.
- http.PostForm(postUrl, formData) í•¨ìˆ˜ë¥¼ í†µí•´ post ìš”ì²­ì„ ë³´ë‚¸ë‹¤.
- ì´í•˜ ê³¼ì •ì€ getê³¼ ê°™ë‹¤.
```go
func main() {
    postUrl := "https://httpbin.org/post"

    // 1. ì „ì†¡í•  FormData ë°ì´í„° ìƒì„±
    formData := url.Values{}
    formData.Set("name", "Gemini")
    formData.Set("level", "100")

    // 2. http.PostForm í•¨ìˆ˜ë¡œ POST ìš”ì²­
    // ì´ í•¨ìˆ˜ëŠ” ìë™ìœ¼ë¡œ Content-Typeì„ application/x-www-form-urlencoded ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.
    resp, err := http.PostForm(postUrl, formData)

    if err != nil {
        log.Fatalf("Error making POST request: %v", err)
    }

    defer resp.Body.Close()

    // 3. ì‘ë‹µ ë³¸ë¬¸ ì½ê¸° ë° ì¶œë ¥
    body, err := io.ReadAll(resp.Body)

    if err != nil {
        log.Fatalf("Error reading response body: %v", err)
    }

    fmt.Println(string(body))
}
```

### ğŸ“Œ 0-4. rest api ì„œë²„ êµ¬ì¶•
- ì—¬ê¸°ì„  ë°ì´í„° ë² ì´ìŠ¤ ëŒ€ì‹  ë©”ëª¨ë¦¬ì— êµ¬ì¡°ì²´ë¥¼ ë§Œë“¤ì–´ë†“ê³  í¬ì¸í„°ë¥¼ ì‚¬ìš©í•´ì„œ ì´ êµ¬ì¡°ì²´ ë‚´ë¶€ì˜ ë‚´ìš©ì„ ê³„ì† ìˆ˜ì •í•˜ëŠ” ì‹ìœ¼ë¡œ ì„œë²„ë¥¼ êµ¬í˜„í•˜ì˜€ë‹¤.
- todosHandlerë¥¼ í†µí•´ ë“¤ì–´ì˜¨ ìš”ì²­ ì •ë³´ì˜ í¬ì¸í„°ì—ì„œ (r *http.Request) ìš”ì²­ë°©ì‹ì´ get, post, put, delete ì¤‘ ì–´ë””ì— í•´ë‹¹ë˜ëŠëƒì— ë”°ë¼ ë¶„ê¸°ë˜ì–´ì•¼í•œë‹¤.
- ìš”ì²­ì—ì„œ íŒŒë¼ë¯¸í„°ë¥¼ ë¶„ë¦¬í•˜ê¸° ìœ„í•´  idStr := strings.TrimPrefix(r.URL.Path, "/todos/")ë¥¼ í™œìš©í•´ì„œ íŒŒë¼ë¯¸í„°ë¥¼ ë¶„ë¦¬í•˜ê³  id, err := strconv.Atoi(idStr)ë¡œ ì´ë¥¼ ì •ìˆ˜ë¡œ ë§Œë“¤ì–´ì„œ idê°’ì„ ë½‘ì•„ë‚¸ë‹¤.
- ê·¸ë¦¬ê³  postìš”ì²­ìœ¼ë¡œ ë“¤ì–´ì˜¨ ë°”ë””ì— ë“¤ì–´ìˆëŠ” í¼ ë°ì´í„°ëŠ” r.PostFormValueë¥¼ í™œìš©í•˜ì—¬ êº¼ë‚¼ ìˆ˜ ìˆë‹¤.
- ì´ë¥¼ í†µí•´ êµ¬ì¡°ì²´ë¥¼ ìˆ˜ì •í•˜ê³  ìˆ˜ì • ê²°ê³¼ë¥¼ ë°˜í™˜í•˜ëŠ” í”„ë¡œê·¸ë¨ì´ë‹¤.
- w.Header().Set("Content-Type", "application/json")
- w.WriteHeader(http.StatusOK)
- ìœ„ ë‘ê°œë¥¼ í†µí•´ ì‘ë‹µì˜ ë‚´ìš©ì„ êµ¬ì„±í•˜ê³  ì‘ë‹µì„ ë³´ë‚´ë©´ ê¸°ì¡´ì— javaì—ì„œ í•˜ë˜ ê²ƒì²˜ëŸ¼ì˜ ì•½ì‹ rest api ì„œë²„ë¥¼ ë§Œë“¤ ìˆ˜ ìˆê²Œ ëœë‹¤.
```go
import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "strconv" // <-- ì¶”ê°€
    "strings" // <-- ì¶”ê°€
)

/** 1. Todo ìì›ì„ ë‚˜íƒ€ë‚´ëŠ” êµ¬ì¡°ì²´ ì •ì˜ */
type Todo struct {
    ID int `json:"id"`
    Title string `json:"title"`
    Completed bool `json:"completed"`
}

/** 2. ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ëŒ€ì‹ í•  ì¸ë©”ëª¨ë¦¬ ìŠ¬ë¼ì´ìŠ¤ */
var todos = []Todo{
    {ID: 1, Title: "Learn Go", Completed: false},
    {ID: 2, Title: "Build REST API", Completed: false},
}

/** 3. /todos ê²½ë¡œì˜ ìš”ì²­ì„ ì²˜ë¦¬í•˜ëŠ” í•¸ë“¤ëŸ¬ */
func todosHandler(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
        /** 4. GET ìš”ì²­ ì²˜ë¦¬ */
        case http.MethodGet:
        // ... (ì´ì „ ì‹¤ìŠµê³¼ ë™ì¼)

        /** 6. POST ìš”ì²­ ì²˜ë¦¬ */
        case http.MethodPost:
        // ... (ì´ì „ ì‹¤ìŠµê³¼ ë™ì¼)

        /** 7. PUT ìš”ì²­ ì²˜ë¦¬ */
        case http.MethodPut:
            // URL ê²½ë¡œì—ì„œ ID ì¶”ì¶œ
            idStr := strings.TrimPrefix(r.URL.Path, "/todos/")
            id, err := strconv.Atoi(idStr)

            if err != nil {
                http.Error(w, "Invalid ID", http.StatusBadRequest)
                return
            }

            // ìš”ì²­ íŒŒë¼ë¯¸í„°ì¸ title, completed ì¶”ì¶œ
            title := r.PostFormValue("title")
            completed := r.PostFormValue("completed") == "true"

            for i := range todos {
                if todos[i].ID == id {
                    todos[i].Title = title
                    todos[i].Completed = completed

                    // ì„±ê³µ ì‘ë‹µ ì „ì†¡
                    w.Header().Set("Content-Type", "application/json")
                    w.WriteHeader(http.StatusOK)
                    json.NewEncoder(w).Encode(todos[i])
                    return
                }
            }
            http.Error(w, "Todo not found", http.StatusNotFound)

        /** 8. DELETE ìš”ì²­ ì²˜ë¦¬ (ì‚­ì œ) */
        case http.MethodDelete:
            // URL ê²½ë¡œì—ì„œ ID ì¶”ì¶œ
            idStr := strings.TrimPrefix(r.URL.Path, "/todos/")
            id, err := strconv.Atoi(idStr)
            if err != nil {
                http.Error(w, "Invalid ID", http.StatusBadRequest)
                return
            }

            for i, t := range todos {
                if t.ID == id {
                todos = append(todos[:i], todos[i+1:]...)

                // ì„±ê³µ ì‘ë‹µ ì „ì†¡
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusOK)
                return
                }
            }
            http.Error(w, "Todo not found", http.StatusNotFound)

        default:
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
    }
}
```

# ğŸ“Œ 1. ë¸”ë¡ì²´ì¸ì— ê´€í•˜ì—¬
### ğŸ“Œ 1-1. ê°„ì´ ë¸”ë¡ì²´ì¸ ì„¤ê³„
- ì‹œê° + ì´ì „í•´ì‹œ = ë‹¤ìŒí•´ì‹œ => í•œ ìŠ¬ë¼ì´ìŠ¤ì— ì—°ë‹¬ì•„ì„œ ì €ì¥
- ë¸”ë¡ êµ¬ì¡°ì²´ë¥¼ ìš°ì„  ì •ì˜í•´ì•¼ í•˜ëŠ”ë° ì´ëŠ” ë§Œë“ ì‹œê°„ê³¼ ë°ì´í„° ê·¸ë¦¬ê³  ì´ì „ë¸”ë¡í•´ì‹œ, ì´í›„ë¸”ë¡í•´ì‹œë¥¼ ë°”ì´íŠ¸ ë°°ì—´ë¡œ ë°›ëŠ”ë‹¤.
- ë¸”ë¡ì„ í•´ì‹œí™”í•˜ëŠ” í•¨ìˆ˜ì¸ SetHash()ì—ì„œ ìš°ì„  strconv.FormatIntë¥¼ í†µí•´ ë¸”ë¡ì˜ ìƒì„±ì‹œê°„ì„ ë¬¸ìì—´ ë°”ì´íŠ¸ë°°ì—´ ë³€í™˜í•œë‹¤. ì´í›„ append(b.PrevBlockHash, append([]byte(b.Data), timestamp...)...)ë¥¼ í†µì— í•´ë‹¹ ë¸”ë¡ì˜ data, ì‹œê°„, ì´ì „ ë¸”ë¡ì˜ í•´ì‹œê°’ì„ ë‹´ì•„ì„œ í•´ì‹œë¡œ ë³€í™˜í•œ í›„ ì´ë¥¼ í•´ë‹¹ ë¸”ë¡ í˜„ì¬ í•´ì‹œê°’ìœ¼ë¡œ ì €ì¥í•œë‹¤.
- ìƒˆë¡œìš´ ë¸”ë¡ ìƒì„± í•¨ìˆ˜ì¸ NewBlockì€ ë°ì´í„°ì™€ ì´ì „ ë¸”ë¡ì˜ í•´ì‹œë¥¼ ë°›ì•„ì„œ í˜„ì¬ì‹œê°„ê³¼ í•¨ê»˜ ìƒˆë¡œìš´ ë¸”ë¡ì„ ë§Œë“¤ê³  í•´ì‹œê°’ê¹Œì§€ ìƒì„±í•´ì„œ ìƒˆë¡œ ì €ì¥í•œë‹¤.
- NewBlockchainì€ ë¸”ë¡ì²´ì¸ì´ë¼ëŠ” blockì˜ í¬ì¸í„° ìŠ¬ë¼ì´ìŠ¤ë¥¼ ì²«ì§¸ë¸”ë¡ì¸ ì œë„¤ì‹œìŠ¤ë¸”ë¡ì„ í¬í•¨í•˜ì—¬ ìƒì„±í•œë‹¤.
- 
```go
import (
    "crypto/sha256"
    "encoding/hex"
    "fmt"
    "strconv"
    "time"
)

/** 1. ë¸”ë¡ê³¼ ì²´ì¸ì„ ìœ„í•œ êµ¬ì¡°ì²´ ì •ì˜í•˜ê¸° */
type Block struct {
    Timestamp int64 // ë§Œë“  ì‹œê°„
    Data string // ë‹´ì„ ë°ì´í„°
    PrevBlockHash []byte // ì´ì „ ë¸”ë¡ í•´ì‹œ
    Hash []byte // í˜„ì¬ ë¸”ë¡ í•´ì‹œ
}

// ë¸”ë¡ì²´ì¸ êµ¬ì¡°ì²´ ì •ì˜
type Blockchain struct {
    blocks []*Block
}

// ë¸”ë¡ì˜ í•´ì‹œ ê³„ì‚° í•¨ìˆ˜
func (b *Block) SetHash() {
    timestamp := []byte(strconv.FormatInt(b.Timestamp, 10))
    headers := append(b.PrevBlockHash, append([]byte(b.Data), timestamp...)...)
    hash := sha256.Sum256(headers)
    b.Hash = hash[:]
}

// ìƒˆ ë¸”ë¡ ìƒì„± í•¨ìˆ˜
func NewBlock(data string, prevBlockHash []byte) *Block {
    block := &Block{time.Now().Unix(), data, prevBlockHash, []byte{}}
    block.SetHash()
    return block
}

// ë¸”ë¡ì²´ì¸ ìƒì„± (ì œë„¤ì‹œìŠ¤ ë¸”ë¡ í¬í•¨)
func NewBlockchain() *Blockchain {
    genesisBlock := NewBlock("Genesis Block", []byte{})
    return &Blockchain{[]*Block{genesisBlock}}
}

/** 2. ë¸”ë¡ ì¶”ê°€í•˜ê¸° */
func (bc *Blockchain) AddBlock(data string) {
    prevBlock := bc.blocks[len(bc.blocks)-1]
    newBlock := NewBlock(data, prevBlock.Hash)
    bc.blocks = append(bc.blocks, newBlock)
}

/** 3. ë¸”ë¡ì²´ì¸ ê²€ì¦í•˜ê¸° */
func (bc *Blockchain) IsChainValid() bool {
    for i := 1; i < len(bc.blocks); i++ {
        currentBlock := bc.blocks[i]
        prevBlock := bc.blocks[i-1]
        tempHash := currentBlock.Hash
        currentBlock.SetHash()
        if string(currentBlock.Hash) != string(tempHash) {
            return false
        }
        currentBlock.Hash = tempHash
        if string(currentBlock.PrevBlockHash) != string(prevBlock.Hash) {
            return false
        }
    }

    return true
}

/******** main() *********/
func main() {
    // ìƒˆ ë¸”ë¡ì²´ì¸ ìƒì„±
    bc := NewBlockchain()
    
    // ë¸”ë¡ ì¶”ê°€
    bc.AddBlock("Send 1 BTC to Alice")
    bc.AddBlock("Send 2 BTC to Bob")

    for _, block := range bc.blocks {
        fmt.Printf("Prev. hash: %s\n", hex.EncodeToString(block.PrevBlockHash))
        fmt.Printf("Time: %d\n", block.Timestamp)
        fmt.Printf("Data: %s\n", block.Data)
        fmt.Printf("Hash: %s\n", hex.EncodeToString(block.Hash))
        fmt.Println("----------------------------------")
    }

    // ì²´ì¸ ê²€ì¦
    if bc.IsChainValid() {
        fmt.Println("âœ… ë¸”ë¡ì²´ì¸ ë¬´ê²°ì„± ê²€ì¦ ì„±ê³µ!")
    } else {
        fmt.Println("âŒ ë¸”ë¡ì²´ì¸ ë¬´ê²°ì„± ê²€ì¦ ì‹¤íŒ¨!")
    }
}
```