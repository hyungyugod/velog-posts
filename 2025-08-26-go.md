# 📌 0. go언어 네트워킹
### 📌 0-1. 네트워킹 기초
- go언어는 그 자체로 HTTP 서버 기능을 포함하고 있다.
- *http.Request : 들어온 요청 전체(메서드, URL, 헤더, 바디 등)를 담은 구조체 포인터로 메모리에 저장된 요청 구조체에 접근할 수 있도록해준다.
- http.ResponseWriter : 응답을 쓰는 출력 통로로 io.Writer를 만족하므로 fmt.Fprint(w, ...)처럼 바로 쓸 수 있다.
- io.Writer를 만족한다는 말은 io.Writer 인터페이스의 조건인 Write 메서드 보유를 만족한다는 의미이다.
- fmt.Fprint는 첫번째 인자로 io.Writer 인터페이스를 요구하며 이 io.Writer 인터페이스와 문구를 주면 해당 도구를 사용하여 글을 써준다.
- http.HandleFunc("/", handler)를 통해 경로 패턴과 핸들러 함수를 기본 라우터에 등록한다. 해당 경로로 요청이 오면 이 핸들러 함수를 실행하게 된다.
- log.Fatal(http.ListenAndServe(":8080", nil))에서 log.Fatal은 인자의 함수가 에러를 반환하면 그 내용을 로그로 출력하고 프로세스를 종료하는 역할을 한다.
- http.ListenAndServe(":8080", nil)은 포트번호와 라우터를 연결하는건데 nil은 기본 라우터이다. 이 의미는 모든 네트워크 인터페이스를 8080포트에 연결 즉 모든 네트워크 요청을 8080포트로 받겠다는 것을 의미한다.
```go
import (
"fmt"
"log"
"net/http"
)
// 1. 요청을 처리할 핸들러 함수 정의
func handler(w http.ResponseWriter, r *http.Request) {
    // 2. ResponseWriter에 응답 내용을 씀
    fmt.Fprint(w, "Hello, World!")
}

func main() {
    // 3. "/" 경로와 핸들러 함수를 매핑
    http.HandleFunc("/", handler)
    fmt.Println("Server starting on port 8080...")
    // 4. 8080 포트에서 서버를 시작
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

### 📌 0-2. get요청하기
- url := "https://jsonplaceholder.typicode.com/todos/1"이는 테스트용 JSON api주소이고 JSON을 반환한다.
- http.Get(url) : 해당 URL로 GET 요청을 보낸다.
- defer resp.Body.Close() 이는 메모리, 소켓 누수를 방지하기 위해 사용이 끝ㄴ면 네트워크를 닫는 역할을 한다. resp.Body는 네트워크 연결과 관련된 리소스이다.
- body, err := io.ReadAll(resp.Body): resp.Body는 스트림이기 때문에 바로 문자열처럼 쓸 수 없고 io.ReadAll을 써서 한 번에 다 읽어서 []byte로 변환한다.
- fmt.Println(string(body))이렇게 바이트 배열을 string으로 변환하여 문자열로 출력한다.
```go
import (
    "fmt"
    "io"
    "log"
    "net/http"
)
func main() {
    url := "https://jsonplaceholder.typicode.com/todos/1"

    // 1. http.Get 함수로 GET 요청 전송
    resp, err := http.Get(url)
    if err != nil {
        log.Fatalf("Error fetching URL: %v", err)
    }

    // 2. 함수 종료 시점에 응답 본문을 닫도록 예약
    defer resp.Body.Close()

    // 3. 응답 본문을 모두 읽음
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        log.Fatalf("Error reading response body: %v", err)
    }

    // 4. 읽은 본문을 문자열로 변환하여 출력
    fmt.Println(string(body))
}
```

### 📌 0-3. post 요청하기
- formData := url.Values{}로 빈 formData를 만들고 안에 formData.Set으로 키:값 쌍을 저장한다.
- http.PostForm(postUrl, formData) 함수를 통해 post 요청을 보낸다.
- 이하 과정은 get과 같다.
```go
func main() {
    postUrl := "https://httpbin.org/post"

    // 1. 전송할 FormData 데이터 생성
    formData := url.Values{}
    formData.Set("name", "Gemini")
    formData.Set("level", "100")

    // 2. http.PostForm 함수로 POST 요청
    // 이 함수는 자동으로 Content-Type을 application/x-www-form-urlencoded 로 설정합니다.
    resp, err := http.PostForm(postUrl, formData)

    if err != nil {
        log.Fatalf("Error making POST request: %v", err)
    }

    defer resp.Body.Close()

    // 3. 응답 본문 읽기 및 출력
    body, err := io.ReadAll(resp.Body)

    if err != nil {
        log.Fatalf("Error reading response body: %v", err)
    }

    fmt.Println(string(body))
}
```

### 📌 0-4. rest api 서버 구축
- 여기선 데이터 베이스 대신 메모리에 구조체를 만들어놓고 포인터를 사용해서 이 구조체 내부의 내용을 계속 수정하는 식으로 서버를 구현하였다.
- todosHandler를 통해 들어온 요청 정보의 포인터에서 (r *http.Request) 요청방식이 get, post, put, delete 중 어디에 해당되느냐에 따라 분기되어야한다.
- 요청에서 파라미터를 분리하기 위해  idStr := strings.TrimPrefix(r.URL.Path, "/todos/")를 활용해서 파라미터를 분리하고 id, err := strconv.Atoi(idStr)로 이를 정수로 만들어서 id값을 뽑아낸다.
- 그리고 post요청으로 들어온 바디에 들어있는 폼 데이터는 r.PostFormValue를 활용하여 꺼낼 수 있다.
- 이를 통해 구조체를 수정하고 수정 결과를 반환하는 프로그램이다.
- w.Header().Set("Content-Type", "application/json")
- w.WriteHeader(http.StatusOK)
- 위 두개를 통해 응답의 내용을 구성하고 응답을 보내면 기존에 java에서 하던 것처럼의 약식 rest api 서버를 만들 수 있게 된다.
```go
import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "strconv" // <-- 추가
    "strings" // <-- 추가
)

/** 1. Todo 자원을 나타내는 구조체 정의 */
type Todo struct {
    ID int `json:"id"`
    Title string `json:"title"`
    Completed bool `json:"completed"`
}

/** 2. 데이터베이스를 대신할 인메모리 슬라이스 */
var todos = []Todo{
    {ID: 1, Title: "Learn Go", Completed: false},
    {ID: 2, Title: "Build REST API", Completed: false},
}

/** 3. /todos 경로의 요청을 처리하는 핸들러 */
func todosHandler(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
        /** 4. GET 요청 처리 */
        case http.MethodGet:
        // ... (이전 실습과 동일)

        /** 6. POST 요청 처리 */
        case http.MethodPost:
        // ... (이전 실습과 동일)

        /** 7. PUT 요청 처리 */
        case http.MethodPut:
            // URL 경로에서 ID 추출
            idStr := strings.TrimPrefix(r.URL.Path, "/todos/")
            id, err := strconv.Atoi(idStr)

            if err != nil {
                http.Error(w, "Invalid ID", http.StatusBadRequest)
                return
            }

            // 요청 파라미터인 title, completed 추출
            title := r.PostFormValue("title")
            completed := r.PostFormValue("completed") == "true"

            for i := range todos {
                if todos[i].ID == id {
                    todos[i].Title = title
                    todos[i].Completed = completed

                    // 성공 응답 전송
                    w.Header().Set("Content-Type", "application/json")
                    w.WriteHeader(http.StatusOK)
                    json.NewEncoder(w).Encode(todos[i])
                    return
                }
            }
            http.Error(w, "Todo not found", http.StatusNotFound)

        /** 8. DELETE 요청 처리 (삭제) */
        case http.MethodDelete:
            // URL 경로에서 ID 추출
            idStr := strings.TrimPrefix(r.URL.Path, "/todos/")
            id, err := strconv.Atoi(idStr)
            if err != nil {
                http.Error(w, "Invalid ID", http.StatusBadRequest)
                return
            }

            for i, t := range todos {
                if t.ID == id {
                todos = append(todos[:i], todos[i+1:]...)

                // 성공 응답 전송
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusOK)
                return
                }
            }
            http.Error(w, "Todo not found", http.StatusNotFound)

        default:
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
    }
}
```

# 📌 1. 블록체인에 관하여
### 📌 1-1. 간이 블록체인 설계
- 시각 + 이전해시 = 다음해시 => 한 슬라이스에 연달아서 저장
- 블록 구조체를 우선 정의해야 하는데 이는 만든시간과 데이터 그리고 이전블록해시, 이후블록해시를 바이트 배열로 받는다.
- 블록을 해시화하는 함수인 SetHash()에서 우선 strconv.FormatInt를 통해 블록의 생성시간을 문자열 바이트배열 변환한다. 이후 append(b.PrevBlockHash, append([]byte(b.Data), timestamp...)...)를 통에 해당 블록의 data, 시간, 이전 블록의 해시값을 담아서 해시로 변환한 후 이를 해당 블록 현재 해시값으로 저장한다.
- 새로운 블록 생성 함수인 NewBlock은 데이터와 이전 블록의 해시를 받아서 현재시간과 함께 새로운 블록을 만들고 해시값까지 생성해서 새로 저장한다.
- NewBlockchain은 블록체인이라는 block의 포인터 슬라이스를 첫째블록인 제네시스블록을 포함하여 생성한다.
- 
```go
import (
    "crypto/sha256"
    "encoding/hex"
    "fmt"
    "strconv"
    "time"
)

/** 1. 블록과 체인을 위한 구조체 정의하기 */
type Block struct {
    Timestamp int64 // 만든 시간
    Data string // 담을 데이터
    PrevBlockHash []byte // 이전 블록 해시
    Hash []byte // 현재 블록 해시
}

// 블록체인 구조체 정의
type Blockchain struct {
    blocks []*Block
}

// 블록의 해시 계산 함수
func (b *Block) SetHash() {
    timestamp := []byte(strconv.FormatInt(b.Timestamp, 10))
    headers := append(b.PrevBlockHash, append([]byte(b.Data), timestamp...)...)
    hash := sha256.Sum256(headers)
    b.Hash = hash[:]
}

// 새 블록 생성 함수
func NewBlock(data string, prevBlockHash []byte) *Block {
    block := &Block{time.Now().Unix(), data, prevBlockHash, []byte{}}
    block.SetHash()
    return block
}

// 블록체인 생성 (제네시스 블록 포함)
func NewBlockchain() *Blockchain {
    genesisBlock := NewBlock("Genesis Block", []byte{})
    return &Blockchain{[]*Block{genesisBlock}}
}

/** 2. 블록 추가하기 */
func (bc *Blockchain) AddBlock(data string) {
    prevBlock := bc.blocks[len(bc.blocks)-1]
    newBlock := NewBlock(data, prevBlock.Hash)
    bc.blocks = append(bc.blocks, newBlock)
}

/** 3. 블록체인 검증하기 */
func (bc *Blockchain) IsChainValid() bool {
    for i := 1; i < len(bc.blocks); i++ {
        currentBlock := bc.blocks[i]
        prevBlock := bc.blocks[i-1]
        tempHash := currentBlock.Hash
        currentBlock.SetHash()
        if string(currentBlock.Hash) != string(tempHash) {
            return false
        }
        currentBlock.Hash = tempHash
        if string(currentBlock.PrevBlockHash) != string(prevBlock.Hash) {
            return false
        }
    }

    return true
}

/******** main() *********/
func main() {
    // 새 블록체인 생성
    bc := NewBlockchain()
    
    // 블록 추가
    bc.AddBlock("Send 1 BTC to Alice")
    bc.AddBlock("Send 2 BTC to Bob")

    for _, block := range bc.blocks {
        fmt.Printf("Prev. hash: %s\n", hex.EncodeToString(block.PrevBlockHash))
        fmt.Printf("Time: %d\n", block.Timestamp)
        fmt.Printf("Data: %s\n", block.Data)
        fmt.Printf("Hash: %s\n", hex.EncodeToString(block.Hash))
        fmt.Println("----------------------------------")
    }

    // 체인 검증
    if bc.IsChainValid() {
        fmt.Println("✅ 블록체인 무결성 검증 성공!")
    } else {
        fmt.Println("❌ 블록체인 무결성 검증 실패!")
    }
}
```