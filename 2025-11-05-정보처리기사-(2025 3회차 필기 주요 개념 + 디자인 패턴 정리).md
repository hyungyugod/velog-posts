# ğŸ“Œ 1. ë„¤íŠ¸ì›Œí¬ Â· ë³´ì•ˆ
## 1-1. ì›ê²©ì ‘ì†Â·í†µì‹  í”„ë¡œí† ì½œÂ·ê³„ì¸µ
1) ì›ê²© í˜¸ìŠ¤íŠ¸ì— ì•ˆì „í•˜ê²Œ ë¡œê·¸ì¸Â·ëª…ë ¹ ì‹¤í–‰ì„ ì œê³µí•˜ëŠ” ì•”í˜¸í™”/ë¬´ê²°ì„±/ì¸ì¦ í”„ë¡œí† ì½œ(í¬íŠ¸ 22) â€“ **SSH (Secure Shell)**
2) ê°™ì€ ë¸Œë¡œë“œìºìŠ¤íŠ¸ ë„ë©”ì¸ì—ì„œ IPâ†’MACì„ ì§ˆì˜/ì‘ë‹µìœ¼ë¡œ í•´ì„ â€“ **ARP (Address Resolution Protocol)**
3) ë¸Œë¡œì»¤ ì¤‘ì‹¬ ë°œí–‰Â·êµ¬ë… ê²½ëŸ‰ ë©”ì‹œì§•(IoT, QoS 0/1/2) â€“ **MQTT (Message Queuing Telemetry Transport)**
4) ê²½ë¡œÂ·ë…¼ë¦¬ ì£¼ì†ŒÂ·ë¼ìš°íŒ… ë‹´ë‹¹ ê³„ì¸µ â€“ **OSI 7ê³„ì¸µ(ë„¤íŠ¸ì›Œí¬ ê³„ì¸µ) (OSI Layer 3, Network Layer)**

## 1-2. ê³µê²©Â·ìœ„í˜‘Â·ê¸°ë§Œ
5) ì¶œë°œì§€=ëª©ì ì§€ ìœ„ì¡° íŒ¨í‚·ìœ¼ë¡œ ìì› ê³ ê°ˆ ìœ ë°œ â€“ **LAND ê³µê²© (Local Area Network Denial attack)**
6) ë¶„ì‚°ëœ ëŒ€ëŸ‰ íŠ¸ë˜í”½ìœ¼ë¡œ ì„œë¹„ìŠ¤ ë¶ˆëŠ¥ â€“ **DDoS (Distributed Denial of Service)**
7) MAC í…Œì´ë¸” ì˜¤ì—¼ìœ¼ë¡œ ìŠ¤ìœ„ì¹˜ë¥¼ í—ˆë¸Œì²˜ëŸ¼ ë§Œë“¦ â€“ **ìŠ¤ìœ„ì¹˜ ì¬ë° (Switch MAC Table Flooding)**
8) ê³µê²©ì ìœ ì¸Â·ê´€ì°°ìš© ê¸°ë§Œ ì‹œìŠ¤í…œ â€“ **Honeypot (Honeypot)**

## 1-3. ì ‘ê·¼ í†µì œÂ·ë³´ì•ˆ ì†ì„±
9) ë°ëª¬ ì ‘ê·¼ì„ IP/ë„ë©”ì¸ ê¸°ì¤€ ì œì–´í•˜ëŠ” ë˜í•‘ ìœ í‹¸ â€“ **tcp wrapper (TCP Wrapper)**
10) ì‚¬ìš©ìê°€ ì£¼ì¥í•˜ëŠ” ì‹ ì›ì„ ì¦ëª… â€“ **ì¸ì¦ (Authentication)**
11) ë°ì´í„°ì˜ ë¹„ì¸ê°€ ë³€ê²½ ë°©ì§€/íƒì§€ â€“ **ë¬´ê²°ì„± (Integrity)**
12) ì •ë³´ì˜ ë¹„ì¸ê°€ ì—´ëŒ ë°©ì§€ â€“ **ê¸°ë°€ì„± (Confidentiality)**
13) ìš”êµ¬ ì‹œ ìì›ì˜ ì´ìš© ê°€ëŠ¥ì„± ë³´ì¥ â€“ **ê°€ìš©ì„± (Availability)**

# ğŸ“Œ 2. ì†Œí”„íŠ¸ì›¨ì–´ ê³µí•™ Â· í”„ë¡œì„¸ìŠ¤
## 2-1. ìƒëª…ì£¼ê¸°(í”„ë¡œì„¸ìŠ¤) ëª¨ë¸
1) ìš”êµ¬â†’ì„¤ê³„â†’êµ¬í˜„â†’ì‹œí—˜ ìˆœì°¨ ì§„í–‰ â€“ **Waterfall Model (Waterfall Model)**
2) ë°˜ë³µë§ˆë‹¤ ìœ„í—˜ ë¶„ì„Â·í”„ë¡œí† íƒ€ì´í•‘ â€“ **Spiral Model (Spiral Model)**
3) ì‹œì œí’ˆìœ¼ë¡œ ìš”êµ¬ í™•ì¸Â·ë¦¬ìŠ¤í¬ ì €ê° â€“ **Prototype Model (Prototype Model)**

## 2-2. ë¹„ìš©Â·ì¼ì • ì¶”ì •Â·ê´€ë¦¬
4) ê·œëª¨Â·ìœ í˜•ë³„ ìƒìˆ˜ë¡œ ë…¸ë ¥/ê¸°ê°„ ì‚°ì • â€“ **COCOMO (Constructive Cost Model)**
5) ë ˆì¼ë¦¬ ê³¡ì„  ê¸°ë°˜ ë…¸ë ¥/ì¼ì • ì¶”ì • â€“ **Putnam (SLIM/Putnam Model)**
6) ì‚¬ìš©ì ê¸°ëŠ¥ ìˆ˜ ê¸°ë°˜ ê·œëª¨ ì¸¡ì • â€“ **Function Point (Function Point Analysis)**
7) 3ì  ì¶”ì •Â·í™•ë¥  ê²½ë¡œ ì¼ì •ê¸°ë²• â€“ **PERT (Program Evaluation and Review Technique)**
8) ì½”ë“œ ë¼ì¸ ìˆ˜ ê¸°ë°˜ ì¶”ì • â€“ **LOC ê¸°ë²• (Lines of Code method)**
9) ìœ„í—˜ ì‹ë³„Â·ë¶„ì„Â·ëŒ€ì‘ â€“ **Risk Analysis (Risk Analysis)**

## 2-3. í’ˆì§ˆÂ·ìš”êµ¬ ê¸°ë²•
10) í˜•ì‹ì  ë™ë£Œ ê²€í†  â€“ **FTR (Formal Technical Review)**
11) ì‹¤í–‰ ì—†ì´ ì½ê¸°Â·ì²´í¬ë¦¬ìŠ¤íŠ¸ë¡œ ê²°í•¨ íƒì§€ â€“ **ì¸ìŠ¤í™ì…˜ (Inspection)**
12) 5ëŒ€ ê°€ì¹˜ì™€ ì§§ì€ ë°˜ë³µ ì‹¤ì²œ â€“ **XP (eXtreme Programming)**
13) ê³ ê° ê°€ì¹˜ ë‹¨ìœ„ì˜ ìš”êµ¬ ì¹´ë“œ â€“ **ì‚¬ìš©ì ìŠ¤í† ë¦¬ (User Story)**
14) ê¸°ìˆ /ì„¤ê³„ ë¶ˆí™•ì‹¤ì„± ê²€ì¦ ì‹¤í—˜ â€“ **ìŠ¤íŒŒì´í¬ (Spike)**
15) êµ¬ì¡°ì  ë…¼ë¦¬ í‘œí˜„ ì„¤ê³„ë„ â€“ **NS Chart (Nassiâ€“Shneiderman Chart)**

## 2-4. ëª¨ë“ˆì„± ì§€í‘œÂ·ê²½í—˜ì¹™
16) í•œ ëª¨ë“ˆì„ í˜¸ì¶œí•˜ëŠ” ìƒìœ„ ëª¨ë“ˆ ìˆ˜ â€“ **Fan-in (Fan-in)**
17) í•œ ëª¨ë“ˆì´ í˜¸ì¶œí•˜ëŠ” í•˜ìœ„ ëª¨ë“ˆ ìˆ˜ â€“ **Fan-out (Fan-out)**
18) ëª¨ë“ˆ ê°„ ì˜ì¡´ ê°•ë„ â€“ **ê²°í•©ë„ (Coupling)**
19) ëª¨ë“ˆ ë‚´ë¶€ ì±…ì„ ì§‘ì¤‘ë„ â€“ **ì‘ì§‘ë„ (Cohesion)**
20) ì†Œìˆ˜ ì›ì¸ì´ ë‹¤ìˆ˜ ê²°ê³¼ë¥¼ ë§Œë“ ë‹¤ëŠ” ê²½í—˜ì¹™ â€“ **Paretoì˜ ë²•ì¹™ (Pareto Principle, 80/20 rule)**

# ğŸ“Œ 3. ì„¤ê³„ íŒ¨í„´ Â· UML Â· UI
## 3-1. ìƒì„± íŒ¨í„´
1) ì „ì—­ ì¸ìŠ¤í„´ìŠ¤ í•˜ë‚˜ë§Œ ë³´ì¥ â€“ **Singleton (Singleton Pattern)**
2) ì›í˜• ê°ì²´ ë³µì œë¡œ ìƒì„± â€“ **Prototype (Prototype Pattern)**
3) ìƒì„± ì±…ì„ì„ ì„œë¸Œí´ë˜ìŠ¤ì— ìœ„ì„ â€“ **Factory Method (Factory Method Pattern)**

## 3-2. êµ¬ì¡° íŒ¨í„´
4) ì¶”ìƒê³¼ êµ¬í˜„ì˜ ë¶„ë¦¬ë¡œ ë…ë¦½ í™•ì¥ â€“ **Bridge (Bridge Pattern)**

## 3-3. UML í•µì‹¬ ê°œë…
5) êµ¬ì¡°/í–‰ë™/ì£¼í•´ ë“± UML ìš”ì†Œ â€“ **UML ì‚¬ë¬¼ (UML Things: Structural/Behavioral/Annotation)**

## 3-4. UI ìœ í˜•Â·ì‚°ì¶œë¬¼
6) ìì—° ë™ì‘ ê¸°ë°˜ ìƒí˜¸ì‘ìš© â€“ **NUI (Natural User Interface)**
7) ê·¸ë˜í”½ ìœ„ì ¯ ê¸°ë°˜ ì¸í„°í˜ì´ìŠ¤ â€“ **GUI (Graphical User Interface)**
8) í…ìŠ¤íŠ¸ ëª…ë ¹ ê¸°ë°˜ ì¸í„°í˜ì´ìŠ¤ â€“ **CLI (Command-Line Interface)**
9) ì‹¤ì œì™€ ìœ ì‚¬í•œ ì •ì  í™”ë©´ ê²¬ë³¸ â€“ **ëª©ì—… (Mockup)**
10) í™”ë©´ íë¦„/ì½˜í…ì¸  ì„¤ê³„ ë¬¸ì„œ â€“ **ìŠ¤í† ë¦¬ë³´ë“œ (Storyboard)**
11) ì‘ë™ ê°€ëŠ¥í•œ ì´ˆê¸° êµ¬í˜„ë¬¼ â€“ **í”„ë¡œí† íƒ€ì… (Prototype)**

# ğŸ“Œ 4. ë°ì´í„°ë² ì´ìŠ¤ Â· SQL Â· ëª¨ë¸ë§
## 4-1. ê¶Œí•œÂ·ê°ì²´
1) ê¶Œí•œ íšŒìˆ˜ â€“ **REVOKE (REVOKE)**
2) ê¶Œí•œ ë¶€ì—¬ â€“ **GRANT (GRANT)**
3) ë…¼ë¦¬ì  ê°€ìƒ í…Œì´ë¸” â€“ **VIEW (View)**

## 4-2. ì—°ì‚°Â·ê´€ê³„ëŒ€ìˆ˜Â·ì§‘ê³„
4) ê³µí†µ ì†ì„± ê²°í•© â€“ **ì¡°ì¸ (Join, â‹ˆ)**
5) ì¡°ê±´ìœ¼ë¡œ í–‰ ì„ íƒ â€“ **ì„ íƒ (Selection, Ïƒ)**
6) ì§€ì • ì—´ë§Œ ë‚¨ê¹€ â€“ **íˆ¬ì˜ (Projection, Ï€)**
7) ë‘ ë¦´ë ˆì´ì…˜ ëª¨ë“  íŠœí”Œ ì¡°í•© â€“ **ì¹´í‹°ì…˜ í”„ë¡œë•íŠ¸ (Cartesian Product)**
8) ê·¸ë£¹í™” ê¸°ì¤€ â€“ **GROUP BY (GROUP BY)**
9) ê·¸ë£¹ ê²°ê³¼ í•„í„° â€“ **HAVING (HAVING)**

## 4-3. ì •ê·œí™”Â·ë¬´ê²°ì„±Â·íŠ¸ëœì­ì…˜(ACID)
10) ë¶€ë¶„/ì´í–‰ ì¢…ì† ì œê±° ì •ê·œí˜• â€“ **ì œ3ì •ê·œí˜• (3NF, Third Normal Form)**
11) ëª¨ë“  ê²°ì •ìê°€ í›„ë³´í‚¤ì¸ ì •ê·œí˜• â€“ **BCNF (Boyceâ€“Codd Normal Form)**
12) ê¸°ë³¸í‚¤ NULL/ì¤‘ë³µ ê¸ˆì§€ â€“ **ê°œì²´ ë¬´ê²°ì„± (Entity Integrity)**
13) ì „ë¶€ ë°˜ì˜/ì „í˜€ ë°˜ì˜ â€“ **ì›ìì„± (Atomicity)**
14) ì œì•½ ìœ ì§€ â€“ **ì¼ê´€ì„± (Consistency)**
15) ë™ì‹œ ê°„ì„­ ìµœì†Œí™” â€“ **ê²©ë¦¬ì„± (Isolation)**
16) ì»¤ë°‹ ê²°ê³¼ ì˜êµ¬ ë³´ì¡´ â€“ **ì§€ì†ì„± (Durability)**

## 4-4. ì €ì¥Â·êµ¬ì¡°Â·ì†ì„±
17) ì„œë²„ ì§ì ‘ ì—°ê²° ì €ì¥ì¥ì¹˜ â€“ **DAS (Direct-Attached Storage)**
18) í–‰ ìˆ˜ â€“ **Cardinality (Cardinality)**
19) ì—´ ìˆ˜ â€“ **Degree (Degree)**
20) ê°’ì´ ì—¬ëŸ¬ ê°œì¸ ì†ì„± í‘œê¸° â€“ **ë‹¤ì¤‘ê°’ ì†ì„± (Multivalued Attribute, Double Ellipse)**

## 4-5. SQL êµ¬ë¬¸ ë¶„ë¥˜Â·ì¡°ê±´
21) ë°ì´í„° ì¡°ì‘ì–´ â€“ **DML (Data Manipulation Language)**
22) ë°ì´í„° ì •ì˜ì–´ â€“ **DDL (Data Definition Language)**
23) ì»¬ëŸ¼=ê°’ ê°±ì‹  ì ˆ â€“ **UPDATE â€¦ SET (UPDATE â€¦ SET)**
24) ë„ì´ ì•„ë‹Œ í–‰ ì¡°ê±´ â€“ **IS NOT NULL (IS NOT NULL)**

# ğŸ“Œ 5. ìë£Œêµ¬ì¡° Â· ì•Œê³ ë¦¬ì¦˜ Â· í…ŒìŠ¤íŠ¸
## 5-1. ìë£Œêµ¬ì¡°Â·í‘œí˜„
1) nÃ—n í–‰ë ¬ë¡œ ì—°ê²° í‘œí˜„ â€“ **ì¸ì ‘ í–‰ë ¬ (Adjacency Matrix)**
2) í•œìª½ ëì—ì„œë§Œ ì‚½ì…/ì‚­ì œ â€“ **ìŠ¤íƒ (Stack, LIFO: Last-In, First-Out)**
3) ì–‘ë ë¶„ë¦¬ ì‚½ì…/ì‚­ì œ â€“ **í (Queue, FIFO: First-In, First-Out)**
4) ë¶€ëª¨â€“ìì‹ ë¹„ì„ í˜• êµ¬ì¡° â€“ **íŠ¸ë¦¬ (Tree)**
5) ì •ì /ê°„ì„  ê´€ê³„ êµ¬ì¡° â€“ **ê·¸ë˜í”„ (Graph)**

## 5-2. ì •ë ¬
6) í˜„ì¬ ì›ì†Œë¥¼ ì ì†Œì— ì‚½ì…(O(nÂ²)) â€“ **ì‚½ì… ì •ë ¬ (Insertion Sort)**
7) í”¼ë²— ë¶„í•  í›„ ì¬ê·€ ì •ë ¬ â€“ **í€µ ì •ë ¬ (Quick Sort)**

## 5-3. í…ŒìŠ¤íŠ¸ ê¸°ë²•
8) ëª…ì„¸ ê¸°ë°˜ ì‹œí—˜ â€“ **ë¸”ë™ë°•ìŠ¤ í…ŒìŠ¤íŠ¸ (Black-box Testing)**
9) ê²½ê³„ ê·¼ì²˜ ì…ë ¥ ì„¤ê³„ â€“ **ê²½ê³„ê°’ ë¶„ì„ (Boundary Value Analysis)**
10) ì…ë ¥ì˜ ë“±ê°€ í´ë˜ìŠ¤ ëŒ€í‘œê°’ ì‹œí—˜ â€“ **ë™ë“± ë¶„í•  (Equivalence Partitioning)**
11) ê²½í—˜/íŒ¨í„´ ê¸°ë°˜ ì·¨ì•½ ì˜ì—­ ì˜ˆì¸¡ â€“ **ì˜¤ë¥˜ ì˜ˆì¸¡ (Error Guessing)**
12) ë¬´ì‘ìœ„ ì…ë ¥ìœ¼ë¡œ ê²°í•¨ íƒì§€ â€“ **ëœë¤ í…ŒìŠ¤íŠ¸ (Random Testing)**

# ğŸ“Œ 6. ìš´ì˜ì²´ì œ Â· ì»´í“¨í„° êµ¬ì¡°
## 6-1. ë©”ëª¨ë¦¬/í• ë‹¹Â·êµì²´
1) ê°€ì¥ ì‘ì€ ë§ì¶¤ ê³µê°„ì— ì ì¬ â€“ **Best Fit (Best-Fit Allocation)**
2) ê°€ì¥ í° ë¹ˆ ê³µê°„ì— ì ì¬ â€“ **Worst Fit (Worst-Fit Allocation)**
3) ì²« ë²ˆì§¸ë¡œ ë§ëŠ” ê³µê°„ì— ì ì¬ â€“ **First Fit (First-Fit Allocation)**
4) ì°¸ì¡° ë¹„íŠ¸ë¡œ í•œ ë²ˆ ë” ê¸°íšŒ â€“ **Second-Chance ì•Œê³ ë¦¬ì¦˜ (Clock/Second-Chance Page Replacement)**

## 6-2. í”„ë¡œì„¸ìŠ¤/ìŠ¤ì¼€ì¤„ë§
5) í”„ë¡œì„¸ìŠ¤ ìƒíƒœ/ë¬¸ë§¥/ìì› ì •ë³´ ë¸”ë¡ â€“ **PCB (Process Control Block)**
6) ì‘ë‹µë¹„ìœ¨ì´ í° ì‘ì—… ìš°ì„  â€“ **HRN ìŠ¤ì¼€ì¤„ë§ (Highest Response Ratio Next)**
7) ê°€ì¥ ì§§ì€ ì‘ì—… ìš°ì„  â€“ **SJF ìŠ¤ì¼€ì¤„ë§ (Shortest Job First)**

## 6-3. ì£¼ì†Œ ë³€í™˜Â·êµì°© íšŒí”¼
8) ì„¸ê·¸ë¨¼íŠ¸ ì‹œì‘ì£¼ì†Œ+ì˜¤í”„ì…‹ ë³€í™˜ â€“ **ì„¸ê·¸ë¨¼íŠ¸ í…Œì´ë¸” (Segment Table)**
9) ì•ˆì „ ìƒíƒœë§Œ í—ˆìš©í•˜ëŠ” êµì°© íšŒí”¼ â€“ **ì€í–‰ê°€ ì•Œê³ ë¦¬ì¦˜ (Bankerâ€™s Algorithm)**

# ğŸ“Œ 7. í”„ë¡œê·¸ë˜ë° ì–¸ì–´(ë¬¸ë²•Â·ì‹ë³„ì)
## 7-1. ì—°ì‚°ìÂ·íƒ€ì…
1) í•˜ë‚˜ë¼ë„ ì°¸ì´ë©´ ì°¸ â€“ **ë…¼ë¦¬í•© ì—°ì‚°ì (Logical OR, ||)**
2) ì°¸/ê±°ì§“ ìë£Œí˜• â€“ **boolean (Boolean Type)**

## 7-2. ì ‘ê·¼Â·ì‹ë³„ìÂ·ë‹¨ìœ„
3) ë©¤ë²„ ì ‘ê·¼ ë²”ìœ„ ì§€ì •ì â€“ **ì ‘ê·¼ì œì–´ì (Access Modifiers: public/default/protected/private)**
4) ì‹ë³„ì ì‘ì„± ê·œì¹™ â€“ **ë³€ìˆ˜ëª… ì œì•½ (Identifier Naming Rules)**
5) 4ë¹„íŠ¸(half-byte) â€“ **nibble (Nibble)**

# ğŸ“Œ 8. ì •ë³´ì‹œìŠ¤í…œ êµ¬ì¶• Â· ì‹ ê¸°ìˆ  Â· í´ë¼ìš°ë“œ
## 8-1. SDx/ê°€ìƒí™”
1) ìì›ì„ ì†Œí”„íŠ¸ì›¨ì–´ë¡œ ì •ì˜/ìë™í™”í•œ ë°ì´í„°ì„¼í„° â€“ **SDDC (Software-Defined Data Center)**
2) ìŠ¤í† ë¦¬ì§€ ê°€ìƒí™”Â·í’€ë§Â·ì •ì±… ì œê³µ â€“ **SDS (Software-Defined Storage)**

## 8-2. ë¶„ì‚°Â·ë¹…ë°ì´í„°/ML
3) ë¶„í• (Map)â†’ì§‘ê³„(Reduce) ë¶„ì‚° ì²˜ë¦¬ â€“ **MapReduce (MapReduce)**
4) ìˆ˜ì¹˜ì—°ì‚°/ìë™ë¯¸ë¶„/ë”¥ëŸ¬ë‹ í”„ë ˆì„ì›Œí¬ â€“ **TensorFlow (TensorFlow)**

## 8-3. í´ë¼ìš°ë“œ ì„œë¹„ìŠ¤Â·í”Œë«í¼
5) êµ­ë‚´ ì˜¤í”ˆ PaaS í‘œì¤€ í”Œë«í¼ â€“ **PaaS-TA (Platform as a Serviceâ€“TA)**
6) í´ë¼ìš°ë“œ ì„œë¹„ìŠ¤ ë¶„ë¥˜ â€“ **IaaS (Infrastructure as a Service) / PaaS (Platform as a Service) / SaaS (Software as a Service)**

## 8-4. ê¸°íƒ€ ì‹ ê¸°ìˆ  ìš©ì–´
7) ë°œí‘œë§Œ ë˜ê³  ì‹¤ì œ ë°°í¬ëŠ” ì•ˆ ëœ ì†Œí”„íŠ¸ì›¨ì–´ â€“ **Vaporware (Vaporware)**
8) í˜„ì‹¤ê³¼ ë””ì§€í„¸ì´ ìœµí•©ëœ 3D ê°€ìƒ ì„¸ê³„ â€“ **Metaverse (Metaverse)**

# ğŸ“Œ 9. ìƒì„±(Creational) íŒ¨í„´ (Java)

> í•œì¤„ì •ì˜: **ê°ì²´ ìƒì„±ì˜ ì±…ì„ê³¼ ì‹œì ì„ ìœ ì—°í•˜ê²Œ ë¶„ë¦¬í•´ ê²°í•©ë„ë¥¼ ë‚®ì¶”ëŠ” íŒ¨í„´êµ°**  
> ì•„ì´ë””ì–´: ìƒì„± ê³¼ì •ì„ ê°ì¶”ê±°ë‚˜ ì§€ì—°/ëŒ€ì²´/í‘œì¤€í™”í•˜ì—¬ **í™•ì¥ ê°€ëŠ¥ì„±ê³¼ í…ŒìŠ¤íŠ¸ ìš©ì´ì„±**ì„ í™•ë³´í•œë‹¤.

---

## 9-1. Abstract Factory
- **í•œì¤„ì •ì˜:** ê´€ë ¨ëœ **ì œí’ˆêµ°**ì„ ìƒì„±í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•˜ë˜, êµ¬ìƒ í´ë˜ìŠ¤ë¥¼ ê°ì¶˜ë‹¤.
- **ì•„ì´ë””ì–´:** í´ë¼ì´ì–¸íŠ¸ëŠ” íŒ©í† ë¦¬ ì¸í„°í˜ì´ìŠ¤ë§Œ ì•Œê³ , ì„œë¡œ í˜¸í™˜ë˜ëŠ” ì œí’ˆ ì„¸íŠ¸ë¥¼ ì¼ê´€ë˜ê²Œ ë§Œë“ ë‹¤.
```java
interface Button { String skin(); }
interface Window { String skin(); }

interface WidgetFactory {
  Button createButton();
  Window createWindow();
}

class MacFactory implements WidgetFactory {
  public Button createButton() { return () -> "mac"; }
  public Window createWindow() { return () -> "mac"; }
}
class WinFactory implements WidgetFactory {
  public Button createButton() { return () -> "win"; }
  public Window createWindow() { return () -> "win"; }
}

class App {
  App(WidgetFactory f) {
    System.out.println(f.createButton().skin() + " / " + f.createWindow().skin());
  }
}
```

## 9-2. Builder
- **í•œì¤„ì •ì˜:** ë³µì¡í•œ ê°ì²´ì˜ **ì¡°ë¦½ ì ˆì°¨**ë¥¼ ë¶„ë¦¬í•´, **ê°™ì€ ì ˆì°¨ë¡œ ë‹¤ë¥¸ í‘œí˜„**ì„ ë§Œë“ ë‹¤.
- **ì•„ì´ë””ì–´:** ë¶ˆë³€/ê°€ë…ì„±/ì„ íƒì  í•„ë“œì— ìœ ë¦¬í•œ ì²´ì´ë‹ API.
```java
class HttpReq {
  final String method, path; final boolean keep;
  private HttpReq(Builder b){ this.method=b.m; this.path=b.p; this.keep=b.k; }
  static class Builder {
    String m="GET", p="/"; boolean k;
    Builder method(String v){ m=v; return this; }
    Builder path(String v){ p=v; return this; }
    Builder keepAlive(boolean v){ k=v; return this; }
    HttpReq build(){ return new HttpReq(this); }
  }
}
```

## 9-3. Factory Method
- **í•œì¤„ì •ì˜:** ê°ì²´ ìƒì„±ì„ **í•˜ìœ„ í´ë˜ìŠ¤**(ë˜ëŠ” ì „ë‹¬ëœ ì „ëµ)ì— ìœ„ì„í•œë‹¤.
- **ì•„ì´ë””ì–´:** ìƒìœ„ëŠ” ìƒì„± íƒ€ì´ë°ë§Œ ì •í•˜ê³ , êµ¬ìƒ íƒ€ì… ì„ íƒì€ í•˜ìœ„ê°€ ë‹´ë‹¹.
```java
abstract class Creator {
  abstract Product create();            // íŒ©í† ë¦¬ ë©”ì„œë“œ
  Product order(){ return create(); }   // ê³ ì • ê³¨ê²©
}
interface Product { String name(); }
class A implements Product { public String name(){ return "A"; } }
class ACreator extends Creator { Product create(){ return new A(); } }
```

## 9-4. Prototype
- **í•œì¤„ì •ì˜:** ì›í˜• ê°ì²´ë¥¼ **ë³µì œ(clone)**í•˜ì—¬ ìƒˆ ê°ì²´ë¥¼ ë§Œë“ ë‹¤.
- **ì•„ì´ë””ì–´:** ìƒì„± ë¹„ìš©ì´ í° ê°ì²´, ëŸ°íƒ€ì„ì— ìƒˆë¡œìš´ â€œíƒ€ì…â€ì„ ë“±ë¡/ìƒì„±.
```java
class Enemy implements Cloneable {
  int hp; String type;
  Enemy(int hp, String type){ this.hp=hp; this.type=type; }
  public Enemy clone(){ try { return (Enemy)super.clone(); } catch(CloneNotSupportedException e){ throw new AssertionError(); } }
}
```

## 9-5. Singleton
- **í•œì¤„ì •ì˜:** ì‹œìŠ¤í…œ ì „ì—­ì— **í•˜ë‚˜ì˜ ì¸ìŠ¤í„´ìŠ¤**ë§Œ ë³´ì¥í•œë‹¤.
- **ì•„ì´ë””ì–´:** private ìƒì„±ì + ì •ì  ì ‘ê·¼ì(ìŠ¤ë ˆë“œ ì•ˆì „ ë°©ì‹ ê¶Œì¥).
```java
class Logger {
  private Logger(){}
  private static class Holder { static final Logger I = new Logger(); }
  public static Logger get(){ return Holder.I; }
}
```

---

# ğŸ“Œ 10. êµ¬ì¡°(Structural) íŒ¨í„´ (Java)

> í•œì¤„ì •ì˜: **í´ë˜ìŠ¤/ê°ì²´ì˜ ì¡°í•© ë°©ì‹ì„ ë°”ê¿” ì¸í„°í˜ì´ìŠ¤ í˜¸í™˜, ì±…ì„ ë¶„ë¦¬, ì¬ì‚¬ìš©ì„ ë†’ì´ëŠ” íŒ¨í„´êµ°**  
> ì•„ì´ë””ì–´: í•©ì„±/ìœ„ì„ìœ¼ë¡œ ìœ ì—°ì„±ì„ í™•ë³´í•˜ê³  ìƒì† ë‚¨ìš©ì„ ì¤„ì¸ë‹¤.

---

## 10-1. Adapter
- **í•œì¤„ì •ì˜:** **í˜¸í™˜ë˜ì§€ ì•ŠëŠ” ì¸í„°í˜ì´ìŠ¤**ë¥¼ ë³€í™˜í•˜ëŠ” ì¤‘ê°„ ë˜í¼.
- **ì•„ì´ë””ì–´:** ê¸°ëŒ€ ì¸í„°í˜ì´ìŠ¤(Lightning)ë¥¼ êµ¬í˜„í•˜ê³ , ì‹¤ì œ ëŒ€ìƒ(TypeC)ì— ìœ„ì„.
```java
interface Lightning { void charge(); }
class TypeC { void cCharge(){ System.out.println("Type-C 25W!"); } }
class LightningToTypeCAdapter implements Lightning {
  private final TypeC c;
  LightningToTypeCAdapter(TypeC c){ this.c=c; }
  public void charge(){ c.cCharge(); }
}
```

## 10-2. Bridge
- **í•œì¤„ì •ì˜:** **ì¶”ìƒ**ê³¼ **êµ¬í˜„**ì„ ë¶„ë¦¬í•´ ë…ë¦½ì ìœ¼ë¡œ í™•ì¥í•œë‹¤.
- **ì•„ì´ë””ì–´:** Abstractionì´ Implementorë¥¼ í•©ì„±.
```java
interface Renderer { void circle(int x,int y,int r); }
class Raster implements Renderer { public void circle(int x,int y,int r){ System.out.println("Raster"); } }
class Vector implements Renderer { public void circle(int x,int y,int r){ System.out.println("Vector"); } }
class Circle {
  private final Renderer r; int x,y,rad;
  Circle(Renderer r,int x,int y,int rad){ this.r=r; this.x=x; this.y=y; this.rad=rad; }
  void draw(){ r.circle(x,y,rad); }
}
```

## 10-3. Composite
- **í•œì¤„ì •ì˜:** **ë¶€ë¶„-ì „ì²´**ë¥¼ ë™ì¼ ì¸í„°í˜ì´ìŠ¤ë¡œ ë‹¤ë£¨ëŠ” íŠ¸ë¦¬ êµ¬ì¡°.
- **ì•„ì´ë””ì–´:** Componentì— Leaf/Compositeê°€ ê³µì¡´.
```java
import java.util.*;
interface Node { void render(); }
class Leaf implements Node { public void render(){ System.out.println("Leaf"); } }
class Group implements Node {
  private final List<Node> children=new ArrayList<>();
  void add(Node n){ children.add(n); }
  public void render(){ System.out.println("Group{"); children.forEach(Node::render); System.out.println("}"); }
}
```

## 10-4. Decorator
- **í•œì¤„ì •ì˜:** ê°ì²´ë¥¼ **ê°ì‹¸ì„œ ê¸°ëŠ¥ì„ ë™ì ìœ¼ë¡œ ë§ë¶™ì¸ë‹¤**.
- **ì•„ì´ë””ì–´:** ë™ì¼ ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„ + ë‚´ë¶€ì— ì› ê°ì²´ ë³´ê´€.
```java
interface View { void draw(); }
class TextView implements View { public void draw(){ System.out.println("Text"); } }
class BorderDecorator implements View {
  private final View inner;
  BorderDecorator(View v){ inner=v; }
  public void draw(){ inner.draw(); System.out.println("+Border"); }
}
```

## 10-5. Facade
- **í•œì¤„ì •ì˜:** ë³µì¡í•œ ì„œë¸Œì‹œìŠ¤í…œì— **ë‹¨ìˆœ í†µí•© ì¸í„°í˜ì´ìŠ¤** ì œê³µ.
- **ì•„ì´ë””ì–´:** ì›Œí¬í”Œë¡œìš°ë§Œ ì¡°ì •í•˜ê³  ë‚´ë¶€ ì„¸ë¶€ë¥¼ ê°ì¶¤.
```java
class Audio { void on(){ System.out.println("Audio"); } }
class Net { void connect(){ System.out.println("Net"); } }
class Scene { void load(){ System.out.println("Scene"); } }
class GameFacade {
  private final Audio a=new Audio(); private final Net n=new Net(); private final Scene s=new Scene();
  void start(){ a.on(); n.connect(); s.load(); System.out.println("Start!"); }
}
```

## 10-6. Flyweight
- **í•œì¤„ì •ì˜:** **ê³µìœ  ê°€ëŠ¥í•œ ë‚´ì¬ ìƒíƒœ**ë¥¼ ìºì‹œí•´ ë©”ëª¨ë¦¬ë¥¼ ì ˆê°.
- **ì•„ì´ë””ì–´:** intrinsic(ê³µìœ )/extrinsic(í˜¸ì¶œ ì‹œ ì „ë‹¬) ë¶„ë¦¬.
```java
class Glyph { final char ch; Glyph(char c){ ch=c; } void draw(int x,int y){ System.out.println(ch+"@"+x+","+y); } }
class GlyphFactory {
  private static final java.util.Map<Character,Glyph> pool = new java.util.HashMap<>();
  static Glyph get(char c){ return pool.computeIfAbsent(c, Glyph::new); }
}
```

## 10-7. Proxy
- **í•œì¤„ì •ì˜:** ë™ì¼ ì¸í„°í˜ì´ìŠ¤ë¡œ **ì ‘ê·¼ì„ ê°€ë¡œì±„** ê¶Œí•œ/ìºì‹œ/ì§€ì—° ë¡œë”© ìˆ˜í–‰.
- **ì•„ì´ë””ì–´:** Subject ì¸í„°í˜ì´ìŠ¤ ë™ì¼, ë‚´ë¶€ì— RealSubject í•©ì„±.
```java
interface Subject { void fetch(); }
class RealSubject implements Subject { public void fetch(){ System.out.println("Heavy DB"); } }
class AuthProxy implements Subject {
  private final Subject real; private final boolean allowed;
  AuthProxy(Subject real, boolean allowed){ this.real=real; this.allowed=allowed; }
  public void fetch(){ if(!allowed) System.out.println("DENY"); else real.fetch(); }
}
```

---

# ğŸ“Œ 11. í–‰ìœ„(Behavioral) íŒ¨í„´ (Java)

> í•œì¤„ì •ì˜: **ì±…ì„ ë¶„ë°°ì™€ ìƒí˜¸ì‘ìš©ì˜ ê·œì¹™**ì„ ì •ì˜í•´ ìœ ì—°ì„±ê³¼ ì‘ì§‘ë„ë¥¼ ë†’ì´ëŠ” íŒ¨í„´êµ°  
> ì•„ì´ë””ì–´: ì¡°ê±´Â·ë¶„ê¸°Â·ì½œë°±Â·í”„ë¡œí† ì½œì„ ê°ì²´ ê°„ ê³„ì•½ìœ¼ë¡œ ë°”ê¾¸ì–´ ë³€í™”ì— ê°•í•˜ê²Œ ë§Œë“ ë‹¤.

---

## 11-1. Chain of Responsibility
- **í•œì¤„ì •ì˜:** ìš”ì²­ì„ **ì—°ê²°ëœ ì²˜ë¦¬ì**ë“¤ì— ë„˜ê²¨ ì ì ˆí•œ ê³³ì—ì„œ ì²˜ë¦¬.
- **ì•„ì´ë””ì–´:** í•¸ë“¤ëŸ¬ê°€ ë‹¤ìŒ í•¸ë“¤ëŸ¬ë¥¼ ì°¸ì¡°.
```java
abstract class Handler {
  private Handler next;
  Handler link(Handler n){ this.next=n; return n; }
  final boolean handle(int v){ return exec(v) || (next!=null && next.handle(v)); }
  abstract boolean exec(int v);
}
class Limit10 extends Handler { boolean exec(int v){ if(v<=10){ System.out.println("<=10"); return true;} return false; } }
class Limit20 extends Handler { boolean exec(int v){ if(v<=20){ System.out.println("<=20"); return true;} return false; } }
```

## 11-2. Command
- **í•œì¤„ì •ì˜:** ìš”ì²­ì„ **ê°ì²´ë¡œ ìº¡ìŠí™”**í•˜ì—¬ ì‹¤í–‰/í/Undoë¥¼ í‘œì¤€í™”.
- **ì•„ì´ë””ì–´:** Command.execute()ì— ë™ì‘ì„ ëª¨ì€ë‹¤.
```java
interface Command { void exec(); }
class Light { boolean on; void on(){ on=true; System.out.println("ON"); } }
class LightOn implements Command {
  private final Light l; LightOn(Light l){ this.l=l; }
  public void exec(){ l.on(); }
}
```

## 11-3. Interpreter
- **í•œì¤„ì •ì˜:** **ë¬¸ë²• ê·œì¹™**ì„ í´ë˜ìŠ¤ë¡œ ëª¨ë¸ë§í•´ í•´ì„í•œë‹¤.
- **ì•„ì´ë””ì–´:** AST ê° ë…¸ë“œê°€ interpretë¥¼ êµ¬í˜„.
```java
interface Expr { int eval(); }
record Num(int v) implements Expr { public int eval(){ return v; } }
record Add(Expr a, Expr b) implements Expr { public int eval(){ return a.eval()+b.eval(); } }
```

## 11-4. Iterator
- **í•œì¤„ì •ì˜:** ë‚´ë¶€ í‘œí˜„ì„ ë…¸ì¶œí•˜ì§€ ì•Šê³  **í‘œì¤€ ìˆœíšŒ** ì œê³µ.
- **ì•„ì´ë””ì–´:** hasNext/next ê³„ì•½.
```java
import java.util.Iterator;
class ArrIter implements Iterator<Integer> {
  private final int[] a; private int i=0;
  ArrIter(int[] a){ this.a=a; }
  public boolean hasNext(){ return i<a.length; }
  public Integer next(){ return a[i++]; }
}
```

## 11-5. Mediator
- **í•œì¤„ì •ì˜:** ê°ì²´ ê°„ ìƒí˜¸ì‘ìš©ì„ **ì¤‘ì¬ì**ì—ê²Œ ìœ„ì„í•´ N:N ì˜ì¡´ì„ 1:Nìœ¼ë¡œ.
- **ì•„ì´ë””ì–´:** ë™ë£Œë“¤ì€ Mediatorë§Œ ì°¸ì¡°.
```java
interface Mediator { void notify(String who, String ev); }
class Button { private final Mediator m; Button(Mediator m){ this.m=m; } void click(){ m.notify("Button","click"); } }
```

## 11-6. Memento
- **í•œì¤„ì •ì˜:** ìº¡ìŠí™” ìœ ì§€í•˜ë©° **ìƒíƒœ ìŠ¤ëƒ…ìƒ·**ì„ ì €ì¥/ë³µì›.
- **ì•„ì´ë””ì–´:** Originator/ Memento/ Caretaker ë¶„ë¦¬.
```java
class Player { int x,y; Snapshot save(){ return new Snapshot(x,y); } void load(Snapshot s){ x=s.x; y=s.y; } }
record Snapshot(int x,int y){}
```

## 11-7. Observer
- **í•œì¤„ì •ì˜:** **ë°œí–‰-êµ¬ë…** ëª¨ë¸ë¡œ ìƒíƒœ ë³€í™” í†µì§€.
- **ì•„ì´ë””ì–´:** Subjectê°€ êµ¬ë…ìë¥¼ ëª©ë¡ìœ¼ë¡œ ê´€ë¦¬í•˜ê³  notify.
```java
import java.util.*;
interface Observer { void update(int t); }
class Thermometer {
  private final List<Observer> obs = new ArrayList<>(); private int t;
  void sub(Observer o){ obs.add(o); }
  void setTemp(int nt){ t=nt; obs.forEach(o->o.update(t)); }
}
```

## 11-8. State
- **í•œì¤„ì •ì˜:** ìƒíƒœì— ë”°ë¼ **í–‰ìœ„ë¥¼ êµì²´**(ê±°ëŒ€í•œ if-else ì œê±°).
- **ì•„ì´ë””ì–´:** Contextê°€ í˜„ì¬ Stateì— ìœ„ì„í•˜ê³  êµì²´.
```java
interface DoorState { void push(Door ctx); }
class Door {
  DoorState st = new Closed();
  void push(){ st.push(this); }
  void set(DoorState s){ st=s; }
}
class Closed implements DoorState { public void push(Door c){ System.out.println("Open"); c.set(new Open()); } }
class Open implements DoorState { public void push(Door c){ System.out.println("Close"); c.set(new Closed()); } }
```

## 11-9. Strategy
- **í•œì¤„ì •ì˜:** ì•Œê³ ë¦¬ì¦˜ì„ **êµì²´ ê°€ëŠ¥í•œ ì „ëµ ê°ì²´**ë¡œ ìº¡ìŠí™”.
- **ì•„ì´ë””ì–´:** Contextê°€ ì „ëµì„ í•©ì„±.
```java
interface Pay { int doPay(int amt); }
class Card implements Pay { public int doPay(int a){ System.out.println("Card"); return a; } }
class Cash implements Pay { public int doPay(int a){ System.out.println("Cash"); return a; } }
class Checkout { Pay p; Checkout(Pay p){ this.p=p; } int pay(int a){ return p.doPay(a); } }
```

## 11-10. Template Method
- **í•œì¤„ì •ì˜:** ì•Œê³ ë¦¬ì¦˜ì˜ **ê³¨ê²©**ì„ ì •ì˜í•˜ê³  ì„¸ë¶€ëŠ” í•˜ìœ„ì—ì„œ êµ¬í˜„.
- **ì•„ì´ë””ì–´:** final í…œí”Œë¦¿ + í›… ë©”ì„œë“œ.
```java
abstract class Algo {
  public final void run(){ System.out.println("Start"); step1(); step2(); System.out.println("End"); }
  protected abstract void step1();
  protected abstract void step2();
}
```

## 11-11. Visitor
- **í•œì¤„ì •ì˜:** **êµ¬ì¡°ëŠ” ê³ ì •**í•˜ê³ , ìƒˆë¡œìš´ ì—°ì‚°ì„ **ë°©ë¬¸ì**ë¡œ ì¶”ê°€.
- **ì•„ì´ë””ì–´:** double-dispatch(`accept/visit`).
```java
interface Visitor { void visit(Circle c); void visit(Rect r); }
interface Element { void accept(Visitor v); }
class Circle implements Element { int r; public void accept(Visitor v){ v.visit(this); } }
class Rect implements Element { int w,h; public void accept(Visitor v){ v.visit(this); } }
```

