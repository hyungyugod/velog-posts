# 📌 0. react ajax-crud
### 📌 0-1. ajax 연동
- "proxy": "http://localhost:8080" 이는 fetch("/departments") 호출하면 http://localhost:8080/departments로 요청이 전달되도록 중계해주는 역할을 한다.
- "start": "react-scripts start | hossam-server": 리액트 개발 서버의 출력이 hossam-server로 전달된다. 즉 리액트 개발 서버의 콘솔 로그/출력 결과가 **그대로 hossam-server 프로그램의 “입력”**으로 들어가게 된다.
- 이때 yarn start를 실행하면 "react-scripts start | hossam-server" 이 명령 전체가 실행된다.
```json
"proxy": "http://localhost:8080",
"scripts": {
    "start": "react-scripts start | hossam-server", 
}
```
- 그리고 yarn + 아래 스크립트의 키값을 입력하면 오른쪽의 명령어들이 실행된다. 하여 yarn start로 백엔드와 리액트 서버를 두개 다 가동할 수 있게 되는 것이다.
```json
"scripts": {
    "start": "react-scripts start | hossam-server",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
}
```

### 📌 0-2. 학과 리스트 불러오기
- useEffect는 두번째 인자 속 배열 내부값이 바뀔때마다 내부 함수를 실행하면서 화면을 재랜더링한다.
- 이때 처음 리스트로 get요청을 보내면서 keyword를 주는데 키워드가 포함된(like) 학과 리스트를 백엔드에서 데이터로 받아온다.
- 이때 2번째 인자 배열 내부에 keyword 값을 주면 keyword 값이 바뀔때마다 해당 함수가 실행되면서 해당 키워드로 get요청을 보내 리스트를 받아오게 된다.
- keyword값은 useCallback에 의해 한번 로드 되고 바뀌지 않는 onSearchSubmit객체를 활용하여 폼이 submit되었을때 input 태그의 값을 키워드로 설정하게 된다.
- `<Link to={/view/${v.id}}>{v.dname}</Link>` 에서 링크를 클릭해도 router가 app.js 에 있으니까 거기서 길을 찾아서 페이지를 이동한다.
- 모든 페이지가 ajax 요청을 기다리지 않고 한번 로드될 수 있으므로 모든 상태값에는 기본값을 넣어두어야한다.
```js
const DepartmentList = memo(() => {
    const [data, setData] = useState([]);
    const [keyword, setKeyword] = useState('');
    const [loading, setLoading] = useState(false);
    const searchInputRef = useRef();

    useEffect(() => {
        (async () => {
            let result = null;
            setLoading(true);

        try {
            result = await fetchHelper.get('/departments', {
            dname_like: keyword,
            });
        } catch (e) {
            console.error(e);
            alert(e.message);
            return;
        } finally {
            setLoading(false);
        }
            setData(result.item || []);
        })();
    }, [keyword]);

    const onSearchSubmit = useCallback((e) => {
        e.preventDefault();
        setKeyword(searchInputRef.current.value.trim());
    }, []);

    return (
        <DepartmentListContainer>
        <h2>학과목록</h2>
        <Spinner loading={loading} />
        <form className="search-form" onSubmit={onSearchSubmit}>
            <input type="search" ref={searchInputRef} placeholder="학과명을 검색" />
            <Buttons>
                <button type="submit">검색</button>
                <Link to="/add">신규 학생 등록</Link>
            </Buttons>
        </form>
        <Table>
            <thead>
                <tr>
                    <th>학과번호</th>
                    <th>학과명</th>
                    <th>위치</th>
                    <th>전화번호</th>
                    <th>이메일</th>
                    <th>설립년도</th>
                    <th>홈페이지</th>
                </tr>
            </thead>
            <tbody>
            {data &&
                data.map((v, i) => (
                <tr key={v.id}>
                    <td>{v.id}</td>
                    <td>
                    <Link to={`/view/${v.id}`}>{v.dname}</Link>
                    </td>
                    <td>{v.loc}</td>
                    <td>
                    {v.phone && (
                        <a href={`tel:${v.phone}`}>{v.phone}</a>
                    )}
                    </td>
                    <td>
                    {v.email && (
                        <a href={`mailto:${v.email}`}>{v.email}</a>
                    )}
                    </td>
                    <td>{v.established}</td>
                    <td>
                    {v.homepage && (
                        <a href={v.homepage} target="_blank" rel="noopener noreferrer">
                        {v.homepage}
                        </a>
                    )}
                    </td>
                </tr>
                ))}
            </tbody>
        </Table>
        </DepartmentListContainer>
    );
}
```

### 📌 0-3. 학과 정보 수정
- **useNavigate**와 `<Link />` 둘 다 React Router에서 “페이지 이동”에 사용되므로 쓰임새를 구분할 필요가 있다.
- useNavigate는 프로그래밍 적으로 자동으로 페이지를 이동하게 해주는 리액트 훅이고 Link는 사용자가 클릭해서 직접 이동하는 링크이다.
- React Router는 앱 전체를 `<Router>` 컴포넌트로 감싸고 내부적으로 **라우팅 상태(현재 위치, 히스토리 등)**를 Context로 관리한다.
- 이 Context에서 **페이지 이동에 필요한 함수(예: navigate)**와 현재 경로 등의 정보를 자식 컴포넌트들이 언제든 꺼내 쓸 수 있게 한다.
- useNavigate 훅은 React Router의 내부 Context에서 SPA 라우팅에 특화된 “navigate 함수”를 꺼내와서 반환해주는 훅이다.
- React의 “훅(Hook)”은  단순히 “컴포넌트에서 상태, context 등 React 기능을 사용할 수 있는 함수”를 의미한다.
- 이는 비동기 처리와는 별개로 useNavigate()도 “동기적으로” 동작해서 navigate 함수(즉시 실행 가능한 함수)를 반환한다.
- useParams는 컴포넌트가 렌더링될 때 현재 URL에서 Path 파라미터(예: /edit/:id의 id)를 즉시 동기적으로 반환해준다.
- params는 모든 쿼리스트링을 map형태로 가지고 있으므로 params.id로 특정 쿼리스트링(id)에 접근할 수 있다.

- navigate("/path", {replace: true})
→ history.replace 대신 사용(뒤로가기가 안 남음)
- navigate(-1)
→ window.history.go(-1) 처럼 뒤로가기
(숫자를 주면 브라우저 히스토리에서 이동)
- state 전달:
navigate("/path", {state: {key: value}})
→ 라우팅 시 데이터 전달 (location.state로 받을 수 있음)
```js
const DepartmentEdit = memo(() => {
  // 페이지 이동 처리 함수 생성
  const navigate = useNavigate();

  // URL로부터 Path 파라미터 추출
  const params = useParams();

  // 로딩 상태 변수 선언
  const [loading, setLoading] = useState(false);

  // 학과 데이터 저장용 상태 변수 선언
  const [data, setData] = useState({});
```
- if (!params?.id) { return; } 불필요하게 서버에 데이터를 요청하지 않도록 미리 차단하는 목적이다.
-  라우팅 context가 바뀌거나, 부모 라우터가 변경되어 navigate 함수가 “새 객체”로 바뀌는 경우가 있을 수 있는데 이때 navigate함수를 의존성 배열에 넣지 않으면 최신의 navigate함수를 사용할 수 없을 수 있으므로 이를 useEffect에서 의존성 배열에 추가한다.
- `<button type="reset">초기화</button>` button type의 reset은 눌렸을때 해당 폼 안의 모든 입력 필드가 폼이 처음 로드될때의 상태로 모두 되돌아가게 한다.
- 폼을 제출하면 navigate함수를 통해 학과 정보 페이지로 이동
```js
  // 학과 정보 조회하기
  useEffect(() => {
    if (!params?.id) {
      return;
    }

    (async () => {
      let result = null;
      setLoading(true);

      try {
        result = await fetchHelper.get(`/departments/${params.id}`);
      } catch (e) {
        console.error(e);
        alert(e.message);
        return;
      } finally {
        setLoading(false);
      }
      setData(result.item || {});
    })();
  }, [params.id]);

  // 폼 제출 처리 이벤트 핸들러
  const handleSubmit = useCallback(async (e) => {
    e.preventDefault();

    try {
      regexHelper.value('#dname', '학과명을 입력하세요.');
      regexHelper.value('#loc', '위치를 입력하세요.');
      regexHelper.value('#phone', '전화번호를 입력하세요.');
      regexHelper.value('#email', '이메일을 입력하세요.');
      regexHelper.value('#established', '설립년도를 입력하세요.');
      regexHelper.value('#homepage', '홈페이지 URL을 입력하세요.');

      regexHelper.maxLength('#dname', 50, '학과명은 최대 50자까지 입력할 수 있습니다.');
      regexHelper.maxLength('#loc', 100, '위치는 최대 100자까지 입력할 수 있습니다.');
      regexHelper.maxLength('#phone', 20, '전화번호는 최대 20자까지 입력할 수 있습니다.');
      regexHelper.maxLength('#email', 100, '이메일은 최대 100자까지 입력할 수 있습니다.');
      regexHelper.minLength('#established', 4, '설립년도는 최소 4자리 숫자로 입력해야 합니다.');
      regexHelper.maxLength('#homepage', 200, '홈페이지 URL은 최대 200자까지 입력할 수 있습니다.');
    } catch (e) {
      alert(e.message);
      e.element.focus();
      return;
    }

    setLoading(true);

    let result = null;

    try {
      result = await fetchHelper.put(`/departments/${params.id}`, e.currentTarget);
      alert('학과가 수정되었습니다.');
    } catch (e) {
      console.error(e);
      alert(e.message);
    } finally {
      setLoading(false);
    }

    // React에서의 화면 이동
    navigate(`/view/${result.item.id}`);
  }, [params.id, navigate]);

  return (
    <DepartmentEditContainer>
      <h2>학과수정</h2>
      <Spinner loading={loading} />
      <form id="my-form" onSubmit={handleSubmit}>
        <TableInput>
          <tbody>
            <tr>
              <th>학과명</th>
              <td>
                <input type="text" name="dname" id="dname" placeholder="학과명을 입력하세요." defaultValue={data?.dname} />
              </td>
            </tr>
            <tr>
              <th>위치</th>
              <td>
                <input type="text" name="loc" id="loc" placeholder="위치를 입력하세요." defaultValue={data?.loc} />
              </td>
            </tr>
            <tr>
              <th>전화번호</th>
              <td>
                <input type="text" name="phone" id="phone" placeholder="전화번호를 입력하세요." defaultValue={data?.phone} />
              </td>
            </tr>
            <tr>
              <th>이메일</th>
              <td>
                <input type="email" name="email" id="email" placeholder="이메일을 입력하세요." defaultValue={data?.email} />
              </td>
            </tr>
            <tr>
              <th>설립년도</th>
              <td>
                <input type="number" name="established" id="established" placeholder="설립년도를 입력하세요." defaultValue={data?.established} />
              </td>
            </tr>
            <tr>
              <th>홈페이지</th>
              <td>
                <input type="url" name="homepage" id="homepage" placeholder="홈페이지 URL을 입력하세요." defaultValue={data?.homepage} />
              </td>
            </tr>
          </tbody>
        </TableInput>
        <Buttons>
          <button type="submit">등록</button>
          <button type="reset">초기화</button>
        </Buttons>
      </form>
    </DepartmentEditContainer>
  );
});
```

# 📌 1. redux (앱 전체의 상태(state)를 한 곳에서 체계적으로 관리하는 “중앙 저장소”)
- Redux와 React Router의 Context: 둘 다 React의 Context API를 기반으로 앱 전체에 “공통 데이터”를 전달하고, 어디서든 쉽게 꺼내 쓸 수 있게 해주는 구조이다.
- Context API: props를 일일이 넘기지 않고도(=props drilling 문제 해결) “전역적으로 값을 관리”하고 어떤 컴포넌트에서든 쉽게 읽거나 쓸 수 있게 해주는 React 내장 도구
- Provider : “공급자” MyContext.Provider로 앱(또는 하위 트리)을 감싸고, value prop에 공유할 데이터를 전달
- Consumer : “소비자” 하위 컴포넌트에서 useContext(MyContext)로 공유한 값을 쉽게 꺼내서 씀
```js
// 1. Context 생성
const ThemeContext = React.createContext('light');

// 2. 공급자(Provider)로 감싸기
function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Child />
    </ThemeContext.Provider>
  );
}

// 3. 하위에서 소비(Consumer)
function Child() {
  const theme = React.useContext(ThemeContext);
  return <div>현재 테마: {theme}</div>;
}
```
- Redux의 dispatch: 전역 store에 액션을 “전달”해 리듀서를 통해 상태를 바꿈(글로벌, 외부)
- useState/useReducer의 dispatch/setter: 개별 컴포넌트(혹은 해당 훅의 지역)에서만 상태를 바꿈(로컬, 내부)

### 📌 1-1. redux slice, store
- `<Provider store={store}>`는 Redux의 “전역 상태관리 공간(store)”을 앱 전체에 공급하는 Context Provider이다. 그러면 이 Provider 안에 있는 모든 컴포넌트에서 useSelector, useDispatch 등으로 Redux store(context)에 접근 가능하게 된다.
```js
// index.js
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <Provider store={store}>
    <BrowserRouter basename={Process.env.PUBLIC_URL}>
      <App />
    </BrowserRouter>
  </Provider>
);
```
- configureStore: redux-toolkit에서 store(전역 상태 저장소)를 만드는 함수로 여러 개의 slice(상태관리 단위)를 합쳐 하나의 store로 만들어준다.
- reducer: { CounterSlice } : store에 “CounterSlice”라는 이름으로 slice의 리듀서를 등록, state.CounterSlice에 접근할 수 있게 된다. (이름이 key로 들어감)
- 상태관리 단위니까 state. 으로 호출한다.
- reduce: 여러 값을 하나로 ‘누적하여’ 합치는 과정(여기서 줄이다가 파생) -> Redux에서 상태(state) 변화는 항상 “이전 상태”와 “액션”을 “하나의 새 상태”로 ‘줄이는(누적하는)’ 과정이므로 이 reduce 과정을 수행하는 단위는 reducer가 된다.
- 여기서 store에 등록하는 CounterSlice는 CounterSlice에서 export한 CounterSlice.reducer 즉 모든 액션함수들의(액션함수(리듀서)들이 모인 객체) 설계도 이다. 
```js
// store.js
import {configureStore} from '@reduxjs/toolkit';
import CounterSlice from './slices/CounterSlice';

const store = configureStore(
    {
        reducer: {
            CounterSlice
        }
    }
);

export default store;
```
- Slice는 상태값, 이 상태를 바꿀 “함수들”(=리듀서), 상태를 바꾸는 명령을 만들 “액션함수” 이 세 가지를 하나의 객체에 “묶어서” 자동으로 만들어 준다.
- name은 **이 Slice(상태 조각)**가 Redux 전체에서 어떤 “영역/분야”의 상태를 관리하는지 구분해주는 이름으로 createSlice는 내부적으로 **액션 객체의 type을 "name/reducer명"**으로 자동으로 만들어준다.
- 즉 서로 다른 Slice의 reducer 이름이 겹쳐도 name이 다르면 액션이 절대 충돌하지 않게 된다. (예: todos/add, user/add)
- initialState로 초기 상태를 만들고 plus와 같은 reducer로 파라미터를 받아 내부 작용을 통해 상태를 변화시킨다.
- 이때 컴포넌트에서 이 함수를 호출할 때 전달되는 파라미터는 `action.payload`로 전달되며 이 상태변경 함수 reducer는 당연히 상태를 업데이트하는 것이므로 initialState와 동일한 구조의 객체를 리턴해야 한다.
```js
import { createSlice } from '@reduxjs/toolkit'

/**
 * Slice 객체 생성
 * -> Slice: 리듀서와 액션함수를 내장하는 객체
 * -> 리듀서: 상태값을 변경하는 함수
 * -> 액션함수: 상태값을 변경하는 명령어
 * -> 일반 컴포넌트에서 액션함수를 호출하면 액션함수가 리듀서를 호출하여 상태값을 변경
 */

// Slice 객체 생성 --> 객체 이름은 소스파일명과 동일하게 설정(권장)
const CounterSlice = createSlice({
  // 1) Slice 객체의 이름 --> Slice 객체명과 동일하게 설정(권장)
  name: 'CounterSlice',

  // 2) 이 모듈이 관리하고자하는 상태값들을 명시 --> 이 안의 변수들은 자유롭게 나열
  initialState: {
    number: 0,
    color: '#000'
  },

  // 3) 상태값을 갱신하기 위한 함수들을 구현한다.
  // --> 파라미터는 state, action으로 고정되어 있다.
  // --> state: 현재 상태값을 가리킨다.
  // --> 컴포넌트에서 이 함수를 호출할 때 전달되는 파라미터는 `action.payload`로 전달된다.
  // --> [중요] initialState와 동일한 구조의 JSON을 리턴해야 한다.
  reducers: {
    plus: (state, action) => {
      const numberValue = state.number + action.payload;
      let colorValue = "#000";

      if (numberValue > 0) {
        colorValue = '#2f77eb';
      } else if (numberValue < 0) {
        colorValue = '#f60';
      }

      return {
        number: numberValue,
        color: colorValue
      };
    },
    minus: (state, action) => {
      const numberValue = state.number - action.payload;
      let colorValue = "#000";

      if (numberValue > 0) {
        colorValue = '#2f77eb';
      } else if (numberValue < 0) {
        colorValue = '#f60';
      }

      return {
        number: numberValue,
        color: colorValue
      };
    }
  }
});

// Slice 객체에서 액션함수들을 추출하여 export
export const { plus, minus } = CounterSlice.actions;

// Slice 객체에서 리듀서를 추출하여 export
export default CounterSlice.reducer;
```

### 📌 1-2. counter 사용 (useSelector, dispatch)
- useSelector를 통해 state.CounterSlice 즉 CounterSlice가 관리하는 상태값들을 가져와서 사용할 수 있다.
- useDispatch는 이 context에 맞는 reducer 사용함수를 만들어 리턴한다. 
- `<button onClick={() => dispatch(plus(5))}>+5</button>` 이와 같이 dispath함수와 함께 사용한다.
- 만약 다른 slice에 같은 reducer가 있다면 import할 때 별칭(alias)으로 구분하거나 구조분해 할당 시 이름을 다르게 해주면 된다. 내부적으로 타입은 달라서 안전하게 실행된다.
```js
const Counter = memo(() => {
  // hook을 통해 slice가 관리하는 상태값 가져오기
  const { number, color } = useSelector((state) => state.CounterSlice);

  // dispatch 함수 생성
  const dispatch = useDispatch();

  return (
    <CounterContainer>
      <h2>Counter</h2>

      <div className="counter-box">
        <button onClick={() => dispatch(plus(5))}>+5</button>
        <h2 className="number" color={color}>{number}</h2>
        <button onClick={() => dispatch(minus(3))}>-3</button>
      </div>
    </CounterContainer>
  );
});
```

### 📌 1-3. redux활용 ajax
- ajax로 불러온 값을 한번 전역 변수에 저장해두면 이후에는 여러번 ajax 호출을 하지 않고도 새로 고침하지 않는 이상 기존에 있던 값을 재사용할 수 있게 된다.
- 이는 보통 모바일과 같이 로딩 속도가 중요한 환경에서 사용하기 위해 디자인되었다.
- createAsyncThunk(함수명, 비동기함수(파라미터포함)) 여기서 말하는 함수명도 비동기 작업을 구분하는 “액션 타입(type)” 문자열이다. 타입을 구분하는 용도로 사용한다.
- payload: 이 thunk를 실행할 때 추가로 전달한 데이터 (payload: pay-가치있는 load-적재, 실은 것 => 가치있는 화물을 의미한다.)
- { rejectWithValue }: 에러 발생 시, 커스텀 에러 객체를 리턴해줄 수 있는 함수
- createAsyncThunk: Redux Toolkit에서 비동기(Ajax/API) 작업을 “자동으로” 관리해주는 액션 생성 함수이다.
- pending(작업시작), 성공, 실패에 대한 3가지 액션이 자동으로 생성되고 extraReducers에서 각각에 대해 리듀서를 작성 가능하다.
- extraReducers를 통해 비동기 상태값을 갱신할 리듀서들을 등록해둔다. 이들은 직접 호출하는 것이 아니라 thunk가 자동으로 실행해준다. dispatch로 getList만 부르면 그만이다.
- builder객체에다가 addCase를 통해 각 상태에서 실행될 것들을 미리 넣어두면 된다.
```js
/**
 * - 백엔드와 연동하는 Redux Slice
 * - 백엔드 URL 1개당 Slice 파일 1개 생성
 */
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import fetchHelper from '../helpers/FetchHelper';

// 연동할 백엔드 주소 (엔드포인트)
const API_URL = "/grade";

/** Ajax 처리를 위한 함수들 정리 --> CRUD에 따라 하나씩 작성 */
// createAsyncThunk(함수명, 비동기함수(파라미터포함))
export const getList = createAsyncThunk("GradeSlice/getList", async (payload, { rejectWithValue }) => {
  let result = null;

  try {
    result = await fetchHelper.get(API_URL);
  } catch (err) {
    // err 객체는 AxiosHelper에서 throw하는 에러 객체
    result = rejectWithValue(err);
  }

  return result;
});

// Slice 객체 생성 --> 객체 이름은 소스파일명과 동일하게 설정(권장)
const GradeSlice = createSlice({
  // 1) Slice 객체의 이름 --> Slice 객체명과 동일하게 설정(권장)
  name: "GradeSlice",

  // 2) 이 모듈이 관리하고자하는 상태값들을 명시
  // --> Ajax 처리시 백엔드로부터 전달되는 데이터와 로딩 상태를 저장하기 위한 용도
  initialState: {
    status: 200,
    message: "OK",
    item: null,
    timestamp: null,
    loading: false, // <-- 로딩 상태를 감지하기 위해 추가(백엔드와 상관 없음)
  },

  // 3) 상태값을 갱신하기 위한 함수들을 구현한다. (여기서는 사용 안함)
  reducers: {},

  // 4) 비동기 상태값을 갱신하기 위한 함수들을 구현한다.(주로 Ajax 처리)
  // --> initialState와 동일한 구조의 JSON을 리턴해야 한다.
  extraReducers: (builder) => {
    // 백엔드와 연동 객체에 호출된다. --> 로딩중임을 표시
    // meta: {arg, requestId, requestStatus}
    // ==> arg: 컴포넌트에서 액션함수를 호출할 때 전달한 파라미터(payload)
    // ==> payload: 백엔드에서 받은 데이터
    builder.addCase(getList.pending, (state, { meta, payload }) => {
      return { ...state, loading: true };
    });

    builder.addCase(getList.fulfilled, (state, { meta, payload }) => {
      return { ...payload, loading: false };
    });

    builder.addCase(getList.rejected, (state, { meta, payload }) => {
      return {
        ...state,
        loading: false,
        status: payload.status || 0,
        message: payload.message || "Unknown Error"
      };
    });
  }
});

// 리듀서 객체 내보내기
export default GradeSlice.reducer;
``` 

### 📌 1-4. redux에서 ajax활용
- if (item && item.length > 0) return;를 통해 이미 전역변수에 값이 있다면 새로 로드하지 않도록 한다.
```js
  const { loading, status, message, item } = useSelector((state) => state.GradeSlice);

  // dispatch 함수 생성
  const dispatch = useDispatch();

  // 컴포넌트가 마운트되면 데이터 조회를 위한 액션함수를 디스패치 함
  useEffect(() => {
    // 이미 데이터가 있다면 다시 조회하지 않음
    if (item && item.length > 0) return;

    dispatch(getList());
  }, []);
  ```