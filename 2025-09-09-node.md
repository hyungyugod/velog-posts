# 📌 0. express
### 📌 0-1. express 초기세팅
- express() 함수를 호출한다. 이 함수는 Express 애플리케이션 객체를 생성하며 생성된 app 객체는 서버의 핵심 컨트롤러 역할을 한다.
- 즉, 요청(Request)을 받고 응답(Response)을 보내는 전체 흐름을 관리하는 본체가 된다.
- 이 app 객체에다가 미들웨어를 붙임으로써 요청을 가공하거나 보안 설정을 할 수 있으며 또한 라우터를 붙임으로써 URL 경로마다 동작을 분기할 수 있다.
- 서버 포트, 에러 핸들링, 전역 설정 같은 것도 이 객체를 통해 제어하며 따라서 app은 “Express 서버 프로그램의 본체”라고 이해하면 된다.
```js
const app = express();
```
- app.use 메서드를 호출하여 JSON 파싱 미들웨어를 등록한다.
- 이 미들웨어는 클라이언트가 application/json 형식으로 요청 본문을 보냈을 때 자동으로 자바스크립트 객체로 변환하여 req.body에 담아준다.
- 즉, 서버가 JSON 데이터를 쉽게 다룰 수 있도록 해주며 API 개발에서 거의 필수적으로 사용된다.
```js
app.use(express.json());
```
- app.use 메서드를 호출하여 URL-encoded 데이터 파싱 미들웨어를 등록한다.
- 이 미들웨어는 클라이언트가 HTML <form> 전송 같은 방식으로 데이터를 보냈을 때 이를 파싱해 req.body에 담아준다.
- extended: true 옵션은 중첩 객체 구조(예: user[name]=Tom)를 허용하도록 qs 모듈을 사용한다.
- 따라서 단순한 쿼리스트링뿐 아니라 복잡한 폼 데이터도 다룰 수 있게 된다.
```js
app.use(express.urlencoded({ extended: true }));
```
- express.Router() 함수를 호출하여 라우터 객체를 생성한다.
- 이 라우터 객체는 작은 규모의 미니 앱처럼 동작하며 URL 경로별 요청 처리를 모듈화할 수 있다.
- 즉, 라우팅 기능을 분리하여 코드 구조를 깔끔하게 유지하게 해주며 대규모 프로젝트에서 특히 유용하다.
- app.use 메서드를 호출하여 생성한 라우터를 애플리케이션에 연결한다.
- 이 설정으로 인해 클라이언트의 모든 요청은 먼저 router를 거치게 된다.
- 따라서 라우터 안에 정의한 URL 경로 처리 규칙들이 실제 서버 동작에 반영된다.
```js
const router = express.Router();
app.use(router);
```
- router.get 메서드를 호출하여 GET /hello 요청을 처리한다.
- 클라이언트가 /hello 경로로 접근하면 <h1>Hello World</h1>라는 HTML 응답을 전송한다.
- res.send는 문자열, HTML, 버퍼, 객체 등을 클라이언트로 응답할 수 있는 메서드이다.
```js
router.get('/hello', (req, res) => {
res.send('<h1>Hello World</h1>');
});
```
- router.get 메서드를 호출하여 GET /world 요청을 처리한다.
- 클라이언트가 /world 경로로 접근하면 { name: 'Express', type: 'Framework' }라는 JSON 데이터를 응답한다.
- res.json은 객체나 배열을 JSON 형식으로 자동 변환하여 application/json 타입으로 응답한다.
```js
router.get('/world', (req, res) => {
res.json({ name: 'Express', type: 'Framework' });
});
```
- 아래는 전체 코드이다.
```js
import dotenv from 'dotenv';
dotenv.config();

import express from 'express';

const app = express();

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

const router = express.Router();
app.use(router);

router.get('/hello', (req, res) => {
  res.send('<h1>Hello World</h1>');
});

router.get('/world', (req, res) => {
  res.json({ name: 'Express', type: 'Framework' });
});

const port = process.env.HTTP_PORT || 8080;
app.listen(port);

process.on('SIGINT', () => {
  process.exit();
});
```

### 📌 0-2. 다양한 미들웨어
#### 1. 파비콘 제공
```js
app.use(serveFavicon(process.env.FAVICON_PATH));
```
- `serve-favicon` 미들웨어로 파비콘을 제공함.  
- `.env` 파일의 `FAVICON_PATH`에 지정한 경로의 아이콘 파일을 사용함.  
- 브라우저가 `/favicon.ico` 요청을 보낼 때 자동으로 해당 파일을 응답함.  

---

#### 2. 정적 파일 제공
```js
app.use("/", serveStatic(process.env.PUBLIC_PATH));
```
- `serve-static` 미들웨어로 HTML, CSS, JS, 이미지 등을 제공함.  
- `.env` 파일의 `PUBLIC_PATH`에 지정한 폴더를 정적 리소스 경로로 사용함.  
- 예를 들어 `/style.css` 요청이 들어오면, 해당 폴더 안에서 동일한 파일을 찾아 그대로 반환함.  

---

#### 3. HTTP Method Override
```js
app.use(methodOverride("X-HTTP-Method"));            // Microsoft
app.use(methodOverride("X-HTTP-Method-Override"));   // Google/GData
app.use(methodOverride("X-Method-Override"));        // IBM
app.use(methodOverride("_method"));                  // HTML form ?_method=PUT
```
- `method-override` 미들웨어로 `PUT`, `DELETE` 같은 메서드 요청을 지원함.  
- HTML `<form>`은 기본적으로 `GET`과 `POST`만 전송 가능함.  
- 클라이언트가 요청 헤더(`X-HTTP-Method-Override`)나 쿼리스트링(`?_method=PUT`)으로 원하는 메서드를 지정하면 서버가 이를 감지해 실제 메서드를 바꿔 처리함.  
- RESTful API 설계 시 유용하게 쓰임.  

---

#### 4. User-Agent 파싱
```js
app.use(userAgent.express());
```
- `express-useragent` 미들웨어를 등록함.  
- 요청 헤더의 `User-Agent` 정보를 해석해 `req.useragent` 객체를 생성함.  
- 이를 통해 클라이언트의 운영체제(OS), 브라우저 종류, 버전 등을 쉽게 확인할 수 있음.  

---

#### 5. 요청/응답 로깅 (express-winston)
```js
app.use(
  expressWinston.logger({
    winstonInstance: logger,
    meta: false,
    colorize: true,
    msg:
      "[HTTP {{req.method}}/{{res.statusCode}}] " +
      "{{req.protocol}}://{{req.get('host')}}{{decodeURIComponent(req.url)}} " +
      "({{res.responseTime}}ms)"
  })
);
```
- `express-winston` 미들웨어로 요청과 응답에 대한 로그를 자동으로 기록함.  
- `winstonInstance: logger` → winston 기반 로거와 연결함.  
- `meta: false` → 상세 메타데이터는 기록하지 않음.  
- `colorize: true` → 로그를 색상화하여 출력함.  
- `msg` 포맷 → 로그 형식을 직접 지정할 수 있음.  
  - `{{req.method}}` → 요청 메서드 (GET, POST 등)  
  - `{{res.statusCode}}` → 응답 상태 코드 (200, 404 등)  
  - `{{req.protocol}}://{{req.get('host')}}{{decodeURIComponent(req.url)}}` → 요청 URL  
  - `{{res.responseTime}}ms` → 요청 처리에 걸린 시간  

---
