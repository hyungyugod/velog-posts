# 📌 0. 대화 
### 📌 📌 0-1. 접속 url에 관하여
- "jdbc:log4jdbc:mariadb://%s:%d/%s?characterEncoding=utf8&serverTimezone=UTC";
- jdbc: Java SE가 규정한 표준 접속 스킴. DriverManager가 이 접두사를 보고 JDBC 드라이버를 검색한다.​
- 스킴(scheme) 은 URL(정식 명칭 URI)에서 : 앞에 오는 “이 주소를 무슨 규칙으로 해석해야 하는지”를 알려 주는 식별 꼬리표이다. -> 즉 분류표이다.
- log4jdbc: net.sf.log4jdbc.DriverSpy- 가 “진짜” 드라이버 앞에 끼어들어 모든 JDBC 호출과 SQL을 로그로 내보낸다.
- mariadb:// log4jdbc가 내부적으로 MariaDB Connector/J(ex : org.mariadb.jdbc.Driver)를 찾아 호출한다.
- %s:%d/ → 호스트·포트·경로
- characterEncoding=utf8:클라이언트 ↔ 서버 간 문자 인코딩을 UTF‑8로 강제.
- serverTimezone=UTC: JDBC 드라이버가 TIMESTAMP/DATE 값을 클라이언트 시간대로 보정할 때 기준이 되는 서버 TZ를 UTC로 지정.
- TZ: time zone -> 현지시를 구별하는 기준
- UTC: 0° 경도(영국 그리니치) 기준 세계 협정시. DATETIME 계산할때 기준이 됨.

# 1. 삽입, 수정, 삭제
### 📌 1-1. insert 하는 법
- auto_increment 열은 insert문에서 아예 언급하지 않는다.
- rs 생성직후 커서는 '첫 행 앞'에 있다. 하여 next로 한칸이동했을때 비로소 첫번째 행에 위치하는 것이다.
- rs.getInt(1): 현재 행의 첫번째 컬럼값 도출
- getGeneratedKeys(): 새로 생긴 자동 생성 키들을 모아서 반환”
- “키(key)”는 열(column) 자체를 가리키는 말이 아니고, 그 열에 저장된 값(value) 을 의미함. 
- getGeneratedKeys()가 돌려주는 것은 이 PK 열의 값들만 모아둔 ResultSet이지, 컬럼 이름이나 스키마 정보를 담고 있지는 않음.
- conn.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS)에서 원래 두번째 인자로 특정 열을 넣으면 그 열의 정보만 받아볼 수 있다.
- RETURN_GENERATED_KEYS는 내부적으로 Statement 객체에 autoGeneratedKeys = true 플래그가 설정되도록 하며 DB에 자동 생성 키 결과도 달라고 요청하도록 세팅됨. (원래는 따로 값들의 결과를 담고 있지 않음.)
-  드라이버는 INSERT 결과와 함께 온 “생성된 키 값들”을 내부 버퍼(예: generatedKeysResultSet)에 보관합니다.
```java
@Slf4j
public class App05 {
    public static void main(String[] args) {

        // 1) 데이터베이스에 접속하기 위한 정보를 변수로 구성
        String host = "127.0.0.1";
        int port = 9090;
        String username = "root";
        String password = "1234";
        String database = "myschool";

        // 2) 데이터베이스에 접속 준비
        Connection conn = null; // DB접속 객체
        PreparedStatement pstmt = null; // Sql문을 mariadb에 전달하는 객체
        int result;
        ResultSet rs;
        int newPk;
        
        // 접속 주소 구성
        String urlFormat = "jdbc:log4jdbc:mariadb://%s:%d/%s?characterEncoding=utf8&serverTimezone=UTC";
        String url = String.format(urlFormat, host, port, database);
        log.debug("접속주소: "+ url); 

        // mariadb JDBC 드라이버 로드 (클래스를 등록)
        try {
            Class.forName("org.mariadb.jdbc.Driver");

        // DB 접속
        conn = DriverManager.getConnection(url, username, password);

        } catch (ClassNotFoundException e) {
            log.error("Mariadb jdbc 드라이버 로드 실패", e);
        } catch (SQLException e) {
            log.error("mariadb 접속 실패", e);
        }


        // 3. 수행할 sql문을 문자로 준비
        String dname = "신규학과";
        String loc = "위치";
        String phone = "010-1234-1234";
        String email = "hello@gmail.com";
        int ESTABLISHED = 2025;

        String sql = "INSERT INTO departments (dname, loc, phone, EMAIL, ESTABLISHED) VALUES (?, ?, ?, ?, ?);";


        // 4. mysql에게 sql문을 전달하고 결과를 반환받기
        try {
            pstmt = conn.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS); // 새로 저장될 pk값이 필요하다는 의사 전달
            pstmt.setString(1, dname);
            pstmt.setString(2, loc); 
            pstmt.setString(3, phone); 
            pstmt.setString(4, email); 
            pstmt.setInt(5, ESTABLISHED); 

        } catch (SQLException e) {
            log.error("connection이 정상적으로 이루어지지 않았습니다.", e);
        }

        // 5. 저장된 데이터의 수
        try {
            result = pstmt.executeUpdate();
            rs = pstmt.getGeneratedKeys(); // 새로 생긴 자동 생성 키들을 모아서 반환”
            rs.next(); // 다음 값이 있으면 다음값으로 넘김
            newPk = rs.getInt(1); 

        } catch (SQLException e) {
            log.error("대기 상태의 sql문이 존재하지 않습니다.", e);
        }

        // 6. 데이터 베이스 접속 해제
        try {
            conn.close();
        } catch (SQLException e) {
        log.error("db 접속 해제 실패");
        }
}
}
```

### 📌 1-2. update 하는 법
- update sql 수정하고 executeUpdate실행하면 됨.
```java
@Slf4j
public class App06 {
    public static void main(String[] args) {

        // 1) 데이터베이스에 접속하기 위한 정보를 변수로 구성
        String host = "127.0.0.1";
        int port = 9090;
        String username = "root";
        String password = "1234";
        String database = "myschool";

        // 2) 데이터베이스에 접속 준비
        Connection conn = null; // DB접속 객체
        PreparedStatement pstmt = null; // Sql문을 mariadb에 전달하는 객체
        int result;
        
        // 접속 주소 구성
        String urlFormat = "jdbc:log4jdbc:mariadb://%s:%d/%s?characterEncoding=utf8&serverTimezone=UTC";
        String url = String.format(urlFormat, host, port, database);
        log.debug("접속주소: "+ url); 

        // mariadb JDBC 드라이버 로드 (클래스를 등록)
        try {
            Class.forName("org.mariadb.jdbc.Driver");

        // DB 접속
        conn = DriverManager.getConnection(url, username, password);

        } catch (ClassNotFoundException e) {
            log.error("Mariadb jdbc 드라이버 로드 실패", e);
        } catch (SQLException e) {
            log.error("mariadb 접속 실패", e);
        }


        // 3. 수행할 sql문을 문자로 준비
        int id = 501;
        String dname = "수정된 학과";
        String loc = "새로운위치";
        String phone = "010-1234-1234";
        String email = "email@naver.com";
        int ESTABLISHED = 2025;
        String hompage = "https://www.mega.com";

        String sql = "update departments set dname = ?, loc = ?, phone = ?, email = ?, ESTABLISHED = ?, homepage = ? "; // 아래로 내릴때 마지막에 띄어쓰기 하나해두기
        sql += "where id = ?";

        // 4. mysql에게 sql문을 전달하고 결과를 반환받기
        try {
            pstmt = conn.prepareStatement(sql); 
            pstmt.setString(1, dname);
            pstmt.setString(2, loc); 
            pstmt.setString(3, phone); 
            pstmt.setString(4, email); 
            pstmt.setInt(5, ESTABLISHED);
            pstmt.setString(6, hompage); 
            pstmt.setInt(7, id);

        } catch (SQLException e) {
            log.error("connection이 정상적으로 이루어지지 않았습니다.", e);
        }

        // 5. 저장된 데이터의 수
        try {
            result = pstmt.executeUpdate();
            log.debug("수정된 데이터 수: " + result); 

        } catch (SQLException e) {
            log.error("대기 상태의 sql문이 존재하지 않습니다.", e);
        }

        

        // 6. 데이터 베이스 접속 해제
        try {
            conn.close();
        } catch (SQLException e) {
        log.error("db 접속 해제 실패");
        }
}
}
```

### 📌 1-3. delete 하는 법
- sql문만 delete로 수정
```java
@Slf4j
public class App07 {
    public static void main(String[] args) {

        // 1) 데이터베이스에 접속하기 위한 정보를 변수로 구성
        String host = "127.0.0.1";
        int port = 9090;
        String username = "root";
        String password = "1234";
        String database = "myschool";

        // 2) 데이터베이스에 접속 준비
        Connection conn = null; // DB접속 객체
        PreparedStatement pstmt = null; // Sql문을 mariadb에 전달하는 객체
        int result;
        
        // 접속 주소 구성
        String urlFormat = "jdbc:log4jdbc:mariadb://%s:%d/%s?characterEncoding=utf8&serverTimezone=UTC";
        String url = String.format(urlFormat, host, port, database);
        log.debug("접속주소: "+ url); 

        // mariadb JDBC 드라이버 로드 (클래스를 등록)
        try {
            Class.forName("org.mariadb.jdbc.Driver");

        // DB 접속
        conn = DriverManager.getConnection(url, username, password);

        } catch (ClassNotFoundException e) {
            log.error("Mariadb jdbc 드라이버 로드 실패", e);
        } catch (SQLException e) {
            log.error("mariadb 접속 실패", e);
        }


        // 3. 수행할 sql문을 문자로 준비
        int student_id = 10175;
        int subject_id = 1044;
        

        String sql = "delete from enrollments where student_id = ? and subject_id = ?";

        // 4. mysql에게 sql문을 전달하고 결과를 반환받기
        try {
            pstmt = conn.prepareStatement(sql); // 새로 저장될 pk값이 필요하다는 의사 전달
            pstmt.setInt(1, student_id);
            pstmt.setInt(2, subject_id);

        } catch (SQLException e) {
            log.error("connection이 정상적으로 이루어지지 않았습니다.", e);
        }

        // 5. 저장된 데이터의 수
        try {
            result = pstmt.executeUpdate();
            log.debug("삭제된 데이터 수: " + result); 

        } catch (SQLException e) {
            log.error("대기 상태의 sql문이 존재하지 않습니다.", e);
        }

        

        // 6. 데이터 베이스 접속 해제
        try {
            conn.close();
        } catch (SQLException e) {
        log.error("db 접속 해제 실패");
        }
}
}
```

# 📌 2. Mybatis 활용
- Mapper(매퍼) 란, MyBatis에서 Java 메서드와 SQL 쿼리를 연결하는 역할을 하는 중요한 개념으로 SQL 쿼리와 자바 메서드를 서로 연결시켜 주는 중간 매개체이다.
- 나중에 아래 factory에서 만든 세션 객체를 서비스할 클래스에서 열고 mapper를 잔뜩 사용한 뒤에 닫는 구조이다. 초반에 객체를 가져와서 연결을 해주는 과정이 필요하다.
- Mybatis에서는 세션에서 getmapper에 mapper를 클래스명으로 파라미터에 넣어주면 구현체의 객체를 자동 생성해준다.

### 📌# 트랜잭션(Transaction):
- 하나의 작업 단위(처리과정)를 의미하며, 모든 작업이 --성공해야만 최종 적용(commit)--되고, 하나라도 실패하면 전부 취소(rollback) 되어야 하는 원자적 단위(쪼개지지 않는다. 다되거나 혹은 다 안되거나)이다.
- 트랜잭션의 시작은 session = getSqlSession() 하는 순간이고, 커밋/롤백은 개발자가 직접 commit() 또는 rollback()을 호출해야 비로소 db에 해당 반영을 해준다.

### 📌 2-1. MyBatisConnectionFactory
- 세션(SqlSession )은 접속단위 하나를 의미한다.
- 보통 요청 1건마다 세션 1개를 만들어서 처리하고, 작업이 끝나면 닫는 게 일반적인 방식이다.
- 이 factory클래스를 만들고 여기서 싱글턴으로 미리 입력해둔 데이터베이스 연결 소스를 가지고 객체를 생성해둔다. (클래스 초기화 블럭을 통해)
- 이후 mybatis-.getSqlSession() 이런식으로 아래의 static 매서드를 호출하면 만들어둔 싱글턴 객체를 이용하여 세션을 개방한다.
- sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
이 한 줄 안에 평소에 작성하던 JDBC 드라이버 로딩 + 접속 URL 구성 + DB 커넥션 생성 과정이
전부 config.xml에 기반해서 자동으로 실행되고 있는 것이다.
```java
public class MyBatisConnectionFactory {
    /-- 데이터베이스 접속 객체 -/
    // 싱글턴 객체
    private static SqlSessionFactory  sqlSessionFactory;

    /-- XML에 명시된 접속 정보를 읽어들인다. -/
    // -> resources에 xml파일로 설정된 접속정보를 읽어들임.
    // 클래스 초기화 블럭 (static블럭) : 클래스 변수의 복잡한 초기화에 사용되며 클래스가 처음 로딩될 때 한번만 수행된다.
    static {
        // 접속 정보를 명시하고 있는 XML의 경로 읽기
        // --> import java.io.Reader;
        // --> import org.apache.ibatis.io.Resources;
        try {
            Reader reader = Resources.getResourceAsReader("config.xml");

            // sqlSessionFactory가 존재하지 않는다면 생성한다. (reader에서 읽은 걸 파라미터로 넣어서 객체생성 - 빌더패턴)
            if (sqlSessionFactory == null) {
                sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /-- 데이터베이스 접속 객체를 통해 DATABASE에 접속한 세션를 리턴한다. -/
    // --> import org.apache.ibatis.session.SqlSession;
    public static SqlSession getSqlSession() {
        return sqlSessionFactory.openSession();
    }
}
```

### 📌 2-2. Mapper
- 부서 테이블(departments)에 대한 CRUD기능을 정의하는 인터페이스
- 1. Create(생성)  ---> INSERT문   ---> 삽입 기능 구현
- 2. Read(조회)     ---> SELECT문   ---> 조회 기능 구현
- 3. Update(수정)   ---> UPDATE문   ---> 갱신 기능 구현
- 4. Delete(삭제)   ---> DELETE문   ---> 삭제 기능 구현
- MyBatis에서는 Mapper 인터페이스의 메서드와 Beans를 매핑하여 실행
- (= 어떤 메서드가 어떤 SQL을 실행할지 연결해준다)
- (= SQL의 결과를 어떤 자바 객체로 변환할지 설정한다)
- INSERT, UPDATE, DELETE의 경우 --> 반환타입은 int --> 처리된 데이터의 건수를 의미한다.
- SELECT - 1건 조회 : Beans 클래스 객체 리턴
- SELECT - 다건 조회 : List<Beans 클래스> 리턴
- 주의 : 메서드는 자유롭게 작성 가능
- MyBatis에서 SQL에 #{dname}처럼 작성하면, 전달된 객체에서 getDname() 메서드를 자동으로 호출해서 그 값을 SQL에 바인딩한다. 즉, 파라미터 이름을 기반으로 해당 필드의 getter 메서드를 찾아 사용하는 방식이다.
- 한행 조회, 삭제, 수정은 보통 primary key를 where절 조건에서 언급하여 사용한다.
```java
@Mapper
public interface DepartmentMapper {
    /**
      * 부서 정보를 저장한다.
      * 
      * --> INSERT 실행 + PK에 대한 값 추출
      * --> useGeneratedKeys : AUTO_INCREMENT가 적용된 컬럼이면 공유 사용
      * --> keyProperty : 리턴받을 결과값을 MODEL 객체에서 PK에 대응되는 '멤버변수'
      * --> keyColumn : 테이블의 Primary Key '컬럼명'
      * 
      * @param input - 저장할 데이터에 대한 정보를 담고 있는 객체
      * @return 저장된 데이터의 건수
      */
    @Insert("INSERT INTO departments (dname, loc, phone, email, established, homepage) VALUES (#{dname}, #{loc}, #{phone}, #{email}, #{established}, #{homepage})")
    @Options(useGeneratedKeys = true, keyProperty = "id", keyColumn = "id") // 자동 생성키(id)의 정보를 가지고 있음.
    public int insert(Department input);

    /**
      * 부서 정보를 수정한다.
      * 
      * @param input - 수정할 데이터에 대한 정보를 담고 있는 객체
      * @return 수정된 데이터의 건수
      */
    @Update("UPDATE departments SET " +
            "dname=#{dname}, loc=#{loc}, phone=#{phone}, email=#{email}, established=#{established}, homepage=#{homepage} " +
            "WHERE id=#{id}")
    public int update(Department input);

    /**
      * 부서 정보를 삭제한다.
      * 
      * @param input - 삭제할 대상의 정보를 담고 있는 객체
      * @return 삭제된 데이터의 건수
      */
    @Delete("DELETE FROM departments WHERE id=#{id}")
    public int delete(Department input);

    /**
      * 부서 정보 상세 조회 (1건)
      * 
      * @param input - 조회할 대상의 정보를 담고 있는 객체
      * @return 조회된 데이터
      */
    @Select("SELECT id, dname, loc, phone, email, established, homepage FROM departments WHERE id=#{id}")
    public Department selectOne(Department input);

    /**
      * 부서 정보 목록 조회 (다건)
      * 
      * @param input - 조회 조건을 담고 있는 객체
      * @return 조회된 데이터 목록
      */
    @Select("SELECT id, dname, loc, phone, email, established, homepage FROM departments")
    public List<Department> selectList(Department input);
}
```

### 📌 2-3. "config.xml" (데이터베이스 접근을 위해 미리 만들어두는 파일)
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">

<configuration>
    <!-- MySQL 접속 정보를 지정한다. -->
    <properties>
        <property name="hostname" value="127.0.0.1" />
        <property name="portnumber" value="9090" />
        <property name="database" value="myschool" />
        <property name="username" value="root" />
        <property name="password" value="1234" />
    </properties>

    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC" />
            <dataSource type="POOLED">
                <property name="driver" value="org.mariadb.jdbc.Driver" />
                <property name="url" value="jdbc:log4jdbc:mariadb://${hostname}:${portnumber}/${database}?characterEncoding=UTF8&amp;serverTimezone=UTC" />
                <property name="username" value="${username}" />
                <property name="password" value="${password}" />
            </dataSource>
        </environment>
    </environments>

    <!-- 실행할 SQL문을 정의한 Mapper XML의 경로를 지정한다. -->
    <mappers>
        <!-- XML Mapper -->
        <!-- <mapper resource="mappers/DepartmentMapper.xml" /> -->
        <!-- Interface Mapper (Java 소스파일의 위치 지정) -->
        <!-- <mapper class="kr.hyungyu.mappers.DepartmentMapper" /> -->
        <!-- Package Mapper (특정 패키지 내의 모든 소스코드 자동 인식 )-->
        <package name="kr.hyungyu.mappers"/>
    </mappers>
</configuration>
```

### 📌 2-4. Mapper 활용한 insert 문
- 1. getMapper(...) 호출
- 2. MyBatis가 DepartmentMapper 인터페이스를 분석
- 3. 이 인터페이스를 구현하는 익명 프록시 클래스를 동적으로 생성
- 4. 내부적으로 XML의 SQL과 연결하는 코드로 채워짐
- 5. mapper를 통해 메서드 호출 → SQL 실행

### 📌# ✅ SqlSession의 주요 역할 요약

| 기능            | 설명                                                         |
|-----------------|--------------------------------------------------------------|
| 1. SQL 실행     | `select`, `insert`, `update`, `delete` 실행                 |
| 2. 트랜잭션 관리 | 수동 커밋/롤백 가능 (`commit()`, `rollback()`)             |
| 3. Mapper 제공  | `getMapper()`를 통해 Mapper 인터페이스 객체 얻기           |
| 4. 연결 닫기    | DB 연결을 닫는 `close()` 제공                                |

### 📌# log4jdbc 라이브러리
- 디버깅용 라이브러리인 log4jdbc를 설치하면 아래 로그를 어떤 설정을 하지 않아도 자동으로 남겨준다. 라이브러리를 다운받고 connection을 형성할때 제공하는 url에 포함한다.
[DEBUG] 25-04-21 17:31:07 [insert:135] - ==>  Preparing: INSERT INTO departments (dname, loc, phone, email, established, homepage) VALUES (?, ?, ?, ?, ?, ?)
[DEBUG] 25-04-21 17:31:07 [insert:135] - ==> Parameters: 새로운 학과(String), B-1(String), 010-1234-1234(String), hyungyu@naver.com(String), 2020(Integer), https://hyungyu.com(String)
[INFO ] 25-04-21 17:31:07 [sqlonly:228] - INSERT INTO departments (dname, loc, phone, email, established, homepage) VALUES ('새로운 학과', 'B-1', '010-1234-1234', 'hyungyu@naver.com', 2020, 'https://hyungyu.com')
[DEBUG] 25-04-21 17:31:07 [insert:135] - <==    Updates: 1
[INFO ] 25-04-21 17:31:07 [resultsettable:610] - 

```java
@Slf4j
public class App01 {
    public static void main(String[] args) {
        // 1. mybatis 설정 파일의 내용을 로드하는 접속 새션 생성 및 Mapper로드
        SqlSession sqlSession = MyBatisConnectionFactory.getSqlSession(); // 싱글턴 세션 객체를 리턴하는 메서드 호출
        DepartmentMapper departmentMapper = sqlSession.getMapper(DepartmentMapper.class); // 인터페이스도 클래스의 일종 하여 이와 같은 방식으로 클래스 정보를 넘긴다.

        // 2. 저장할 데이터를 beans 클래스의 객체로 준비
        Department input = new Department();
        input.setDname("새로운 학과");
        input.setLoc("B-1");
        input.setPhone("010-1234-1234");
        input.setEmail("hyungyu@naver.com");
        input.setEstablished(2020);
        input.setHomepage("https://hyungyu.com");

        // 3. Mapper에 구현되어있는 매서드를 호출하여 SQL문을 실행
        int output = departmentMapper.insert(input); // mapper에 정의된 insert문 사용

        // 4. 결과 판별
        log.debug("저장된 데이터의 수 " + output);
        log.debug("생성된 primary key " + input.getId()); // 생성된 primary키는 입력파라미터 객체에 셋팅된다.

        // 5. 데이터 베이스 접속 해제
        sqlSession.commit(); // 커밋해야 트랜젝션이 완료됨.
        sqlSession.close(); // 세션의 연결을 꼭 닫아주어야함.
    }   
}
```

### 📌 2-5. Mapper 활용한 update문
```java
@Slf4j
public class App02 {
    public static void main(String[] args) {
        // 1. mybatis 설정 파일의 내용을 로드하는 접속 새션 생성 및 Mapper로드
        SqlSession sqlSession = MyBatisConnectionFactory.getSqlSession(); // 싱글턴 세션 객체를 리턴하는 메서드 호출
        DepartmentMapper departmentMapper = sqlSession.getMapper(DepartmentMapper.class); // 인터페이스도 클래스의 일종 하여 이와 같은 방식으로 클래스 정보를 넘긴다.

        // 2. 저장할 데이터를 beans 클래스의 객체로 준비
        Department input = new Department();
        input.setId(511); // 값을 수정할 것이기 때문에 수정할 위치의 아이디도 같이 첨부한다.
        input.setDname("수정된 학과");
        input.setLoc("B-2");
        input.setPhone("010-1234-1234");
        input.setEmail("hyun@naver.com");
        input.setEstablished(2020);
        input.setHomepage("https://hyungyu.com");

        // 3. Mapper에 구현되어있는 매서드를 호출하여 SQL문을 실행
        int output = departmentMapper.update(input); // mapper에 정의된 update문 사용

        // 4. 결과 판별
        log.debug("수정된 데이터의 수 " + output);

        // 5. 데이터 베이스 접속 해제
        sqlSession.commit(); // 커밋해야 트랜젝션이 완료됨.
        sqlSession.close(); // 세션의 연결을 꼭 닫아주어야함.
    }   
}
```

### 📌 2-6. Mapper 활용한 delete문
```java
@Slf4j
public class App03 {
    public static void main(String[] args) {
        // 1. mybatis 설정 파일의 내용을 로드하는 접속 새션 생성 및 Mapper로드
        SqlSession sqlSession = MyBatisConnectionFactory.getSqlSession(); // 싱글턴 세션 객체를 리턴하는 메서드 호출
        DepartmentMapper departmentMapper = sqlSession.getMapper(DepartmentMapper.class); // 인터페이스도 클래스의 일종 하여 이와 같은 방식으로 클래스 정보를 넘긴다.

        // 2. 삭제할 데이터를 beans 클래스의 객체로 준비
        Department input = new Department();
        input.setId(511); // 행 전체를 삭제할 것이기 때문에 수정할 위치의 아이디만 첨부

        // 3. Mapper에 구현되어있는 매서드를 호출하여 SQL문을 실행
        int output = departmentMapper.delete(input); // mapper에 정의된 delete문 사용

        // 4. 결과 판별
        log.debug("삭제된 데이터의 수 " + output);

        // 5. 데이터 베이스 접속 해제
        sqlSession.commit(); // 커밋해야 트랜젝션이 완료됨.
        sqlSession.close(); // 세션의 연결을 꼭 닫아주어야함.
    }   
}
```

### 📌 2-7. Mapper 활용한 selectone문
```java
@Slf4j
public class App04 {
    public static void main(String[] args) {
        // 1. mybatis 설정 파일의 내용을 로드하는 접속 새션 생성 및 Mapper로드
        SqlSession sqlSession = MyBatisConnectionFactory.getSqlSession(); // 싱글턴 세션 객체를 리턴하는 메서드 호출
        DepartmentMapper departmentMapper = sqlSession.getMapper(DepartmentMapper.class); // 인터페이스도 클래스의 일종 하여 이와 같은 방식으로 클래스 정보를 넘긴다.

        // 2. 조회할 데이터를 beans 클래스의 객체로 준비
        Department input = new Department();
        input.setId(510); 

        // 3. Mapper에 구현되어있는 매서드를 호출하여 SQL문을 실행
        Department output = departmentMapper.selectOne(input); // mapper에 정의된 delete문 사용

        // 4. 결과 
        log.debug("조회결과 " + output.toString());

        // 5. 데이터 베이스 접속 해제
        sqlSession.close(); // 세션의 연결을 꼭 닫아주어야함.
    }   
}
```

### 📌 2-8. Mapper 활용한 selectlist문
- 어짜피 전체를 조회하기 때문에 객체를 따로 생성할 필요가 없다.
```java
@Slf4j
public class App05 {
    public static void main(String[] args) {
        // 1. mybatis 설정 파일의 내용을 로드하는 접속 새션 생성 및 Mapper로드
        SqlSession sqlSession = MyBatisConnectionFactory.getSqlSession(); // 싱글턴 세션 객체를 리턴하는 메서드 호출
        DepartmentMapper departmentMapper = sqlSession.getMapper(DepartmentMapper.class); // 인터페이스도 클래스의 일종 하여 이와 같은 방식으로 클래스 정보를 넘긴다.

        // 2. 전부 조회할 것이므로 객체를 따로 준비할 필요가 없음.

        // 3. Mapper에 구현되어있는 매서드를 호출하여 SQL문을 실행
        List <Department> output = departmentMapper.selectList(null); // mapper에 정의된 delete문 사용

        // 4. 결과 
        log.debug("조회결과 " + output.toString());

        // 5. 데이터 베이스 접속 해제
        sqlSession.close(); // 세션의 연결을 꼭 닫아주어야함.
    }   
}
```


