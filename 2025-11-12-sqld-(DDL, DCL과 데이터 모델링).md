# 📌 1. CREATE 테이블 명명: 단수 명사 사용과 특수문자 허용 이유

## 1-1. 단수 명사(영문 기준) 사용 권장 배경
- **집합의 원소 관점**: 테이블은 동형 레코드의 집합이고, 각 행은 **엔터티 인스턴스(개체 1건)** 이다. 따라서 이름은 원소의 이름(단수)이 의미적으로 정확하다. 예) `Customer` 테이블의 각 행은 *한 고객*.
- **언어적 일관성**: 도메인 주도 설계(DDD)와 ORM 매핑에서 `Customer` ↔ 객체 1개가 자연스럽다. 복수형은 `$Customers[i]$`처럼 **컨테이너 이름**에 가깝다.
- **SQL 가독성**: 조인 시 의미 해석이 단수일 때 명확하다. 예) `SELECT * FROM Order JOIN Customer ...` 는 “주문-고객” 관계를 직관적으로 드러낸다.
- **암묵 규약의 이점**: 컬럼/관계, API 경로 설계(REST)에서 명명 충돌·불규칙을 줄인다.

> 표준 강제는 아니다. 팀 규칙으로 복수형을 쓰기도 한다. 핵심은 **일관성**이다.

## 1-2. `_`, `#`, `$`만 허용되는 역사·의미(주요 상용 DB 기준의 보수적 규약)
- **초기 SQL 파서 제약**: 알파벳·숫자·언더스코어(`_`) 조합이 가장 이식성이 높았다. 일부 DB는 기호를 예약(연산자/바인드)으로 사용.
- **`$`**: Oracle 등에서 내부/시스템 객체 식별에 관습적으로 사용되며, 사용자 스키마에서도 허용된 역사 존재. 예: `USER$` 같은 데이터 사전 테이블.
- **`#`**: SQL Server에서 임시 테이블 프리픽스(`#`,`##`)로 자리 잡음. 식별자 허용 집합에 포함.
- **보수적 가이드**: 다른 특수문자는 드라이버/툴체인/ETL에서 이스케이프 이슈를 야기. 이식성 확보를 위해 **영문 + 숫자 + `_`**(필요 시 `$`, `#`) 권장.

---

# 📌 2. UNIQUE가 NULL을 허용하는 이유 & CHECK 제약 요약

## 2-1. UNIQUE와 NULL
- **수학적 의미**: UNIQUE는 “서로 **서로 다른 값**(distinct values)” 제약이다. SQL에서 **NULL은 ‘알 수 없음’** 이므로, 서로 비교 불가($NULL \neq NULL$, $NULL$은 어떤 값도 아님).  
- **결과**: 다수의 NULL을 허용해도 **값의 중복**으로 보지 않는다.
- **예외**: DBMS에 따라 **필터 인덱스/부분 인덱스**로 `NULL` 처리 방식을 바꾸는 전략은 가능하나, 표준 의미는 위와 같다.

## 2-2. CHECK 제약 정리
- **정의**: 행 단위로 논리식이 참이어야 저장 가능. 예) `CHECK (qty >= 0 AND status IN ('N','Y'))`.
- **평가 시점**: DML 시점(INSERT/UPDATE). DDL 트랜잭션에 포함(Oracle은 DDL auto-commit이지만, `ALTER TABLE ... ADD CONSTRAINT` 실행 단위로 롤백 불가).
- **NULL과 CHECK**: 조건식에 NULL이 개입하면 **UNKNOWN** → 일반적으로 **통과**. 필요 시 `IS NOT NULL`로 명시.
- **권장**: 도메인 제약은 CHECK로 모델에 귀속하여 **데이터 무결성**을 스키마 레벨에서 보장.

---

# 📌 3. 외래키 ON DELETE/UPDATE 옵션: Oracle vs SQL Server

## 3-1. 지원 옵션 비교
| 옵션 | 의미 | Oracle | SQL Server |
|---|---|---|---|
| CASCADE | 부모 삭제/변경 시 자식도 함께 | ✅(DELETE) / ❌(UPDATE) | ✅ |
| SET NULL | 부모 삭제/변경 시 FK를 NULL | ✅(DELETE) / ❌(UPDATE) | ✅ |
| SET DEFAULT | FK를 DEFAULT 값으로 | ❌ | ✅ |
| NO ACTION | 제약 위반 시 오류(지연평가 가능) | ✅ | ✅ |
| RESTRICT | 즉시 검사(Oracle 기본 동작 개념) | ✅ | ❌(NO ACTION과 유사 처리) |

## 3-2. 기본값
- **Oracle**: `ON DELETE` 미지정 시 **RESTRICT/NO ACTION** 동등 의미. `ON UPDATE` 미지원.
- **SQL Server**: `NO ACTION` 기본. `ON UPDATE` 지원.

---

# 📌 4. ALTER 차이(Oracle vs SQL Server) — “기적의 TIP” 해설

| 항목 | Oracle | SQL Server | 이유 |
|---|---|---|---|
| 여러 속성 동시 변경 | `MODIFY (col ... , col ...)` | `ALTER COLUMN` 단위 | 선언적 vs 명령적 DDL 철학 |
| 괄호 사용 | ✅ | ❌ | 다중 속성 서술 |
| DEFAULT 변경 | `MODIFY ... DEFAULT ...` | `ADD CONSTRAINT DF_... DEFAULT ... FOR col` | SQL Server는 DEFAULT를 **제약 객체**로 관리 |

---

# 📌 5. DELETE vs TRUNCATE vs DROP

| 구분 | DELETE | TRUNCATE | DROP |
|---|---|---|---|
| 분류 | DML | DDL | DDL |
| WHERE | 가능 | 불가 | 불필요 |
| 롤백 | 가능 | 불가 | 불가 |
| 실행 후 테이블 | 존재 | 존재 | 삭제 |
| 속도 | 느림(로그 상세) | 빠름(페이지 해제, 최소 로그) | 가장 빠름(객체 제거) |
| 인덱스/구조 | 유지 | 구조 유지(인덱스 재생성) | 모두 제거 |

---

# 📌 6. VIEW의 DML 가능 조건

## 6-1. 단일 테이블 기반 뷰만 업데이트 가능(일반 규칙)
- **이유**: 뷰는 SELECT의 **함수적 결과**. DML은 역함수 적용이 필요. **원본 행 일대일 추적**이 가능해야 함.
- **불가 사례**: JOIN, GROUP BY, DISTINCT, 집계, UNION 포함 뷰.
- **예외**: `INSTEAD OF TRIGGER`로 명시적 라우팅 구현 시 가능.

---

# 📌 7. ALTER TABLE로 컬럼 삭제: Oracle vs SQL Server

| 항목 | Oracle | SQL Server |
|---|---|---|
| 기본 문법 | `ALTER TABLE T DROP COLUMN c;` 또는 `DROP (c1,c2)` | `ALTER TABLE T DROP COLUMN c1, c2;` |
| 제약 삭제 | `CASCADE CONSTRAINTS` 지원 | 선(先) `DROP CONSTRAINT` 필요 |
| DEFAULT | 컬럼과 함께 제거 | DEFAULT 제약은 별도 객체이므로 먼저 제거 |
| 내부 처리 | 지연/논리 삭제 후 물리 정리 가능 | 즉시 물리 변경 |

---

# 📌 8. DROP TABLE 요약 (Oracle/SQL Server)

- 공통: `DROP TABLE T;` → 구조/데이터/제약/인덱스 제거, DDL 자동 커밋, 롤백 불가.
- **Oracle**: Recycle Bin 존재 → `FLASHBACK TABLE ... TO BEFORE DROP` 복구 가능, 완전 삭제는 `PURGE`.
- **SQL Server**: `IF EXISTS` 지원, 휴지통 없음(즉시 카탈로그 제거).

---

# 📌 9. 권한: 시스템 권한 vs 객체 권한, WITH GRANT/ADMIN OPTION, CASCADE

## 9-1. 시스템 권한 vs 객체 권한
| 구분 | 시스템 권한 | 객체 권한 |
|---|---|---|
| 대상 | DB 전반(접속/생성 등) | 특정 객체(테이블/뷰/시퀀스) |
| GRANT | `GRANT CREATE SESSION TO A;` | `GRANT SELECT ON T TO A;` |
| ON 키워드 | 사용 안 함 | 사용 |
| 부여주체 | 주로 DBA | 객체 소유자/DBA |

## 9-2. WITH GRANT OPTION vs WITH ADMIN OPTION
| 항목 | WITH GRANT OPTION | WITH ADMIN OPTION |
|---|---|---|
| 대상 | **객체 권한** 재부여 | **시스템 권한/ROLE** 재부여 |
| REVOKE 영향 | **Oracle: 연쇄 회수(CASCADE)**, SQL Server: 비연쇄 | 연쇄 회수 없음(둘 다) |

- **CASCADE 의미**: 의존 관계를 따라 **전달된 권한까지 제거**.

## 9-3. 기본 ROLE
| ROLE | 핵심 권한 | 목적 |
|---|---|---|
| CONNECT | `CREATE SESSION` | 로그인 |
| RESOURCE | 객체 생성 권한 | 개발자용 |
| DBA | 광범위 시스템 권한 | 전체 관리 |

> Oracle 12c 이후 CONNECT 권한 구성은 축소/변경됨.

---

# 📌 10. 모델링 3단계: 개념 → 논리 → 물리

| 단계 | 산출물 | 핵심 활동 |
|---|---|---|
| 개념적 | 개념 ERD(엔터티·관계) | 엔터티·관계 식별 |
| 논리적 | 속성 포함 ERD, 정규화 | PK/FK·제약, $1$~$3$NF |
| 물리적 | DDL/인덱스/쿼리 | 반정규화, 성능, 파티션/튜닝 |

---

# 📌 11. 엔터티는 집합인가? 인스턴스 수와 관계 필요성

- **집합적 정의**: 엔터티는 동형 인스턴스의 **집합**. 이론 전제는 “복수 가능성”이지만 실제 데이터가 **1건이어도 엔터티**가 될 수 있다.
- **고립 엔터티**: 업무상 독립 의미가 있으면 관계가 없어도 가능(예: `CompanyInfo`, `Config`). 다만 핵심 비즈니스 엔터티는 관계를 갖는 편이 모델 완결성에 유리.

---

# 📌 12. 엔터티 유형 분류: 유형/개념/사건

| 구분 | 정의 | 예시 |
|---|---|---|
| 유형 엔터티 | 물리적 실체 | 고객, 상품, 차량 |
| 개념 엔터티 | 분류·코드·조직 개념 | 부서, 직급, 지역 |
| 사건 엔터티 | 시간 기반 행위/트랜잭션 | 주문, 결제, 예약 |

---

# 📌 13. 속성 분류

## 13-1. 특성 기준
| 유형 | 정의 | 예시 |
|---|---|---|
| 기본속성 | 현실 데이터 자체 | 이름, 생년월일 |
| 설계속성 | 식별/관리용 인위 속성 | 고객ID, 코드 |
| 파생속성 | 계산/집계 결과 | 나이, 총금액(단가×수량) |

## 13-2. 구성 방식 기준
| 유형 | 정의 | 예시 |
|---|---|---|
| PK | 유일 식별 | 학번, 주문번호 |
| FK | 관계 표현 | 주문의 고객ID |
| 일반속성 | 부가 정보 | 주소, 전화 |

---

# 📌 14. IE vs Barker: 표기 핵심(‘1’ 사용 여부, 선택성 표기)

| 항목 | IE | Barker |
|---|---|---|
| 카디널리티 표기 | 숫자 `1`, `N` 명시 | 숫자 미표기(선/기호) |
| 선택성(최소 참여) | **점선**=선택, **실선**=필수 | **O(원)**=선택, 실선=필수 |
| 초점 | 정량(수치) | 시각(형태) |

- 해석 팁: 실선=끊김 없음=필수, 점선=끊김 가능=선택, 원(O)=비어있음 허용(최소 $0$).

---

# 📌 15. 점선·실선·O의 설계 의미(시각 기호학)

| 기호 | 의미 | 데이터베이스 대응 |
|---|---|---|
| 실선 | 존재의 연속(강제) | FK NOT NULL, 필수 참여 |
| 점선 | 존재의 단절 가능 | FK NULL 허용, 선택 참여 |
| O | 비어있음 허용(선택) | 최소 카디널리티 $0$ |

---

# 📌 16. 통계성 엔터티의 독립성

- **생성은 종속**: 원시 데이터 집계로 생성.
- **존재는 독립**: 생성 후 별도 테이블로 **자체 생명주기**·참조 가능. FK 없이도 관리(의사결정 지표).  
- 정리: 논리적으로는 의존, 물리적으로는 독립.

---

# 📌 17. 식별자(Identifier) 분류 4축

| 기준 | 유형 | 요지 | 예시 |
|---|---|---|---|
| 대표성 | 주식별자 / 보조식별자 | 대표 PK / 대체 유일 | 학번 / 이메일 |
| 자생성 | 내부 / 외부 | 자체 생성 / 외부 유입(FK) | 주문번호 / 참조코드 |
| 단일성 | 단일 / 복합 | 1컬럼 / 다컬럼 | 주민번호 / (과목,학기) |
| 대체성 | 본질 / 인조 | 현실 속성 / 설계 ID | 사업자번호 / 일련ID |

---

# 📌 18. IE vs Barker: 식별/비식별 관계 표기

| 관계 | IE | Barker | 의미 |
|---|---|---|---|
| 식별관계 | 실선 | 실선 | 부모 PK ⊂ 자식 PK(존재 종속) |
| 비식별관계 | 점선 | 점선 | 부모 PK → 자식 **FK만**(PK 미포함) |

---

# 📌 19. 비식별관계 = 값 복사인가?

- **아님**: 비식별관계도 **FK 제약을 둔다**. 단, 자식 PK에는 포함되지 않아 **존재 독립성**이 있다.
- 구현 예:  
  `PRIMARY KEY (order_id)` 와 별개로 `FOREIGN KEY (customer_id) REFERENCES customer(customer_id)`.
- 비유: 구성(Composition)=식별관계, 집합(Aggregation)=비식별관계.

---

# 📌 20. 기억해둘 연결식(개념 ↔ 구현)

- **실선/점선/O** ↔ 최소참여(필수/선택) ↔ `NULL` 허용 여부.
- **식별/비식별** ↔ PK 포함 여부 ↔ 조인 키 설계.
- **UNIQUE & NULL** ↔ $NULL$은 값이 아님(중복 판단 제외).
- **VIEW DML** ↔ 역함수 가능성(일대일 추적 가능 여부).
- **정규화/반정규화** ↔ 무결성 ↔ 성능 트레이드오프.
