
# 📌 1. 보고서 그룹화와 Count 함수

## 1-1. 보고서 그룹화의 기본 개념
Access 보고서에서 그룹화는 특정 필드를 기준으로 레코드를 묶는 기능이다.  
이때 Access 보고서 엔진은 다음과 같은 단계를 따른다:

1. **그룹 기준 필드를 기준으로 정렬**
2. **같은 값을 가진 레코드를 하나의 그룹(chunk)으로 구성**
3. **각 그룹마다 헤더, 디테일, 푸터 섹션을 출력**
4. **해당 그룹 내부에서만 작동하는 통계 함수들이 처리됨**

이 구조는 SQL로 표현하면 내부적으로 `GROUP BY`에 해당하는 개념이지만, Access는 화면 기반 문서 엔진으로 동작하기 때문에 보고서 렌더링 과정에서 그룹 계산을 수행한다.

즉,
> 그룹화 = “데이터를 여러 개의 독립된 소규모 테이블로 나누고, 각 테이블별로 별도의 출력 구조를 만들어내는 과정”

## 1-2. 그룹화 후 Count 함수의 동작 원리
그룹 푸터나 헤더에 `=Count([필드명])`을 사용하면 Access는 **그 그룹**에 속한 레코드 개수를 계산한다.

Count 함수는 다음 규칙을 따른다:

- Null 값은 세지 않는다.
- 그룹화 후 Count는 “현재 렌더링 중인 그룹 chunk 내부 레코드만” 대상으로 한다.
- 정확한 레코드 수를 얻으려면 **Null이 없는 필드(예: 기본키 ID)**를 Count하는 것이 안전하다.

---

# 📌 2. 보고서 인쇄: 행 탭이 없고 열 탭만 있는 이유 & 데이터만 인쇄

## 2-1. 왜 행(tab)은 없고 열(tab)만 있는가?
Access 보고서는 **엑셀처럼 셀 기반 구조가 아니라 ‘문서 기반 레이아웃 엔진’**을 따른다.  
따라서:

- **행(Row)**: 디테일 섹션이 데이터 개수만큼 자동으로 반복되므로 사람이 설계할 필요가 없다.
- **열(Column)**: 인쇄 시 종이를 가로로 몇 개의 열로 나눌지 설계자가 직접 지정해야 한다.

Access 보고서는 기본적으로 “위에서 아래로 자동 흐르는 구조”이기 때문에 행을 직접 설계하지 않고, 대신 열 배치를 설계하는 UI를 제공한다.

정리:

> Access 보고서의 행은 자동 생성되는 구조, 열은 사람이 설계하는 구조 → 그래서 열 탭만 존재.

## 2-2. "데이터만 인쇄" 기능의 의미
“데이터만 인쇄”를 선택하면 Access는 텍스트 필드의 값만 인쇄하고,  
다음 요소는 인쇄하지 않는다:

- 레이블(Label)
- 선(Line)
- 사각형(Rectangle)
- 배경
- 기타 UI 장식 요소

이 기능의 설계 이유:
> 이미 인쇄된 종이 양식(정부 문서, 병원 문서, 회사 양식 등)에 데이터를 정확한 위치에만 찍도록 하기 위함.

예:

- 병원에서 ‘입원기록지’가 이미 인쇄된 종이로 존재한다고 하자.
- Access 보고서에서 해당 양식과 같은 구조로 컨트롤만 맞춰놓고
- 인쇄 시 “데이터만 인쇄”를 사용하면  
  → 종이의 틀은 그대로, Access는 텍스트만 출력  

즉:
> Access는 데이터만 출력하고, 양식 틀은 종이가 담당하는 모드이다.

---

# 📌 3. Excel 매크로 vs Access 매크로

## 3-1. Excel 매크로 (VBA 기반 자동화 엔진)
엑셀 매크로는 사실상 **VBA 스크립트**다.

- 셀 조작
- 수식 입력
- 파일 생성/저장
- 반복문, 조건문 사용
- 엑셀 객체 모델을 직접 제어

설계 철학:
> “문서 조작을 프로그래밍할 수 있도록 하여 자동화를 극대화하자.”

## 3-2. Access 매크로 (액션 기반 UI 제어 시스템)
Access의 매크로는 코드가 아니다.  
Access가 제공하는 **액션(Action)**을 조합하는 구조이다.

- OpenForm
- OpenReport
- RunQuery
- GoToRecord
- MessageBox
- If 조건 실행

설계 철학:
> “프로그래밍을 모르는 사용자도 데이터베이스 앱의 흐름을 구성할 수 있게 만들자.”

결론:

- Excel = 프로그래밍 기반 자동화
- Access = UI/데이터 흐름 제어 중심의 액션 매크로

---

# 📌 4. ExportWithFormatting (서식 포함 출력)

## 4-1. 기능 의미
보고서/폼을 외부 파일로 내보낼 때 Access 내부의 서식(글꼴, 정렬, 그룹 구조, 머리글 등)을 그대로 유지하여 PDF·RTF·Excel 등으로 출력하는 기능이다.

즉:
> “Access 보고서를 하나의 문서처럼 외부에 내보내는 기능”

## 4-2. 동작 원리
Access 보고서는 두 가지 렌더링 모드를 가진다:

1. **화면(Screen) 출력용 렌더링**
2. **인쇄(Print) 출력용 렌더링**

ExportWithFormatting은 보고서 엔진이 만든 인쇄/화면 결과물을 그대로 문서(PDF 등)로 변환한다.

설계 철학:
> 보고서는 단순 데이터 표가 아니라 문서(document)이므로, 문서 그대로 외부로 재현할 수 있어야 한다.

---

# 📌 5. Access 이벤트 / 이벤트 속성

## 5-1. 이벤트(Event)
Access 이벤트는 **시스템 또는 사용자가 유발한 특정 시점**을 의미:

- On Open (폼/보고서가 열릴 때)
- On Load (데이터가 로딩될 때)
- On Current (레코드 이동할 때)
- On Click (컨트롤 클릭)
- Before Update / After Update (값 저장 전/후)

Access 이벤트의 본질:
> "지금 이런 상황이 발생했고, 실행할 행동이 있으면 수행하겠다."

## 5-2. 이벤트 속성(Event Property)
폼/컨트롤의 속성 시트에 있는 이벤트 항목:

예:
- On Click
- On Load
- Before Update
- On Current

이 칸에 다음을 지정한다:

- 매크로 이름
- `[Event Procedure]` (VBA 프로시저 호출)

즉:
> 이벤트 속성 = 이벤트가 발생했을 때 실행할 동작을 담아두는 슬롯.

---

# 📌 6. JavaScript 이벤트 vs Access 이벤트 철학 비교

## 6-1. JavaScript 이벤트
JavaScript는 **DOM 객체 중심** 구조다.

- `event` 객체가 제공됨
- 클릭 좌표, 키 코드, 전파(bubbling/capturing) 정보 포함
- addEventListener로 이벤트 핸들러를 연결

설계 철학:
> “사용자 인터페이스의 모든 맥락을 개발자에게 자세히 제공하자.”

## 6-2. Access 이벤트
Access는 **상태 전이(state transition)** 중심.

- event 객체 없음
- 특정 시점에 도착했음을 알려주는 신호만 제공
- 필요한 최소 정보(KeyCode 등)만 전달

설계 철학:
> “폼·데이터의 상태 변화에 필요한 동작을 연결하도록 한다.”

결론 요약:
- JS = “객체 중심 이벤트 시스템”
- Access = “상태 중심 이벤트 시스템”

---

# 📌 7. Caption / Name / 이벤트 프로시저 이름

## 7-1. Caption
사용자가 화면에서 보는 글자.

예:
- 버튼 표면의 텍스트
- 레이블의 표시 문자열
- 폼 창 제목

## 7-2. Name
코드 내부에서 컨트롤을 식별하는 이름.

예:
- `cmd실행`
- `txt이름`

사용자에게 보이지 않음.

## 7-3. `cmd실행_Click`에서 언더스코어 `_`의 의미
- `컨트롤이름_이벤트이름` 형태로 이벤트 프로시저(VBA)를 자동 생성한다.
- `_`는 단순 문자열 구분자일 뿐이며 **JS의 . 같은 객체 접근자가 아니다.**

실제 객체 접근 연산자는 `.` 이다:

```vba
Me.cmd실행.Caption = "실행"
Me.txt이름.Value = "홍길동"
```

---

# 📌 8. OpenReport (보고서 열기)

## 8-1. OpenReport의 의미
OpenReport는 단순히 보고서를 “보여주는” 명령이 아니다.  
다음 작업 전체를 수행하는 **보고서 렌더링 엔진을 실행**하는 명령이다:

- RecordSource 실행
- 필터/조건 적용
- 그룹 계산
- 페이지 분리
- 이벤트 발생
- 화면/프린터 출력을 위해 문서 생성

즉:
> “Access 보고서 엔진을 실행하여 문서를 생성하라”는 명령.

## 8-2. 내부 실행 순서
1. **Report_Open**
2. RecordSource 실행, Where 조건 적용
3. **Report_Load**
4. 그룹/페이지 구조 계산
5. **Report_Current** (레코드 이동 시마다 발생)
6. 렌더링 및 출력

## 8-3. Where 인수의 의미
```vba
DoCmd.OpenReport "rptSales", acViewPreview, , "Region='서울'"
```

보고서 쿼리에 사실상 다음을 추가한 것과 동일:

```
WHERE Region='서울'
```

설계 철학:
> 보고서 디자인과 실행 조건을 분리하여, 한 보고서를 다양한 필터 조건으로 재사용할 수 있게 한다.

---

# 📌 9. ADO 개체: ADO / Connection / Recordset

## 9-1. ADO(ActiveX Data Objects)의 설계 철학
ADO의 목적:
> “DB 종류가 달라도 모두 같은 방식으로 접근할 수 있게 만들자.”

대상:
- Access
- SQL Server
- Oracle
- MySQL
- ODBC 데이터 소스
- 텍스트 / Excel 파일

ADO는 데이터 접근을 위한 공통 객체 모델을 제공한다.

## 9-2. Connection 개체
Connection은 **DB와 연결하는 관문**이다.

역할:

1. ConnectionString 통해 DB 접속 정보 저장
2. SQL 명령을 DB로 전달
3. DB 결과를 받아오는 통로 역할

예:

```vba
cn.ConnectionString = "Provider=Microsoft.ACE.OLEDB.12.0;Data Source=C:\db.accdb"
cn.Open
```

설계 철학:
> 연결이라는 개념을 추상화하여 DB 종류를 교체해도 코드 구조가 유지되도록 한다.

## 9-3. Recordset 개체
Recordset은 SQL 결과를 담는 **“프로그래밍 가능한 테이블”**이다.

구성 요소:

- Fields 컬렉션
- Record 포인터(커서)
- MoveNext / MovePrevious
- AddNew / Edit / Update

예:

```vba
rs.Open "SELECT * FROM 고객", cn
Debug.Print rs!이름
```

설계 철학:
> SQL 결과를 일관된 방식으로 다룰 수 있는 데이터 모델을 제공한다.

## 9-4. Connection → Recordset 흐름의 의미
전체 흐름:

1. Connection이 DB 연결 오픈
2. SQL 전달
3. DB가 결과 반환
4. Recordset이 결과 담기

이 구조 덕분에 Access·SQL Server·Oracle 등 환경이 달라도 코드 재사용성이 높아진다.

---

