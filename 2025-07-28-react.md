# 📌 0. 리엑트 훅
### 📌 0-1. 리액트 훅에서 setter를 통한 상태관리
- seState는 리액트(React)에서 **컴포넌트의 상태(state)**를 관리할 수 있도록 도와주는 훅(Hook)이다.
- 상태는 컴포넌트 내부에서 바뀔 수 있는 값을 의미하고 훅이란 함수형 컴포넌트에서 리액트의 다양한 기능을 사용할 수 있게 해주는 특별한 함수를 의미한다.
- 함수형 컴포넌트는 기존의 클래스 컴포넌트와 다르게 class 문법을 사용하지 않고 함수형으로 정의한 컴포넌트(예 index.js)를 의미한다.
- Hook은 기본적으로 걸어두다라는 뜻으로 특정 지점에서 기능을 걸어서 확장하거나 동작을 연결할 수 있도록 해주는 장치를 의미한다.
- const [변수, setter함수] = useState(초기값); : 변수는 현재 해당 상태 값을 의미하고 setter함수는 이 변수에 접근할 수 있도록 도와주는 장치이다.
- 리액트에서 **상태(state)**란 컴포넌트가 기억해야 할 데이터(변수)이고 리액트는 이 데이터가 바뀌면 화면(UI)도 자동으로 바꿔야하는 의무가 있다.
- 상태값이 변한다 = 화면을 다시 그려야 한다
- setter 함수를 사용하는 과정에서 상태가 바뀌었다는 신호를 내부적으로 남기기 때문에 바로 값을 대입하는 것이 아니라 setter를 통하여 입력해야한다.
- setter없이 여기저기서 변수를 대입하여 바꾸면 일관성이 깨지는 문제도 있다.
- 또 setter를 사용하면 setter 함수가 호출될 때만 렌더링이 발생하므로, 불필요한 연산을 막고 효율적으로 UI를 갱신할 수 있게된다.
- 이로써 핵심은 setter를 사용하면 단순히 값을 바꾸는게 아니라 값을 바꾸는 요청을 같이 하게 된다는 점이다.
- 이 특성은 비동기 처리에서도 이점이 있다. 
- 리액트 내부에서는 여러 변경 요청이 한번에 들어오면 변경 요청을 묶어서 한번에 처리하려고 최적화하는데 (이를 배치(batching)라고 한다. -> setter들을 묶어서 한번에 처리) 이는 값을 직접 바꾸는 대신 setter라는 공통 함수를 통해야만 구현이 가능하다.
- input type range는 범위를 움직일 수 있는 바를 생성한다.
```js
import React, {memo, useState} from 'react';

import styled from 'styled-components';

const MyStateContainer = styled.div`
`;

const MyState = memo(() => {
  /**
   * state(상태)값 정의
   * - 이 페이지안에서 유효한 전역변수 같은 개념.
   * - 화면에 출력할 정도의 변수라고 이해하면 된다.
   * - const [변수이름, 변수에대한setter함수] = React.useState(변수의기본값);
   * - state값이 변경되면 자동으로 화면이 새로 그려진다. --> Virtual DOM의 다시 번경 가능하다.
   */
  const [myName, setMyName] = useState('');
  const [myPoint, setMyPoint] = useState(50);

  /** 이벤트 핸들러로 사용할 함수는 컴포넌트 함수 안에서 정의한다. */
  const onMyNameChange = e => {
    // 빈칸이나 공백일 발생한 입력값 출력
    // --> 출력할 대상을 의미하는 객체를 직접 게재하여 한다.
    // document.querySelector("#myOutput").innerHTML = e.currentTarget.value;

    // 리액트는 상태변수의 값을 변경하기 위해 setter함수를 사용해야 한다.
    // --> 상태변수에 대한 직접 대입은 에러
    // myName = e.currentTarget.value;
    // setter 함수를 통해 변경된 상태 변수는 모든 출력 위치에 자동 반영된다.
    setMyName(e.currentTarget.value);
  };

  return (
    <MyStateContainer>
      <h2>MyState</h2>

      <div>
        <label htmlFor="myNameInput">이름: </label>
        {/* 1) 상태값을 myName이 value속성에 연결된 입력 요소 */}
        {/* 2) 기본 연결을 'on + 이벤트이름' (대소문자 주의), 반드시 함수와 연결해야 한다. */}
        {/* 3) value속성은 반드시 상태변수에 연결 가능하고, value 속성을 사용할 경우
            onChange 이벤트를 통해 상태변수에 연결값을 갱신해 줘야 한다. */}
        {/* 4) 가끔 HTML에서의 value 속성은 defaultValue 속성을 사용한다. (그냥 경우) */}
        <input type="text" id="myNameInput" value={myName} onChange={onMyNameChange} />
      </div>

      <div>
        <label htmlFor="myPointInput">점수: </label>
        <input
          id='myPointInput'
          type='range'
          min='0'
          max='100'
          value={myPoint}
          step='1'
          // 이벤트 핸들러를 익명 함수로 정의한 경우
          onChange={e => setMyPoint(e.currentTarget.value)}
        />
      </div>

      <h2>{myName}님의 점수는 {myPoint}점 입니다.</h2>
    </MyStateContainer>
  );
});

export default MyState;
```

### 📌 0-2. useState, dayjs를 이용한 날짜 처리
- 날짜 처리를 위해 dayjs 라이브러리를 사용하는데 이 라이브러리의 대표함수는 기본적으로 현재 날짜를 가지고 있다.
- 그리고 객체를 const day = dayjs(); 이렇게 한번 초기화하는 과정도 필요하다.
```js
/**
 * useState를 사용하여 날짜 범위 선택 기능 구현
 */
import React, {memo, useState} from 'react';

import styled from 'styled-components';

// for 날짜 처리 (yarn add dayjs)
import dayjs from 'dayjs';

const DateRange1Container = styled.div`
`;

const DateRange1 = memo(() => {

  // dayjs 객체 리턴 반드시.
  const day = dayjs();

  /**
   * 화면에 출력할 상태값을 JSON 객체 myDate로 정의하고
   * 그 안에 출력할 값을 정의할 수 있는 함수를 setMyDate로 선언.
   */
  const [myDate, setMyDate] = useState({
    startDate: day.format("YYYY-MM-DD"),
    endDate: day.format("YYYY-MM-DD")
  });

  return (
    <DateRange1Container>
      <h2>DateRange1</h2>

      <h3>{myDate.startDate} ~ {myDate.endDate}</h3>

      <div>
        <button type="button" onClick={e => {
          // setter함수를 통해 JSON 객체의 상태값을 갱신할 때는
          // 반드시 화면에 구조를 동일한 객체를 사용해야 한다.
          const newDate = {...myDate};

          // dayjs 객체를 사용하여 15일전을 계산하여 설정함
          newDate.startDate = day.add(-15, 'd').format("YYYY-MM-DD");

          setMyDate(newDate);
        }}>-15일</button>

        <button type="button" onClick={
          e => setMyDate({...myDate, startDate: day.add(-1, 'M').format("YYYY-MM-DD")})}>-1개월</button>
        <button type="button" onClick={
          e => setMyDate({...myDate, startDate: day.add(-3, 'M').format("YYYY-MM-DD")})}>-3개월</button>
        <button type="button" onClick={
          e => setMyDate({...myDate, startDate: day.add(-6, 'M').format("YYYY-MM-DD")})}>-6개월</button>
        <button type="button" onClick={
          e => setMyDate({...myDate, startDate: day.add(-1, 'y').format("YYYY-MM-DD")})}>-1년</button>
      </div>

    </DateRange1Container>
  );
});

export default DateRange1;
```

### 📌 0-3. useEffect
- useEffect 리액트에서 "화면에 영향을 주는 부가적인 동작(side effect)"을 다룰 때 사용하는 훅이다.
- 또한 훅 useEffect는 동시처리되는 setter들 사이에서 순서를 잡아주는 역할을 한다. 
- useEffect(() => {}, [myBrightness]); 이런 식으로 정리했을때 useEffect는 [myBrightness]이라는 변수를 계속 관찰하고 있다.
- 즉 useEffect(실행할함수, [의존성배열]);일때 배열에 있는 값이 바뀔 때마다 실행할 함수가 다시 실행되게 된다.
- 변수가 바뀌지 않아도 최초 1회는 무조건 실행된다. 
- 의존성 배열에 빈배열을 넣으면 컴포넌트가 처음 마운트되어 나타날때 한번만 실행된다. 
- 만약 의존성 배열에 배열을 아예 생략하면 컴포넌트가 리랜더링될떄마다 (항상) 실행된다.
```js
/**
 * useEffect
 *
 * useEffect는 기본적으로 렌더링 차례마다 실행되며,
 * - 두 번째 파라미터 배열에 무엇을 넣느냐에 따라 실행되는 조건이 달라진다.
 *
 * 렌더링 => 컴포넌트가 화면에 그려지는 것
 *
 * 클래스의 컴포넌트의 componentDidMount와 componentDidUpdate를 합친 형태
 */
import React, { memo, useState, useEffect } from "react";

import styled from "styled-components";

// 예제 적용을 위한 이미지 참조
import sample from "../../assets/img/sample.jpg";

const MyEffectContainer = styled.div``;

const MyEffect = memo(() => {
  // 예제 적용을 위한 상태값 --> 0~200 사이의 값을 갖는 이미지 밝기
  const [myBrightness, setMyBrightness] = useState(100);

  // 브라우저의 넓이를 의미하는 상태값
  const [myWidth, setMyWidth] = useState(window.innerWidth);

  // 브라우저의 넓이를 상태값에 적용하기 위한 이벤트 핸들러
  const onMyResize = (e) => {
    console.log(`웹 사이즈 변경됨 >> ${window.innerWidth}`);
    setMyWidth(window.innerWidth);
  };

  // 이벤트 강제로 이 위치에서 수동할 경우 같은 처리를 하려 렌더링시마다 중복으로 수행하게 된다.(not good)
  // window.addEventListener("resize", onMyResize);

  /**
   * CASE 1 ==> 플랜 함수만 파라미터로 전달
   * - 이 컴포넌트가 화면에 막 등장할 때와 state, props값이 변경될 때마다 매번 실행됨
   * 거나치게 자주 실행되므로 사용하지 않음.
   */
  useEffect(() => {
    // chrome 브라우저 로그 출력 수준에서 "상세" 항목 체크 필요
    console.debug(`[Case1] %s ::: 화면에 컴포넌트가 처음 로드되거나 state, props 중 하나라도 변경될 경우 호출됨`, new Date());
  });

  /**
   * CASE 2 ==> 모니터링 할 상태변수를 두 번째 파라미터로 전달하는 배열의 형식
   * - 이 컴포넌트가 화면에 막 등장할 때와 등정 state, props값이 변경될 때만 실행됨
   * 특정 상태값이 변경될 솟이 호출 지점을 명확히 정할 수 있음.
   *
   * ex) 백엔드로부터 Ajax로 전송받은 결과값이 저장될 배우를 useState로 정의할 경우
   *     백엔드로부터 응답이 완료된 결과에 대한 후속 처리를 구현할 수 있다.
   */
  useEffect(() => {
    console.warn(`[Case2] %s ::: myBrightness값이 변경됨`, new Date());
  }, [myBrightness]);

  /**
   * CASE 3,4 ==> 두 번째 파라미터로 빈 배열을 설정함
   * - 이 컴포넌트가 화면에 막 등장할 때 단시에 1회 실행됨
   * 컴포넌트 1회만 처음을 실행시킬 수 있는 방법이므로 매우 자주 실행됨.
   *
   * 페이지가 열릴때만 처음으로 처리되어야 하는 기능 구현에 사용됨
   * - Ajax를 통한 HTTP 통신, window 객체에 대한 이벤트 정의
   *
   * 또한 React의 작동 원리상 컴포넌트는 상태값이 변경될 때 다시 매번 생성됨을 갖지하므로
   * 1회만 실행되어야 하는 로직 구현에 활용
   */
  useEffect(() => {
    console.info(`[Case3] %s ::: 화면에 컴포넌트가 처음 로드될 때 처리되어야 할 기능`, new Date());

    // window 객체종과 같이 DOM이외의 객체에 이벤트를 적용할 경우 useEffect를 활용해서
    // 컴포넌트가 로드될 때 단 1회만 처리되도록 해야 한다.
    window.addEventListener("resize", onMyResize);

    /** [CASE 4] 컴포넌트가 화면에서 사라질 때 호출하는 부분 */
    // 정리의 정보로 정의
    return () => {
      console.log(`[Case4] %s ::: 이 컴포넌트가 화면에서 사라지기 직전에 처리되어야 할 기능`, new Date());

      // 이 컴포넌트에 할당지근 될 등록된 이벤트를 제거됨
      window.removeEventListener("resize", onMyResize);
    };
  }, []);

  return (
    <MyEffectContainer>
      <h2>MyEffect</h2>

      <img alt="Hello React" src={sample} width={myWidth * 0.3} style={{
        filter: `brightness(${myBrightness + "%"})`,
      }}
      />

      <div>
        <input type="range" min={0} max={200} step={1} value={myBrightness} onChange={(e) => {
          setBrightness(e.currentTarget.value);
        }}
        />
      </div>
    </MyEffectContainer>
  );
});

export default MyEffect;
```

### 📌 0-4. useMemo
- useEffect 함수에서 첫번째 인자에 전달되었던 값을 memoizedValue에 저장하여 기억해 두었다가 동일하면 작동하지 않는다.
- 하여 값 자체가 똑같이 재설정된 경우가 아니라 바뀌었을 때만 특정 함수를 실행하도록 로직을 구현할 수 있게된다.
```js
/**
 * useMemo
 *
 * 함수형 컴포넌트 내에서의 연산 최적화.
 *
 * useMemo는 특정 상태변수가 변경되었을 때 그 변경된 값을 가지고 처리할 목적 작업을 구현한다.
 * 의존성배열을 갖지하기 위한 상태변수는 useMemo() 1번 두 번째 파라미터로 배열에 명시한다.
 * useMemo의 콜백함수에서 리턴하는 값은 useMemo 자체의 리턴값이 된다.
 */
import React, {memo, useState, useEffect, useMemo} from 'react';

import styled from 'styled-components';

const MyMemoContainer = styled.div`
`;

/**
 * 상태변수 myNumber가 변경될에 따라 영향을 받는 새로운 상태변수 만들기
 */
const MyMemo = memo(() => {
  // 사용자의 입력을 저장할 상태변수
  const [myNumber, setMyNumber] = useState(0);

  // 입력값에 따라 상태변수를 갱신할 이벤트 핸들러
  const onMyNumberChange = (e) => {
    const inputValue = e.currentTarget.value;
    const inputNumber = isNaN(inputValue) ? 0 : parseInt(inputValue);
    setMyNumber(inputNumber);
  }

  /**
   // [case 1]
   // 새로운 상태값
   const [myResult, setMyResult] = useState(0);

   // myNumber값이 변경되었을 때 실행되는 hook
   useEffect(() => {
     // 이 처리를 onMyNumberChange 안에서 함께 하지 못하는 이유가? setMyNumber가 비동기 처리이기 때문에
     // myNumber값의 갱신이 완료되기 경에 다음 코드가 실행 수도 있기 때문.
     setMyResult(myNumber * 234);
   }, [myNumber]);
   */

   // [case 2]
   // 위의 코드를 간결하게 처리한 형태
   // --> useMemo는 특정 상태값이 변경되었을 때 그 상태값에 영향을 받는 새로운 상태값을 생성한다.
   const myResult = useMemo(() => {
     return myNumber * 234;
   }, [myNumber]);
   /***/

  return (
    <MyMemoContainer>
      <h2>MyMemo</h2>

      <input type="number" value={myNumber} onChange={onMyNumberChange} /> x 234 = {myResult}
    </MyMemoContainer>
  );
});

export default MyMemo;
```