# 📌 1. DML·DDL·TCL 구분과 TRUNCATE·MERGE 판별

## 1-1. 개념
- **DML(Data Manipulation Language)**: 행 데이터 조작(INSERT, UPDATE, DELETE, MERGE, SELECT ... FOR UPDATE).
- **DDL(Data Definition Language)**: 객체 정의/구조 변경(CREATE, ALTER, DROP, TRUNCATE 등). 보통 자동 커밋.
- **TCL(Transaction Control Language)**: 트랜잭션 제어(COMMIT, ROLLBACK, SAVEPOINT).

## 1-2. 핵심 포인트
- **TRUNCATE = DDL**: 데이터 전체를 빠르게 제거하고 저장공간을 재설정. 로그 최소화/자동커밋 성격.
- **MERGE = DML**: 조건에 따라 INSERT/UPDATE/DELETE를 한 문장으로 수행.

## 1-3. 즉시 판별 규칙
- **내용을 바꾸면 DML, 구조/스토리지 레벨이면 DDL**. 예) TRUNCATE는 구조 초기화에 가깝다.


# 📌 2. 옵티마이저(Optimizer) — 정의·종류·판단 기준

## 2-1. 정의
- SQL을 가장 효율적으로 실행하기 위한 **실행계획**을 선택하는 엔진.

## 2-2. 종류
- **RBO(규칙 기반)**: 미리 정한 우선순위 규칙(인덱스 스캔 선호 등)으로 선택.
- **CBO(비용 기반)**: 통계정보(카디널리티, 분포 히스토그램, I/O/CPU 비용)를 활용해 **총 비용 최저** 계획 선택.

## 2-3. 판단 요소
- 선택도(Selectivity), 조인 순서/방식(Nested/Hash/Merge), 액세스 경로(인덱스 vs 풀스캔), 병렬성 등.

## 2-4. 출제 포인트
- “**인덱스가 있으면 반드시 사용**” → **CBO에서는 틀림**. 비용이 낮으면 테이블 풀스캔도 선택.


# 📌 3. NULL 비교 규칙과 공집합

## 3-1. 3값 논리
- SQL은 TRUE/FALSE/UNKNOWN. `NULL = NULL`은 **UNKNOWN** → WHERE에서 거짓처럼 취급되어 **행 미선택**.

## 3-2. 올바른 비교
- **IS NULL / IS NOT NULL** 사용.


# 📌 4. 엔터티(Entity) 공통 정의

## 4-1. 공통 3요소
1) **명사형 대상**(사람, 장소, 사건, 개념)  
2) **업무에서 관리해야 하는 정보**  
3) **저장 필요성**(식별자/인스턴스 보유)

## 4-2. 오답 포인트
- “DB 내 변별 가능한 객체”는 정의의 한 요소일 수 있으나, **공통 3요소** 표준 리스트와는 다름.


# 📌 5. 윈도우 함수 분류 — 행 순서 vs 순위

## 5-1. 행 순서 관련
- **LAG, LEAD, FIRST_VALUE, LAST_VALUE**: 파티션 내 **행 순서**를 직접 다룸.

## 5-2. 순위 관련
- **RANK, DENSE_RANK, ROW_NUMBER**: **순위/번호** 산출.
- 문항 의도: “행 순서 함수가 아닌 것” → **RANK**.


# 📌 6. 데이터 독립성(Data Independence)

## 6-1. 논리적 독립성(Logical)
- **개념 스키마(테이블/관계/제약) 변경**이 **외부 스키마/응용**에 영향 없음.

## 6-2. 물리적 독립성(Physical)
- **저장구조/인덱스/파티션 변경**이 **논리 스키마**에 영향 없음.

## 6-3. 판별 요령
- “개념 스키마가 바뀌어도 외부 스키마 영향 없음” → **논리적 독립성**.


# 📌 7. 데이터 모델링의 세 관점

## 7-1. 분류
- **데이터 관점(What)**: 어떤 데이터와 **데이터 간 관계**를 모델링.
- **프로세스 관점(How)**: 업무가 무엇을/어떻게 수행하는지.
- **상관관점(Interaction)**: 프로세스가 데이터에 주는 영향.

## 7-2. 문항 판별
- “업무가 어떤 데이터와 관련이 있는지 또는 데이터 간 관계” → **데이터 관점**.


# 📌 8. 집계와 NULL, NVL의 역할

## 8-1. 기본 규칙
- 그룹함수(SUM/AVG/COUNT(col))는 **NULL을 연산에서 제외**.

## 8-2. NVL이 바꾸는 것·안 바꾸는 것
- 합계: $ \text{SUM}(SAL) = \text{SUM}(\text{NVL}(SAL,0)) $ (동일할 수 있음)  
- 평균: $ \text{AVG}(SAL) \neq \text{AVG}(\text{NVL}(SAL,0)) $ 가능  
  - 예: $[10, NULL, 20] \Rightarrow \text{AVG} = 30/2 = 15$,  
    $ \text{AVG}(\text{NVL}(\cdot,0)) = 30/3 = 10 $

## 8-3. 핵심 결론
- “NVL이 합계오류 예방” → **부정확**. 집계는 원래 NULL을 제외한다.  
- 다만 **표현식 내부**에서 NULL 전파를 막기 위해 NVL/COALESCE가 필요할 수 있다.  
  - 예: `SUM(NVL(qty,0) * price)`


# 📌 9. OUTER JOIN 이후 WHERE 필터

## 9-1. 규칙
- `LEFT JOIN ... WHERE 오른쪽컬럼 IS NOT NULL` → 외부조인 결과에서 NULL을 제거하여 사실상 **INNER JOIN**처럼 수축.

## 9-2. 예시 감각
- T1(1,2,3) ⟕ T2(1,2,NULL) + `WHERE T2.col IS NOT NULL` → (1,2)만 남아 **2행**.


# 📌 10. 누적 백분율 윈도우 함수

## 10-1. CUME_DIST()
- 파티션/정렬 기준에서 “현재 행 이하”의 누적 분포(비율) 반환. 범위 $(0,1]$.
- **NTILE(n)**: 분위 나누기, **LAG/LEAD**: 행 탐색 → 기능이 다름.


# 📌 11. 조인 알고리즘 한눈에

## 11-1. Nested Loop Join
- 선행 테이블 각 행마다 후행 테이블을 탐색. 소량·고선택도에 유리.

## 11-2. Hash Join
- 빌드 테이블을 **해시 테이블**로 구성 후 매칭. 대용량/등가 조인에 강함.

## 11-3. Sort-Merge Join
- 양쪽 정렬 후 병합. 대규모 범위/정렬 친화.

## 11-4. 판별 포인트
- “FROM 절의 모든 테이블을 동시에 조인” 같은 서술은 부정확.  
- 문항의 오답은 Nested Loop 동작을 잘못·불완전 서술한 진술.


# 📌 12. 정규화(Normalization) — 효과와 한계

## 12-1. 목적
- **중복 최소화**, **이상(삽입/갱신/삭제) 제거**, **일관성/무결성 강화**.

## 12-2. 장점
- 중복 감소, 이상 현상 제거, 논리적 무결성에 유리.

## 12-3. 한계(트레이드오프)
- 테이블 분해로 **JOIN 증가 → 조회 성능 저하 가능**. 분석형 질의는 **반정규화** 병행.

## 12-4. 문항 판별
- “정규화의 이점: 처리 성능 향상” → **항상 X**. 보통은 성능 저하 가능. 정답: **처리 성능 향상**은 이점이 아님.


# 📌 13. “합계오류(sum error)”의 정확한 이해

## 13-1. 무엇을 말하나
- **집계 결과가 의도와 다르게 계산**되는 상황의 총칭.  
  1) **NULL 전파로 인한 누락**: 표현식 결과가 NULL이면 해당 행이 집계에서 제외되어 합계가 작아짐.  
  2) **조인으로 인한 중복집계**: 조인으로 행이 증식되어 합계가 커짐.

## 13-2. 표현식 수준의 NULL 전파 차단
- 예: `SUM(col1 + col2)`에서 `col2`가 NULL이면 그 행은 집계 제외 → 누락.  
- 해결: `SUM(NVL(col1,0) + NVL(col2,0))` 처럼 **표현식 내부**에서 처리.

## 13-3. 조인 증식 방지 패턴
- **사전 집계 후 조인**, **대표행 선택**, **세미조인(EXISTS)** 등.

## 13-4. 체크리스트
1) 집계 대상이 **표현식**인가? → 내부에서 NVL/COALESCE 처리  
2) **조인 증식** 위험? → 사전 집계/세미조인 고려  
3) **평균·비율** 지표인가? → NVL이 의미를 바꾸지 않는지 확인

# 📌 15. JOIN 시 열이 옆으로 붙는 이유

## 15-1. JOIN의 본질: Cartesian Product(카테시안 곱)
SQL의 JOIN 연산은 “행을 세로로 결합”하는 것이 아니라, “두 테이블의 행을 가로로 연결”하는 연산이다.  
즉, 두 테이블의 모든 가능한 행 조합을 만들어놓고 그중 ON 조건을 만족하는 행만 남긴다.  

이 과정을 수학적으로는 Cartesian Product (데카르트 곱)이라고 부른다.

| T1.COL | T2.COL |
|---------|---------|
| 1 | 1 |
| 2 | 2 |

이때 T1.COL과 T2.COL은 별개의 속성이다. 이름이 같더라도 소속 테이블이 다르기 때문에 물리적으로 다른 열(column)로 존재한다.

---

## 15-2. 같은 이름의 컬럼이 있어도 합쳐지지 않는 이유
SQL은 스키마 구조를 보존하는 언어이다. 각 테이블의 속성은 명확히 구분되어야 하며, JOIN을 해도 각 테이블의 컬럼 개수는 보존된다.

만약 같은 이름의 컬럼을 하나로 합친다면 데이터 출처를 잃게 되어 논리적 모호성이 생긴다. 그래서 T1.COL, T2.COL처럼 접두사(alias)로 출처를 명시한다.

---

## 15-3. “한 열로 합치는 효과”를 내고 싶다면?
```sql
SELECT T1.COL  -- 또는 T2.COL
FROM T1
JOIN T2 ON T1.COL = T2.COL;
```
T1.COL과 T2.COL 값은 같으므로 결과적으로 “한 열처럼 보이지만”, 실제로는 둘 중 하나만 선택한 것이다.

---

# 📌 16. Sort-Merge Join vs Nested Loop Join

## 16-1. Sort-Merge Join
**Sort(정렬)** 후 **Merge(병합)**.  
정렬된 데이터를 한 번씩 훑으며 같은 키를 병합한다.  
- 대용량 데이터에 유리
- 정렬 비용이 있음

비유: 이름순으로 정렬된 명부 두 개를 나란히 놓고 같은 이름을 찾는 방식.

## 16-2. Nested Loop Join
선행 테이블의 각 행마다 후행 테이블을 반복 검색하는 방식.  
- 소량 데이터에 유리
- 인덱스가 없으면 느림

비유: 명단에 있는 사람마다 도서관 책 전체를 훑으며 찾는 방식.

---

# 📌 17. 선택도(Selectivity)

$ 선택도 = 조건을 만족하는 행 수 / 전체 행 수 $

- 선택도가 작을수록 “필터링 능력”이 좋다.
- “선택도가 높다”는 말은 **적은 행만 선택된다**는 뜻이다.

| 선택도 | 의미 |
|:--:|:--|
| 0.01 | 매우 정밀한 조건 (좋음) |
| 1.0 | 거의 전체 선택 (비효율적) |

---

# 📌 18. 인덱스 스캔(Index Scan) vs 풀 스캔(Full Table Scan)

| 비교 항목 | 인덱스 스캔 | 풀 테이블 스캔 |
|------------|---------------|----------------|
| 접근 방식 | 인덱스 기반 | 전체 순차 접근 |
| 효율적 조건 | 선택도 높을 때 | 선택도 낮을 때 |
| I/O 방식 | 랜덤 접근 | 순차 접근 |
| 사용 예시 | WHERE id=1 | WHERE gender='M' |

---

# 📌 19. 조인 알고리즘의 철학적 차이
- **Sort-Merge Join**은 집합 기반 사고 (set-based).
- **Nested Loop Join**은 절차적 사고 (row-based).

---

# 📌 20. 정규화와 성능의 균형
정규화는 데이터 중복을 줄이고 이상현상을 제거하지만, 지나치면 JOIN이 많아져 성능이 저하된다.

| 장점 | 단점 |
|------|------|
| 중복 최소화, 무결성 보장 | JOIN 증가로 성능 저하 |

---

# 📌 21. Oracle 날짜 연산

```sql
SELECT TO_CHAR(
  TO_DATE('2025030220', 'YYYYMMDDHH24') + 2/24/60/60,
  'YYYY-MM-DD HH24:MI:SS'
) FROM DUAL;
```

- `TO_DATE('2025030220', 'YYYYMMDDHH24')` → 2025-03-02 20:00:00  
- `+ 2/24/60/60` → 2초 더함 (1초 = 1/24/60/60일)  
- 결과 → **2025-03-02 20:00:02**

오라클은 DATE를 **실수(Real Number)** 로 저장한다.  
정수부는 날짜, 소수부는 하루 중 시간 비율을 의미한다.
