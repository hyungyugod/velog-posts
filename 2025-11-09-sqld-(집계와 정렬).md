# 📌 1. 집계 함수와 GROUP BY, DISTINCT, 공집합

## 1-1. 집계 함수의 기본 개념

- 집계 함수(aggregate function)는 여러 행(row)을 하나의 값으로 요약하는 함수이다.
- 대표적인 집계 함수
  - `COUNT(*)` : 행의 개수(존재하는 모든 행)
  - `COUNT(컬럼)` : 해당 컬럼이 NULL이 아닌 행의 개수
  - `SUM(컬럼)` : 합계 (NULL 제외)
  - `AVG(컬럼)` : 평균 (NULL 제외)
  - `MAX(컬럼)` / `MIN(컬럼)` : 최댓값 / 최솟값 (NULL 제외)
- 설계 철학
  - SQL은 데이터 집합을 요약할 때 **“존재(행)”와 “값(컬럼)”**을 구분한다.
  - `COUNT(*)`는 행의 존재를 세고, `COUNT(컬럼)`은 값의 존재를 센다.

## 1-2. NULL 처리 철학 (집계 함수 관점)

- SQL에서 NULL은 **0이 아니라 “모르는 값(unknown)”** 이다.
- 따라서 집계 함수는 다음과 같이 동작한다.
  - `COUNT(컬럼)` : NULL을 제외하고 세기 때문에, “값이 확실히 존재하는 데이터만” 통계에 포함한다.
  - `SUM`, `AVG`, `MAX`, `MIN` : NULL을 계산에 포함하지 않는다.
- 이유
  - NULL을 0으로 취급하면 실제로는 값을 모르는 행까지 0으로 계산해버려 통계가 왜곡된다.
  - SQL은 **“모를 때는 계산하지 않는다”**는 철학을 따른다.

## 1-3. COUNT(*)와 COUNT(컬럼)의 차이

- `COUNT(*)`
  - 모든 행을 센다. 행에 NULL이 있어도 그 행은 “존재”하므로 포함된다.
- `COUNT(컬럼)`
  - 해당 컬럼이 NULL이 아닌 행만 센다.
- 예시

  | 사원 | 급여 |
  |------|------|
  | A    | 5000 |
  | B    | 4000 |
  | C    | NULL |

  - `COUNT(*)` → 3
  - `COUNT(급여)` → 2

- 철학적으로
  - `*`는 행 전체(튜플)의 “존재”이고,
  - 특정 컬럼은 “값의 존재 여부”를 의미한다.

## 1-4. GROUP BY가 없을 때의 집계 동작

- `GROUP BY`를 생략하면, **전체 테이블이 하나의 그룹**으로 간주된다.
- 즉
  - `SELECT AVG(급여) FROM 사원;`
  - 논리적으로는 $GROUP\ BY\ ()$ 와 같은 의미로, 전체가 한 묶음으로 요약된다.
- `GROUP BY`를 사용하면
  - 각 그룹별로 집계 함수가 따로 계산된다.
  - 예: `SELECT 부서, AVG(급여) FROM 사원 GROUP BY 부서;`

## 1-5. 공집합(Empty Set)일 때 집계 결과

- WHERE 조건 등으로 인해 결과 집합이 비어 있을 때 집계 함수의 값

  | 함수 | 공집합일 때 | 의미 |
  |------|-------------|------|
  | `COUNT(*)`, `COUNT(컬럼)` | 0 | 셀 행이 없으므로 개수 0 |
  | `SUM`, `AVG`, `MAX`, `MIN` | NULL | 계산할 값 자체가 없으므로 “모름” |

- 설계 철학
  - “존재 수(count)는 0으로 정의 가능하지만, 값의 합·평균·최댓값은 **아예 정의할 수 없다** → NULL로 표현한다.”

## 1-6. DISTINCT와 집계 함수의 처리 순서

- `DISTINCT`가 집계 함수 안에 사용되면 **먼저 중복을 제거한 후 집계**한다.
- 내부 처리 순서(개념)
  1. FROM으로 행을 가져온다.
  2. 대상 컬럼을 추출한다.
  3. `DISTINCT`로 중복을 제거한다.
  4. 그 결과를 집계 함수에 넣어 계산한다.
- 예시

  | 이름 | 급여 |
  |------|------|
  | 철수 | 3000 |
  | 영희 | 3000 |
  | 민수 | 4000 |

  - `SUM(급여)` → $3000 + 3000 + 4000 = 10000$
  - `SUM(DISTINCT 급여)` → $3000 + 4000 = 7000$
  - `COUNT(급여)` → 3
  - `COUNT(DISTINCT 급여)` → 2

- 철학
  - 집계 이전에 **“동일한 값들을 하나로 본다”**는 집합론적 사고가 반영되어 있다.

# 📌 2. COUNT(*), COUNT(1), COUNT(0)의 의미

## 2-1. COUNT(expr)의 일반 원리

- `COUNT(expr)`는 각 행마다 expr을 평가한 후, **그 결과가 NULL이 아닌 행의 개수**를 센다.
- 즉 개념적으로는
  - 각 행에 대해 expr을 평가
  - 결과가 NULL이 아니면 1, NULL이면 0
  - 전부 더한 값을 반환

## 2-2. COUNT(*)의 의미

- `COUNT(*)`는 예외적으로 “표현식이 아니라 행의 존재”를 센다.
- NULL 여부와 상관없이 **존재하는 모든 행**을 카운트한다.
- 철학
  - “데이터의 내용과 무관하게, **행이 존재한다는 사실**만 세고 싶다.”

## 2-3. COUNT(1), COUNT(0)가 전체 행을 세는 이유

- `1`, `0`은 상수이고, 모든 행에서 평가 결과가 항상 **NULL이 아니다.**
- 따라서 각 행에 대해
  - `1` 또는 `0`이라는 값이 항상 나온다 → NULL이 아님
  - 그러므로 모든 행이 카운트 대상이 된다.
- 결과적으로

  - `COUNT(1)` = 전체 행 수
  - `COUNT(0)` = 전체 행 수

- 대부분의 DBMS는 `COUNT(*)`, `COUNT(1)`, `COUNT(0)`에 대해 **동일한 실행 계획**을 사용한다.

## 2-4. COUNT(컬럼)과의 차이

- `COUNT(컬럼)`은 해당 컬럼 값이 NULL인 행을 제외한다.
- 따라서 컬럼에 NULL이 허용되는 경우
  - `COUNT(*)` ≥ `COUNT(컬럼)` 이 성립한다.
- 이 차이는
  - `COUNT(*)` → “존재(행)”
  - `COUNT(컬럼)` → “값(Value)의 존재”
  를 구분한다는 설계 철학에서 나온다.

# 📌 3. NOT NULL 제약과 COUNT 결과

## 3-1. 예제 문제 구조

- 주문 테이블 예시

  | 컬럼명   | 의미      | 제약 |
  |---------|-----------|------|
  | 주문ID  | 기본키     | `#` (PK) |
  | 고객ID  | 외래키     | `*` (NOT NULL) |
  | 상품ID  | 외래키     | `*` (NOT NULL) |
  | 주문일시 | 일반 컬럼 | (NULL 허용) |

- 쿼리

  ```sql
  SELECT 고객ID, COUNT(*), COUNT(상품ID)
  FROM 주문
  GROUP BY 고객ID;
  ```

## 3-2. 정답이 “두 COUNT 결과는 항상 같다”인 이유

- 상품ID에 `*`가 붙어 있어 `NOT NULL` 제약이 걸려 있다.
- 즉, 상품ID는 어떤 행에서도 NULL이 될 수 없다.
- 그러므로
  - `COUNT(*)` : 그룹 내 모든 행을 센다.
  - `COUNT(상품ID)` : 상품ID가 NULL이 아닌 행을 센다 → 실제로는 모든 행.
- 따라서 항상 결과가 같다.

## 3-3. “COUNT(*)는 NULL을 제외한다”는 선지가 틀린 이유

- `COUNT(*)`는 NULL을 제외하지 않는다.
- NULL이 존재하더라도 **그 행이 존재하면** 카운트에 포함된다.
- NULL을 제외하는 것은 `COUNT(컬럼)`이다.
- 흔한 혼동 포인트
  - “COUNT는 NULL을 세지 않는다” → `COUNT(컬럼)`에만 해당
  - “COUNT(*)는 NULL 포함” → 행의 존재를 기준으로 세는 함수

# 📌 4. GROUP BY, 집계, 공집합, DISTINCT의 설계 철학 요약

## 4-1. GROUP BY 생략 시

- GROUP BY가 없으면 전체 테이블을 **하나의 그룹**으로 간주한다.
- 집계 함수는 이 하나의 그룹 전체를 요약한 결과를 반환한다.

## 4-2. 공집합일 때

- 행이 하나도 없는 경우(조건으로 모두 걸러진 경우)

  - `COUNT(*)`, `COUNT(컬럼)` → 0
  - `SUM`, `AVG`, `MAX`, `MIN` → NULL

- 여기서 0과 NULL의 의미 차이
  - 0 : “셀 대상이 없다”를 숫자로 표현 가능
  - NULL : “값 자체를 정의할 수 없다”

## 4-3. DISTINCT 후 집계

- 집계 전에 **중복을 제거**함으로써
  - “서로 같은 값들을 하나로 취급하는 집합적 요약”을 수행한다.
- 이는 SQL이 **집합론(Set Theory)** 기반 언어라는 점을 잘 보여준다.

# 📌 5. ORDER BY에서 CASE 사용과 열 번호 사용

## 5-1. ORDER BY + CASE 문법

- 예시

  ```sql
  SELECT MOVIE_NAME, GENRE, RATING
  FROM MOVIE_INFO
  ORDER BY CASE GENRE
             WHEN 'SF'   THEN 1
             WHEN '액션' THEN 2
             ELSE 3
           END,
           RATING DESC;
  ```

- 동작
  1. GENRE 값에 따라 우선순위 숫자(1, 2, 3)를 계산한다.
  2. 그 숫자를 기준으로 먼저 정렬한다.
  3. 같은 우선순위에서는 RATING 내림차순으로 정렬한다.

## 5-2. 설계 철학 (ORDER BY + CASE)

- `ORDER BY`는 단순히 컬럼 이름만 받는 것이 아니라 **“표현식(Expression)”을 받는 연산**이다.
- CASE를 사용하면 “정렬 기준” 자체를 **데이터 기반 논리로 선언**할 수 있다.
- 철학적 의미
  - 절차적(if-else) 코드를 작성하는 대신,
  - 정렬 우선순위를 **선언적(declarative) 방식**으로 표현하도록 설계되었다.

## 5-3. ORDER BY에서 열 번호(ordinal position) 사용

- 문법 예시

  ```sql
  SELECT 이름, 나이, 점수
  FROM 학생
  ORDER BY 2 DESC;  -- 나이 기준 내림차순
  ```

- 의미
  - `2`는 SELECT 목록에서 두 번째 컬럼을 의미한다.
  - 즉 `ORDER BY 나이 DESC`와 같은 효과.

- 설계 의도
  - 초기 SQL 환경에서 긴 컬럼명을 반복해서 쓰기 불편했던 점을 보완하기 위한 **실용적인 단축 표기**.
  - 하지만 컬럼 순서에 의존하므로, **가독성과 유지보수성 측면에서는 주의가 필요**하다.

## 5-4. 주의할 점

- CASE 사용 시
  - `CASE ... WHEN ... THEN ... ELSE ... END` 구조를 반드시 완결되게 작성해야 한다.
  - 비교되는 값들의 타입이 서로 호환되어야 한다.
- 열 번호 사용 시
  - SELECT 목록의 순서를 변경하면 정렬 기준도 함께 바뀌어 버릴 수 있다.
  - 실무에서는 가급적 `ORDER BY 컬럼명`을 사용하는 것이 더 명확하다.

# 📌 6. NULL의 ORDER BY 우선순위 (Oracle vs 표준 SQL)

## 6-1. 기본 동작 차이

- 오름차순(ASC), 내림차순(DESC)에서 NULL의 위치는 DBMS마다 다르다.

  | DBMS   | ASC (오름차순) | DESC (내림차순) |
  |--------|----------------|-----------------|
  | Oracle | NULL 맨 마지막 | NULL 맨 처음    |
  | 다수의 표준 SQL 구현(PostgreSQL 등) | NULL 맨 처음 | NULL 맨 마지막 |

## 6-2. Oracle의 철학

- NULL을 **“비교 불가능한 값”**으로 본다.
- 값들의 정렬 순서에서 NULL은 “실제 값의 영역 밖에 있는 존재”로 취급된다.
- 따라서
  - 오름차순: 실제 값들을 모두 정렬한 뒤, 마지막에 NULL을 배치
  - 내림차순: 역순이므로 NULL이 맨 앞에 온다.
- 요약
  - “NULL은 순위에 참여할 수 없으므로, 값들의 끝에 둔다.”

## 6-3. 표준 SQL 계열의 철학

- NULL을 여전히 “모르는 값”으로 보지만,
- 정렬 체계 안에서 **일관된 위치**를 부여하기 위해 “가장 작은 값처럼” 취급한다.
- 그래서
  - 오름차순: NULL이 맨 앞
  - 내림차순: NULL이 맨 뒤
- 요약
  - “비어 있어도 하나의 데이터 행이므로, 정렬 체계 안에 포함시키자.”

## 6-4. NULLS FIRST / NULLS LAST 옵션

- 대부분의 DBMS는 사용자가 직접 NULL 위치를 지정할 수 있게 한다.

  ```sql
  SELECT name, salary
  FROM employees
  ORDER BY salary ASC NULLS FIRST;  -- 오름차순 + NULL을 맨 위로
  ```

  ```sql
  SELECT name, salary
  FROM employees
  ORDER BY salary DESC NULLS LAST;  -- 내림차순 + NULL을 맨 아래로
  ```

- 설계 의도
  - 기본 철학(Oracle 방식이든, 표준 방식이든)을 제공하되,
  - 실제 업무에서는 사용자가 **정렬 철학을 선택**할 수 있도록 선언적 옵션을 제공한다.

## 6-5. 철학적 요약

- Oracle
  - “정렬은 실제 값들에 대한 질서이며, NULL은 그 질서 바깥에 있다.”
- 표준 SQL 계열
  - “정렬은 모든 행이 포함되는 관계이며, NULL도 일관된 위치를 가져야 한다.”
- 공통점
  - 둘 다 NULL의 의미를 명확히 정의하려고 하되,
  - 기본 정책이 다를 뿐, `NULLS FIRST / LAST`를 통해 사용자가 원하는 정렬 방식을 선택할 수 있게 한다.
