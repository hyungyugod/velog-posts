# 📌 1. 엑세스 보고서/폼 머리글, 특정 레코드, 페이지 번호

## 1-1. 보고서 머리글, 그룹 머리글, 페이지 머리글 비교

- **보고서 머리글(Report Header)**
  - **출력 위치 기준**: 보고서 **전체 맨 앞에 딱 한 번** 출력.
  - 책으로 치면 **표지/제목 페이지** 역할.
  - 보고서 제목, 로고, 전체 설명 등 **보고서 전체를 대표하는 정보**를 넣는다.
  - 페이지가 아무리 많아도 **반복되지 않는다**.

- **그룹 머리글(Group Header)**
  - **출력 위치 기준**: **특정 필드를 기준으로 그룹이 바뀔 때마다** 출력.
  - 예: 부서별 보고서 → `부서`가 바뀔 때마다 “영업부”, “인사부” 등의 그룹 머리글이 찍힘.
  - 페이지와는 무관하게 **데이터의 논리적 묶음(그룹)** 이 바뀔 때마다 나타난다.
  - 옵션에 따라 **페이지가 바뀔 때마다 반복할 수도 있고, 안 할 수도 있음**.

- **페이지 머리글(Page Header)**
  - **출력 위치 기준**: **모든 페이지의 맨 위**에 반복 출력.
  - 책의 페이지 상단 영역처럼, 페이지 번호, 작성일, 열 제목 등을 넣는 곳.
  - 데이터 그룹과 상관없이 **“물리적인 페이지” 단위**로 반복.

> 정리:  
> - 보고서 머리글 → “보고서 전체” 기준  
> - 그룹 머리글 → “데이터 그룹” 기준  
> - 페이지 머리글 → “페이지” 기준

---

## 1-2. 폼 레코드 원본과 특정 레코드만 대상으로 하는 방법

- 폼에는 **레코드 원본(Record Source)** 속성이 있고, 여기에
  - 테이블
  - 쿼리
  - SQL 문
  를 지정할 수 있다.
- **테이블 전체를 레코드 원본으로 지정**하면 **그 테이블의 모든 레코드**가 폼의 대상이 된다.
- “특정 레코드만 폼에서 다루고 싶다”면:
  - **레코드 원본을 쿼리로 설정**하여, 이미 조건이 걸린 상태의 데이터를 불러오는 것이 원칙적 방법.
  - 예:  
    `SELECT * FROM 사원 WHERE 부서 = '영업';`
- 단순한 필터도 사용할 수 있지만, **설계 관점에서는 레코드 원본 자체를 제한하는 것이 더 명확하고 안정적**이다.

---

## 1-3. 보고서 페이지 번호의 동작과 제약

- 보고서에서 페이지 번호는 보통 텍스트 상자에 **수식 형태**로 들어간다.
  - 예: `="페이지 " & [Page] & " / " & [Pages]`
- 이 텍스트 상자는 보통:
  - **페이지 머리글(Page Header)** 또는
  - **페이지 바닥글(Page Footer)**  
  에 자동으로 삽입된다.

### (1) 첫 페이지에만 표시/숨기기

- `[Page]` 값은 현재 페이지 번호를 의미한다.
- 조건부 서식 또는 VBA 코드로 **1페이지에서만 보이게** 또는 **1페이지는 숨기고 2페이지부터 보이게** 할 수 있다.
  - 예: `IIf([Page] = 1, False, True)` 를 Visible 속성에 연결하여 1페이지에서는 숨김.

### (2) 페이지 번호 대화상자 동작

- 리본의 **페이지 번호** 기능을 사용할 때마다
  - **페이지 머리글/바닥글에 텍스트 상자를 새로 생성**하고
  - 그 안에 `[Page]` / `[Pages]` 관련 수식을 자동으로 삽입한다.
- 이미 있는 컨트롤을 수정하는 것이 아니라, **항상 새로운 컨트롤을 삽입**하는 방식.

### (3) 페이지 번호 표시 위치 제한

- 페이지 번호는 **“페이지 단위 정보”** 이므로,
  - **페이지 머리글 / 페이지 바닥글** 에만 두는 것이 원칙.
- 보고서 머리글이나 그룹 머리글은 **데이터 구조 기준 영역**이므로, 페이지 번호와 직접 연결되지 않는다.

---

# 📌 2. 엑세스 이벤트 상수와 보기 모드

## 2-1. acNormal, acNewRec의 의미

- 엑세스에서 `ac` 로 시작하는 상수들은 **Access Constant** 의 약자:
  - Access에서 **미리 정의한 상수값**을 의미한다.
  - 내부적으로는 숫자이지만, 의미를 읽기 편하게 이름으로 제공.

### (1) acNormal

- 문맥에 따라 다르게 쓰이지만 대표적으로:
  - `DoCmd.OpenForm "사원정보", acNormal`
    - 폼을 **일반 폼 보기(Normal Form View)** 로 연다.
  - 레코드 이동 관련에서는:
    - `DoCmd.GoToRecord , , acNext` 와 같이 사용되며,
    - **기존 레코드들 사이에서 “정상적인” 이동**을 뜻한다.
- 요약하면:
  - **기본/보통 상태**  
  - 특별한 모드(새 레코드 전용, 디자인 보기 등)가 아닌 상태.

### (2) acNewRec

- `DoCmd.GoToRecord , , acNewRec`
  - 현재 레코드 집합의 **“새 레코드 입력 위치(빈 행)”로 이동**.
- 용도:
  - 기존 레코드를 수정하는 것과 구분되는, **“새 레코드 추가 모드”** 진입.
- 설계 의도:
  - 읽기/수정과 **추가(append)** 를 명확히 구분하여 안전하게 다루기 위해.

---

## 2-2. ac 접두사의 설계 의도

- `ac`는 **Access에서 쓰는 공통 상수 집합**이라는 표시.
- 예:
  - `acNormal`, `acNewRec`, `acViewPreview`, `acReadOnly`, …
- 이들은 전부 **숫자 코드 대신 의미 있는 이름**을 쓰기 위한 것.
- 정수 0, 1, 2를 쓰는 대신, `acNormal`, `acDesign` 처럼 쓰면:
  - 코드 가독성이 높아지고
  - 의미를 직관적으로 이해할 수 있다.

---

## 2-3. DoCmd.OpenForm "사원정보", acNormal 의 의미

- `DoCmd.OpenForm "사원정보", acNormal`:
  - **"사원정보" 폼을 일반 폼 보기로 열어라**라는 뜻.
- 결과:
  - 사용자가 데이터 입력/수정/검색을 하는 **표준 UI 화면**으로 폼이 열린다.
- 디자인 보기, 데이터시트 보기 등이 아닌, **“정상 동작 상태”**의 폼.

---

# 📌 3. 엑셀: 메모와 피벗테이블, 일반 범위의 차이

## 3-1. 피벗테이블에서 메모가 셀을 따라가지 않는 이유

- 엑셀의 **메모(주석, Comment)** 는 셀의 “값”이 아니라:
  - 셀 위에 얹혀 있는 **도형(Shape) 개체**로 취급된다.
- 피벗테이블은 정렬/필터/필드 변경 시:
  - 기존 셀을 이동하는 것이 아니라
  - **표 자체를 다시 그린다(재작성)**.
- 메모는 이 재작성 과정에 포함되지 않고,
  - 기존 좌표에 고정된 도형이라서
  - 피벗 구조가 바뀌어도 **함께 이동하지 못한다**.

> 피벗: 동적 구조(“다시 그림”)  
> 메모: 고정 도형(“제자리에 남음”)  
> → 둘의 체계가 다르기 때문에 같이 안 움직임.

---

## 3-2. 일반 범위에서 메모가 셀을 따라 이동하는 이유

- 일반 범위(피벗이 아닌 표)에서 메모는:
  - **특정 셀에 앵커(anchor)** 로 연결된 상태.
- 정렬은 이 경우:
  - **기존 셀들을 위아래로 실제로 이동**시키는 작업.
  - 따라서 셀과 함께 메모도 같이 이동.
- 일반 범위에서 메모는 사실상:
  - 셀의 속성처럼 취급되기 때문에  
  → 정렬/필터에 동기적으로 반응.

> 일반 범위: “셀 이동” → 메모도 같이 이동  
> 피벗: “표 재작성” → 메모는 그대로

---

# 📌 4. 엑셀 차트와 원본 데이터 변화

## 4-1. 행/열 숨김이 차트에 반영되는 이유

- 셀을 **숨김(Hide)** 하면 값이 삭제된 것은 아니지만,
  - 차트 설정의 옵션에 따라 **숨겨진 데이터는 표시하지 않는 것**이 기본값인 경우가 많다.
- 차트에는:
  - “숨겨진 행 및 열의 데이터 표시 여부” 옵션이 있으며,
  - 기본적으로 **숨겨진 데이터는 표시하지 않도록 설정**되어 있을 수 있다.
- 따라서:
  - **행/열을 숨기면 → 차트에서 해당 값이 빠진 것처럼 보임**.

핵심:
- 시트 입장: “숨김 = 화면에서만 안 보임, 값은 존재”
- 차트 입장: “숨김 = 사용자 의도에 따라 **그래프에서 제외할 수 있는 신호**”

---

## 4-2. 차트와 연결된 데이터에 열을 추가해도 자동 반영되지 않는 이유

- 차트는 만들 때:
  - 원본 데이터 범위를 **정적인 참조**로 저장한다.
  - 예: `=Sheet1!$A$1:$C$10`
- 이후에:
  - C열과 D열 사이에 새로운 열을 추가해도
  - 차트가 기억하고 있는 범위는 여전히 **A1:C10**.
- 엑셀 차트는 “데이터가 있는 영역 전체를 자동 추적”하는 구조가 아니라,
  - **처음 지정한 범위를 그대로 사용하는 구조**.
- 자동 확장을 원한다면:
  - **표(Table)** 로 변환하거나
  - **이름 정의 + 동적 범위** 를 사용해야 한다.

---

# 📌 5. 부분합과 개요(Outline) 구조

## 5-1. 부분합 실행 시 요약행과 개요 자동 생성의 의도

- 부분합(Subtotal)을 실행하면:
  - 그룹별로 **요약행(부분합 행)** 을 삽입하고
  - 해당 구간을 감싸는 **개요(Outline)** 를 자동으로 만든다.
- 설계 의도:
  - 사람이 데이터를 읽을 때처럼:
    - 세부 데이터 → 그룹 요약 → 전체 요약  
    로 **계층 구조**를 만들고,
  - 버튼 클릭만으로
    - 세부 행을 접거나,
    - 요약만 볼 수 있도록 하기 위함.

> “데이터를 의미 단위로 접고 펼칠 수 있는 계층 구조”를 자동 생성.

---

## 5-2. 개요 수준(Level)과 그룹의 관계

- 개요 수준은 **최대 8개 Level** 까지 지원.
- 각 Level은:
  - 특정 단계의 그룹에 해당.
  - 예:
    - Level 1: 전체 합계
    - Level 2: 부서별 합계
    - Level 3: 팀별 세부
- 의미:
  - **작은 그룹 → 큰 그룹으로 올라갈수록 Level이 커지는 계단 구조**.
- 사용자는 각 Level 버튼으로:
  - 세부 데이터를 감추고
  - 상위 요약만 보는 등,
  - 데이터의 계층을 빠르게 전환할 수 있다.

---

# 📌 6. 사용자 지정 표시 형식과 날짜 기준 서식의 한계

## 6-1. 임의의 날짜를 기준으로 셀 서식을 지정할 수 없는 이유

- **셀 서식(Number Format)** 은:
  - 값이 이미 결정된 후, **그 값을 어떻게 “보여줄지”만 담당**하는 규칙.
- 반면
  - “특정 날짜보다 크면 이렇게 표시하라” 같은 것은
  - 값의 **비교/판단(조건)** 이 필요.
- 즉:
  - 셀 서식은 **조건 로직을 처리하는 장치가 아니다**.
  - 조건 로직은 **조건부 서식(Conditional Formatting)** 이 담당.
- 그래서:
  - **임의의 날짜를 기준으로 서식을 바꾸는 기능은 셀 서식만으로는 지원되지 않음**.

---

## 6-2. `0#.#%` 의 의미

- 백분율 형식과 자리수를 조합한 형태.

구조 해석:
- `0` : 앞자리에 숫자가 없더라도 **0을 강제로 표시**.
- `#` : 선택적 자리수(있으면 표시, 없으면 생략).
- `. #` : 소수점 이하 **한 자리 표시**.
- `%` : 값에 $100$ 을 곱해 **백분율로 표시**.

예시:
- 값 $0.056$ → `05.6%`
- 값 $0.8$ → `08.0%`
- 값 $0.03$ → `03.0%`

→ **두 자릿수 정수부 + 한 자리 소수 + 백분율** 형태를 강제하는 표현.

---

## 6-3. `#.#` 의 의미

- 소수점 한 자리만 표시하는 단순 형식.

구조:
- `#` : 정수부, 있는 만큼만 표시.
- `. #` : 소수부 한 자리, 있으면 표시, 없으면 생략.

예시:
- $3.14$ → $3.1$
- $5$ → $5$
- $0.28$ → $0.3$

---

## 6-4. `#,##0.0` 의 의미

- **천 단위 구분 쉼표** + **소수 한 자리 고정** 조합.

구조:
- `#,##0` : 천 단위 구분, 값이 $0$ 이어도 최소 한 자리(0)를 표시.
- `.0` : 소수점 아래 **항상 한 자리**를 표시.

예시:
- $1234.56$ → `1,234.6`
- $50$ → `50.0`
- $7.1$ → `7.1`

---

## 6-5. `#,###;@"점"` 의 의미

사용자 지정 서식은 다음과 같은 **4구역 구조**를 가진다:
- 양수; 음수; 0; 텍스트

`#,###;@"점"` 은:
- 1구역: `#,###` → 양수 표시 형식
- 2구역 없음 → 음수도 1구역 형식을 기본 사용
- 3구역 없음 → 0도 1구역 형식을 기본 사용
- 4구역: `@"점"` → 텍스트 값 뒤에 `"점"` 이라는 글자를 붙여서 표시

예시:
- 숫자 $1234$ → `1,234`
- 텍스트 `"가나다"` → `가나다점`

---

# 📌 7. 정렬 기준, 배열, 단축키, 휴지통

## 7-1. 셀 아이콘을 기준으로 정렬, “위에 표시”의 의미

- 조건부 서식 아이콘(신호등, 화살표 등)은 **각각 내부 우선순위(랭킹)** 를 가지고 있다.
- “정렬 기준 → 셀 아이콘” 선택 후 **“위에 표시”** 란:
  - **정렬 후 리스트의 “최상단에 올 아이콘”을 지정한다**는 뜻.
- 예:
  - 초록 ●, 노랑 ●, 빨강 ● 아이콘이 있을 때
  - “초록을 위에 표시” → 초록 아이콘이 붙은 행들을 가장 위로 모은다.
- 즉:
  - 정렬 기준을 “값”이 아닌 **“아이콘의 등급”** 으로 삼는 것.

---

## 7-2. 배열 수식(Array Formula) vs 배열 상수(Array Constant)

- **배열 수식**
  - 여러 값에 대해 **한 번에 연산**을 수행하는 수식.
  - 예: `{=A1:A3 * B1:B3}`
    - $A1×B1$, $A2×B2$, $A3×B3$ 를 한 번에 계산.
  - 핵심: **연산 방식**.

- **배열 상수**
  - 수식 안에 직접 적어 넣는 **고정된 값들의 묶음**.
  - 예: `{1,2,3}` 또는 `{1;2;3}`
  - 더 이상 계산이 아니라, **데이터 집합** 그 자체.

> 배열 수식 = “어떻게 계산할 것인가(연산)”  
> 배열 상수 = “무슨 데이터를 쓸 것인가(자료)”

---

## 7-3. Shift+Tab, Ctrl+Tab의 차이

- **Shift + Tab**
  - Tab 키로 포커스가 **오른쪽/아래로 이동**할 때의 **반대 방향**.
  - 셀 이동, 입력 상자 이동 등에서 **이전 위치로 되돌아가고 싶을 때** 사용.

- **Ctrl + Tab**
  - 여러 창/탭(워크북, 브라우저 탭 등) 사이를 **다음 탭으로 이동**.
  - `Ctrl + Shift + Tab` → 이전 탭으로 이동.
  - 문서/탭 간 **전환용 단축키**.

---

## 7-4. 휴지통 최대 크기 초과 시 삭제 기준

- 휴지통에는 **최대 용량**이 설정되어 있고,
- 새로운 파일을 삭제하여 휴지통 용량을 초과하면,
  - **가장 오래된 항목부터 순서대로 삭제**한다.
- 정리:
  - **Oldest-first 방식**으로 자동 정리.
  - 오래된 것부터 비워서 새로 들어오는 파일을 수용.

---

# 📌 8. 클라이언트·웹·프록시 서버와 프록시의 역할

## 8-1. Client–Server, Web Server, Proxy Server 비교

- **Client–Server 구조**
  - 클라이언트(요청)와 서버(응답)를 나누는 **전체 아키텍처 모델**.
  - 메일 서버, DB 서버, 파일 서버 등 모두 이 구조의 한 종류.

- **Web Server**
  - HTTP/HTTPS 요청을 받아:
    - HTML, CSS, JS, 이미지, API 응답 등을 제공.
  - Apache, Nginx, IIS 등이 대표적.
  - Client–Server 구조 안에서 **웹 콘텐츠 제공에 특화된 서버**.

- **Proxy Server**
  - 클라이언트와 서버 사이에 위치하는 **중간자 서버**.
  - 요청을 대신 전달, 필터링, 캐시 저장 등 수행.
  - 내부망을 보호하거나, 트래픽을 제어하는 데 사용.

---

## 8-2. 프록시가 캐시 서버·방화벽 역할까지 하는 이유

- 프록시의 위치:
  - 클라이언트 → **프록시** → 외부 서버
- 모든 요청·응답이 반드시 **프록시를 거치기 때문에**:
  - 요청/응답 내용을 저장해두면 **캐시 서버** 역할 가능.
    - 같은 요청이 오면 외부 서버까지 가지 않고, **프록시가 캐시에서 바로 응답**.
  - 요청을 검사/필터링하면 **방화벽 역할** 수행:
    - 특정 사이트 차단
    - 악성 패턴 탐지
    - 내부 IP 숨김 등

> 즉, **네트워크의 관문**을 차지하고 있어서 캐시·보안 기능을 동시에 수행하기에 최적의 위치.

---

# 📌 9. 통신/프로그래밍/저장장치 개념

## 9-1. 다양한 기기를 하나의 표준 접속으로 묶으려는 기술

- 통신기기, 가전, 사무용 기기 등 **종류와 제조사에 상관없이**:
  - **하나의 표준 접속으로 다양한 기능을 수행**하려는 개념은
  - 일반적으로 **홈 네트워크 / UPnP 계열 기술**로 설명된다.
- 핵심 목표:
  - 기기마다 제각각인 연결 방식을 통합하고,
  - “연결만 하면 자동 인식 후 서로 제어/연동”이 가능하도록 하는 것.

---

## 9-2. 프리프로세서(Preprocessor)

- **컴파일 전에 소스코드를 전처리하는 도구/단계**.
- C 언어 기준 주요 기능:
  - `#define` 매크로 치환
  - `#include` 파일 포함
  - `#if`, `#ifdef` 등 조건부 컴파일
  - 주석 제거 등
- 역할:
  - 프로그래머가 쓰기 편한 형태의 코드를
  - **컴파일러가 처리하기 좋은 형태로 미리 정리**해주는 ‘전처리’ 단계.

---

## 9-3. RAID의 목적

- RAID (Redundant Array of Independent Disks):
  - 여러 개의 디스크를 묶어서 **하나의 논리적 디스크처럼 운영하는 기술**.
- 목적:
  1. **데이터 안정성(내결함성)**  
     - 디스크 하나故障 시에도 데이터 유지 (RAID 1, 5, 6 등)
  2. **성능 향상**  
     - 여러 디스크에 병렬로 읽기/쓰기를 수행해 속도 향상 (RAID 0 등)
  3. **대용량 구성**  
     - 여러 디스크를 합쳐 하나의 큰 볼륨처럼 사용

> 정리: **“안전성 + 성능 + 용량”을 동시에 잡기 위한 디스크 배열 구조.**

---

# 📌 10. 부동소수점, 고정소수점, 시간 단위

## 10-1. 부동소수점에서 부호 비트가 양수 $0$, 음수 $1$ 인 이유

- 부호 비트는 **값의 크기가 아니라 부호만 표현**한다.
- 가능한 경우:
  - 양수
  - 음수
- 1비트로 표현해야 하므로:
  - 두 상태만 필요 → $0$ 과 $1$.

설계 이유:
1. **기본값(0)을 “양수”로 두는 것이 자연스럽기 때문**
   - 하드웨어에서 “아무 것도 안 한 상태(기본)”를 0으로 취급.
   - 별도 표시가 필요한 쪽(음수)을 1로 표시.

2. **정수의 2의 보수 체계와 일관성 유지**
   - 2의 보수에서도:
     - 양수 → 최상위 비트(MSB) = $0$
     - 음수 → MSB = $1$
   - 부동소수점도 이 관례를 그대로 따름.

---

## 10-2. 부동소수점 연산이 고정소수점보다 느린 이유

- **고정소수점 연산**:
  - 거의 **정수 연산과 동일한 방식**으로 처리 가능.
- **부동소수점 연산**은 다음 단계들이 필요:

1. **지수부 정렬(Exponent Alignment)**  
   - 두 실수의 지수가 다르면, 가수를 맞추기 위해 지수 정렬 필요.

2. **가수부 연산(Mantissa 연산)**  
   - 정렬된 가수끼리 덧셈, 곱셈 등 수행.

3. **정규화(Normalization)**  
   - 결과를 $1.xxxxx \times 2^n$ 형태로 다시 맞춤.

4. **반올림(Rounding)**  
   - IEEE 754 규칙에 따라 반올림 처리.

5. **예외 처리**  
   - Overflow, Underflow, NaN, $\infty$ 등 특수 케이스 처리.

- 이 모든 과정을 하드웨어(FPU)가 수행해야 하므로:
  - **고정소수점(정수형) 연산보다 구조적으로 훨씬 복잡하고 느리다.**

---

## 10-3. 시간 단위 as, fs, ps, ns, μs, ms

각각의 의미:

- **as (attosecond)**: $10^{-18}$ 초
- **fs (femtosecond)**: $10^{-15}$ 초
- **ps (picosecond)**: $10^{-12}$ 초
- **ns (nanosecond)**: $10^{-9}$ 초
- **μs (microsecond)**: $10^{-6}$ 초
- **ms (millisecond)**: $10^{-3}$ 초

### 빠른(짧은 시간) → 느린(긴 시간) 순서

1. as
2. fs
3. ps
4. ns
5. μs
6. ms

시간이 짧을수록 **“더 빠른 단위”**, 길수록 **“더 느린 단위”** 로 볼 수 있다.

---

# 📌 11. ClearType, FTP URL, PGP/PEM, 스풀링

## 11-1. ClearType

- 마이크로소프트의 **글꼴(텍스트) 안티앨리어싱/가독성 향상 기술**.
- LCD 패널의 한 픽셀은 실제로
  - R, G, B 서브픽셀 3개로 이루어져 있다.
- ClearType은:
  - **픽셀 전체가 아니라 서브픽셀 단위로 색을 조절**하여
  - 글자 윤곽을 더 부드럽고 선명하게 표현.

> 결과: 텍스트의 “계단 현상”을 줄이고, 작은 글씨도 읽기 좋게 만든다.

---

## 11-2. FTP URL

- FTP 서버에 접근할 때 사용하는 주소 형식.

형태 예:
`ftp://username:password@hostname/path/file.txt`

구성:
- `ftp://` → FTP 프로토콜 사용
- `username:password` → 사용자 계정 정보
- `hostname` → 서버 주소 (예: ftp.example.com)
- `/path/file.txt` → 서버 내 파일 경로

> **FTP 서버의 특정 파일/폴더 위치를 가리키는 주소 표기법**.

---

## 11-3. PGP와 PEM

- **PGP (Pretty Good Privacy)**
  - 주로 **전자메일 암호화 및 전자서명**에 사용되는 방식/프로그램.
  - 공개키 암호 기반.
  - 중앙 기관(CA) 대신 **사용자들 간 신뢰 관계(Web of Trust)** 를 기반으로 동작.

- **PEM (Privacy-Enhanced Mail)**
  - 원래는 메일 보안 표준.
  - 현재는 **인증서/키를 저장하는 파일 형식(.pem)** 으로 많이 사용.
  - 공개키, 개인키, 인증서 등을 **BASE64로 인코딩**하여 텍스트로 표현.

> 정리:  
> - PGP → 이메일을 “어떻게 암호화/서명할까”라는 **방식/프로그램**  
> - PEM → 키·인증서를 “어떤 형식으로 저장할까”라는 **파일 포맷**

---

## 11-4. 스풀링(spooling) 단위를 조절한다는 것

- 스풀링:
  - 작업(특히 인쇄 작업)을 바로 장치로 보내지 않고,
  - **임시 저장 공간(스풀러)에 쌓아두었다가 장치 속도에 맞춰 천천히 보내는 방식**.
- 스풀링 단위를 조절한다:
  - 한 번에 프린터로 보내는 **데이터 블록의 크기**를 조절하는 것.
  - 너무 크면:
    - 프린터/스풀러 메모리에 부담.
  - 너무 작으면:
    - 자주 전송해야 해서 오버헤드 증가.
- 적절한 단위로 조절하여:
  - 인쇄 속도, 메모리 사용, 반응성을 **균형 있게 최적화**하는 것이 목적.

---

# 📌 12. 옵션 그룹, 연결 테이블, 컨트롤 원본, IME

## 12-1. 옵션 그룹(option group)의 개념과 동작 원리

1. **정의**
   - 옵션 그룹은 여러 개의 선택지를 **하나의 논리적 값으로 묶는 컨트롤**이다.
   - 내부에 옵션 버튼, 토글 버튼, 체크 상자 등을 포함할 수 있고, 보통 **“여러 개 중 딱 하나 선택”** 구조로 사용한다.

2. **구조**
   - 그룹 자체에 **그룹 값(Value)** 이 있고,
   - 그룹 안의 각 버튼에는 **옵션 값(Option Value)** 을 부여한다.
   - 사용자가 특정 버튼을 클릭하면, 그 버튼의 옵션 값이 **그룹의 Value** 로 들어간다.
     - 예: 성별 옵션 그룹에서  
       - 남 = $1$  
       - 여 = $2$  
       → 사용자가 “여”를 고르면 그룹 값은 $2$가 된다.

3. **DB와의 연결**
   - 실제 테이블에는 버튼이 아니라 **그룹의 값(Value)** 이 저장된다.
   - 폼 코드에서는 `Me.옵션그룹이름.Value` 처럼 **숫자 하나만 읽어서 분기**하면 되기 때문에, 코드와 데이터 구조가 단순해진다.

4. **설계 철학**
   - 여러 버튼의 상태를 따로따로 보지 않고,  
     **“하나의 의미 있는 상태 값”으로 수렴시키는 UI**를 만들기 위한 구조.
   - 실수로 2개 중복 선택하는 일을 막고, 단일 선택을 강제한다.

---

## 12-2. 연결 테이블(linked table)과 원본 데이터 변경

1. **연결 테이블의 본질**
   - 연결 테이블은 **원본 테이블의 복사본이 아니라, 원본을 그대로 가리키는 “창문(view)”** 역할이다.
   - 실제 데이터 파일(예: 다른 Access 파일, 외부 DB)에 직접 연결되어 있다.

2. **왜 수정 시 원본이 바뀌는가**
   - 연결 테이블에서 데이터를 수정/추가/삭제하는 순간,
     → 그 동작은 곧바로 **원본 파일에 대한 연산**이 된다.
   - 즉, “복사해서 갖고 온 것”이 아니라 “원격 조종 장치”이기 때문에,  
     **연결에서의 변경 = 원본의 변경**이 된다.

3. **설계 철학**
   - “데이터는 단일 근원(single source of truth)”라는 원칙을 따른다.
   - 중복된 복사본을 만들어 데이터 불일치를 일으키지 않도록,  
     **직접 참조 구조**를 취한다.

---

## 12-3. 컨트롤 원본에서 `=1` 과 `1` 의 차이

1. **컨트롤 원본이 `1` 인 경우**
   - Access는 컨트롤 원본에 들어간 값을 **필드 이름**으로 먼저 해석한다.
   - `1` 이라고 쓰면, “이 폼/레코드에 `1` 이라는 이름의 필드가 있나?”를 찾는다.
   - 보통 그런 필드는 없으므로 **의도한 값 표시가 되지 않는다**.

2. **컨트롤 원본이 `=1` 인 경우**
   - `=` 로 시작하면 Access는 이것을 **“식(Expression)”** 으로 해석한다.
   - `=1` 은 “항상 $1$이라는 상수 값을 계산해서 보여줘”라는 뜻이다.
   - 이 컨트롤은 **계산 컨트롤(calculated control)** 이 된다.

3. **요약**
   - `1`  → “이름이 1인 필드를 보여줘라” (필드 참조)
   - `=1` → “식의 결과 $1$을 표시해라” (상수/계산값)

---

## 12-4. IME(Input Method Editor) 설정의 의미

1. **IME의 스펠링과 정의**
   - IME = **Input Method Editor**
   - 키보드로 입력한 키를 각 언어(한글, 일본어, 중국어 등)의 글자로 변환해 주는 입력기.

2. **Access에서의 IME 관련 속성 의미**
   - 폼/컨트롤의 IME 설정은 **해당 컨트롤에서 기본적으로 어떤 입력 모드를 사용할지**를 지정한다.

   대표 옵션:
   - IME Off : 영문 위주 입력(기본 알파벳/숫자)
   - IME On  : 한글/동아시아 문자 입력 모드 활성
   - (일본어 환경) Hiragana, Katakana, Full-width, Half-width 등 세부 모드

3. **한국어 환경에서의 사용 예**
   - 이름, 주소 입력 칸 → IME On (한글 입력이 기본)
   - 전화번호, 코드, ID 입력 칸 → IME Off (영문/숫자 입력이 기본)

4. **설계 철학**
   - 사용자가 매번 한/영 전환키를 누르지 않아도 되게 해서  
     **“입력 실수를 줄이고, 입력 흐름을 구조화”** 하려는 의도.

---

# 📌 13. 매크로 기록, 절대참조, 부분합과 머리글

## 13-1. 매크로 기록 시 셀 선택이 절대참조로 기록되는 이유

1. **매크로 기록기의 본질**
   - 매크로 기록기는 **“사용자의 행동을 좌표 단위로 그대로 베껴 쓰는 도구”**이다.
   - 사용자가 A1을 클릭하면, 기록 결과는 `Range("A1").Select` 가 된다.

2. **왜 기본이 절대참조인가**
   - 기록기는 “사용자가 무엇을 의도했는지”를 이해하지 못한다.
   - 단지 “당신이 A1을 눌렀으니, 그대로 코드로 적어둘게”라는 방식이다.
   - 상대참조는 “현재 위치 대비 얼마만큼 이동”이라는 의미인데,  
     이건 사용자가 **‘상대참조 사용’ 버튼을 명시적으로 켜야만** 가능하다.

3. **설계 철학**
   - 기본값은 항상 **“정확한 좌표(절대참조)”**로 기록해서 오해를 줄이고,
   - “패턴(상대참조)”를 쓰려 할 때만 사용자가 모드를 켜도록 설계.

---

## 13-2. 부분합(Subtotal) 기능과 여러 함수 중복 사용

1. **부분합의 구조**
   - 부분합은 **원본 데이터 사이사이에 요약 행을 삽입하는 기능**이다.
   - 원본 데이터를 바꾸지 않고, **위에 분석 레이어(요약 행)** 를 쌓는 방식.

2. **같은 열에 여러 부분합 함수를 쓸 수 있는 이유**
   - 예: 합계, 평균, 개수를 같은 열에서 모두 구하고 싶을 때
   - 부분합은 각 요약을 **“별도의 행”으로 삽입**하므로,
     - 합계 행
     - 평균 행
     - 개수 행  
     이 서로 충돌하지 않는다.
   - 즉, 한 열에 대해 여러 통계치를 구해도, **행이 다르기 때문에 공존 가능**하다.

3. **머리글(첫 행) 필요 이유**
   - 부분합은 “어떤 필드를 기준으로 그룹을 묶을 것인가”를 알아야 한다.
   - 엑셀은 필드를 숫자가 아니라 **머리글 이름(열 제목)** 으로 구분한다.
   - 첫 행에 머리글이 없으면:
     - 그룹화할 필드 목록을 만들 수 없고
     - 대화상자에서 선택할 항목이 없어서
     - **부분합 기능 자체를 적용할 수 없다.**

4. **요약**
   - 여러 함수 중복 가능 → 요약 행을 여러 층으로 삽입하기 때문.
   - 첫 행 머리글 필수 → 어떤 열을 기준으로 그룹·요약할지 지정하는 “필드의 이름표” 역할.

---

# 📌 14. 고급필터, 인쇄 자동 맞춤, 시트탭과 시나리오 보고서

## 14-1. 고급필터에서 특수 조건식의 의미

1. `="=??"` 의 의미
   - `?` : 임의의 한 글자
   - `"="` 를 붙이면 “이 패턴과 정확히 일치하는 문자열”이라는 뜻.
   - 따라서 `="=??"` 는  
     **“글자 수가 정확히 2글자인 텍스트만 통과시켜라”** 라는 조건이다.
     - `AA`, `가나` → 통과  
     - `A`, `AAA` → 제외

2. `=LEN($A2)=2` 의 의미
   - 수식 조건을 사용하는 방식.
   - `LEN($A2)` : A2 셀의 문자 개수  
   - `=2` : 길이가 $2$일 때만 TRUE
   - TRUE가 되는 행만 필터를 통과시키므로,  
     결과적으로 `="=??"` 와 **같은 의미**를 가진다.
   - 차이:
     - `="=??"` → 패턴 매칭 방식
     - `=LEN($A2)=2` → 논리식 계산 방식

3. `="=**"` 의 의미
   - `*` : 0글자 이상 임의의 문자열
   - `**` 는 실질적으로 `*` 와 동일한 패턴이다.
   - `="=**"` 는 **사실상 모든 텍스트를 허용**하는 조건이라 특별한 필터링 효과는 없다.

---

## 14-2. 페이지 설정에서 자동 맞춤(용지 너비=1, 높이=1)의 원리

1. **설정 의미**
   - 용지 너비: $1$ 페이지  
   - 용지 높이: $1$ 페이지
   - 엑셀에게 **“시트 전체를 딱 1페이지 안에 모두 넣어라”** 라고 지시하는 것과 같다.

2. **동작 방식**
   - 현재 시트의 인쇄 범위를 분석해,  
     이 범위를 $1\times 1$ 페이지 안에 넣기 위해 **축소 비율을 자동 계산**한다.
   - 가로로 5페이지, 세로로 10페이지 분량이어도  
     축소 비율을 심하게 줄여서라도 1페이지에 집어넣는다.

3. **결과**
   - “여러 페이지 분량의 내용이 한 페이지에 인쇄된다”는 말은  
     → **축소 비율을 강제해서 공간 안에 우겨 넣는다**는 뜻이다.
   - 글자가 매우 작아질 수 있다.

---

## 14-3. 시트탭에서 설정할 수 있는 것과 없는 것

1. **시트 탭에서 가능한 것**
   - 인쇄 제목(반복 행/열)
   - 눈금선 인쇄 여부
   - 행/열 머리글(행 번호, 열 문자) 인쇄 여부
   - 시트 방향/인쇄 범위 관련 설정

2. **시트 탭에서 불가능한 것**
   - **머리글/바닥글 내용 자체를 설정하는 것**
   - 머리글/바닥글은:
     - 페이지 레이아웃 탭
     - 또는 “페이지 설정”의 **머리글/바닥글 탭** 에서 설정한다.

3. **왜 “시트탭에서 머리글/바닥글 설정 가능”이 틀린 말인가**
   - 시트탭은 **시트의 인쇄 옵션(반복, 눈금선, 행/열 머리글)** 을 다루고,
   - 머리글/바닥글의 텍스트나 코드(작성일, 페이지 번호 등)는  
     **머리글/바닥글 영역에서만 설정**할 수 있기 때문이다.

---

## 14-4. 시나리오 요약 보고서가 자동으로 갱신되지 않는 이유

1. **시나리오 기능의 성격**
   - 시나리오 요약 보고서는 **“특정 시점의 값들을 복사해서 만든 정적(Static) 보고서”**이다.
   - 요약 보고서를 생성할 때,  
     각 시나리오의 결과를 **값으로 복사해 놓는다.**

2. **왜 자동 반영이 안 되는가**
   - 이미 만들어진 요약 보고서는  
     원본 시나리오와 링크되어 계산되는 구조가 아니다.
   - 따라서 시나리오를 변경해도  
     **기존 보고서에는 반영되지 않고**,  
     다시 “시나리오 요약”을 생성해야 값이 갱신된다.

3. **설계 철학**
   - 시나리오 보고서는 “분석 스냅샷”이다.
   - 실시간 대시보드가 아니라,  
     **그 시점의 결과를 문서처럼 남겨두는 용도**로 설계되어 있다.

---

# 📌 15. 날짜 단축키, 각주 서식, 머리글 날짜 코드, 문자열 표기 차이

## 15-1. 날짜/시간 단축키: Ctrl + ; 와 Ctrl + Shift + ;

1. **Ctrl + ;**
   - “오늘 날짜(Date)”를 셀에 입력한다.
   - 예: $2025\text{-}12\text{-}09$
   - 달력 정보(연-월-일)만 저장되고 시간은 $0$ 으로 취급.

2. **Ctrl + Shift + ;**
   - “현재 시각(Time)”만 입력한다.
   - 예: $18{:}32$
   - 시간 부분(하루 중 어느 시점인지)만 소수부로 기록된다.

3. **엑셀의 날짜/시간 내부 구조**
   - 날짜와 시간은 하나의 실수로 표현된다:
     - 정수부: 날짜(기준일로부터의 경과일)
     - 소수부: 시간(하루의 비율)
   - 그래서 날짜만, 시간만 따로 입력하는 단축키를 제공한다.

---

## 15-2. 각주(윗주) 텍스트 일부 서식 변경이 안 되는 이유

1. **셀 내부 텍스트와의 차이**
   - 셀 안의 일반 텍스트는 **문자 단위로 서식(색, 굵기 등) 변경 가능**하다.
   - 그러나 각주(윗주/각주 텍스트)는 셀 내용이 아니라  
     **“별도의 주석 객체(Comment와 비슷한 구조)”**에 저장된다.

2. **각주의 서식 지원 범위**
   - 전체 글꼴, 크기, 색 등은 설정할 수 있지만,
   - 텍스트의 **일부만 따로 굵게/색 변경**하는 기능은 지원하지 않는다.

3. **요약**
   - “윗주에 입력된 텍스트 중 일부분의 서식을 별도로 변경할 수 있다”  
     → 실제론 지원하지 않으므로 **틀린 설명**이다.

---

## 15-3. `작성일:&[날짜]` 와 `"작성일 :" & TODAY()` 의 차이

1. **`작성일:&[날짜]`**
   - 머리글/바닥글 전용 **코드**이다.
   - `&[날짜]` 는 인쇄 시점의 **시스템 날짜**를 자동 삽입하는 특수 태그.
   - 페이지 레이아웃 엔진이 처리하는 문법이지,  
     일반 셀 수식이 아니다.

2. **`"작성일 :" & TODAY()`**
   - 셀 수식에서 사용하는 문자열 결합 방식.
   - `TODAY()` 함수는 **현재 날짜를 반환**한다.
   - `"작성일 :" & TODAY()` 는 셀에서  
     “작성일 : 2025-12-09” 같은 문자열을 보여준다.

3. **엔진의 차이**
   - `&[날짜]` → **머리글/바닥글 엔진**이 인쇄 직전에 평가
   - `TODAY()` → **수식 엔진**이 워크시트 계산 시점에 평가

4. **정리**
   - 둘 다 “오늘 날짜를 표시한다”는 점은 같지만,
   - 사용하는 문법과 평가 타이밍, 적용 위치(머리글 vs 셀)가 다르다.

---

## 15-4. SQL의 문자열 `' '` vs 엑셀의 문자열 `" "` 차이

1. **SQL에서의 문자열**
   - 표준 SQL에서는:
     - 문자열 리터럴: `'텍스트'`
     - 식별자(컬럼/테이블 이름 등): `"ColumnName"` 또는 `\`ColumnName\`` (DB마다 다름)
   - 즉, 문자열과 식별자를 **기호로 엄격히 구분**한다.

2. **엑셀에서의 문자열**
   - 엑셀 수식에서는:
     - 문자열 리터럴: `"텍스트"`
   - `'텍스트'` 는 특별한 의미가 없고, 그냥 `"텍스트"` 와 동일한 일반 텍스트 취급이 아니라,  
     수식 문법상 **문자열 리터럴로 인식되지 않는다.**

3. **왜 이렇게 설계되었나**
   - 엑셀은 처음부터 “프로그래밍 언어”가 아니라  
     **범용 전자 계산기 + 워드/표 계열 UI의 혼합 형태**로 설계되었다.
   - `" "` 로 문자열을 쓰는 방식은 일반 사용자에게 **더 직관적이고 일관된 문서 스타일**이다.
   - SQL처럼 식별자 구분까지 필요하지 않기 때문에 `' '` 를 다른 의미로 쓸 이유가 없다.

4. **요약**
   - SQL: `' '` = 문자열, `" "` = 식별자(환경에 따라)
   - 엑셀: `" "` = 문자열, `' '` 는 수식 문자열 리터럴로 사용되지 않음  
   - 서로의 세계관이 다르기 때문에 헷갈리지만, **각자의 설계 철학이 다르다.**

---

# 📌 16. 피벗테이블의 행 레이블, 열 레이블, 값 영역

## 16-1. 행 레이블/열 레이블의 개념: 축인가, 속성인가?

1. **핵심 정의**
   - 행 레이블(Row Labels)과 열 레이블(Column Labels)은  
     **피벗테이블의 축(axis)을 구성하는 “분류 기준 속성”**이 들어가는 영역이다.
   - 그래프로 치면:
     - 행 레이블 = 세로축(Y축) 기준
     - 열 레이블 = 가로축(X축) 기준

2. **속성과 데이터의 역할 분리**
   - **속성(Attribute)**:
     - 지역, 제품, 부서, 날짜 등
     - 데이터를 “어떤 기준으로 나눌지(분류할지)” 결정
     - → 행/열 레이블에 들어간다.
   - **데이터(Data)**:
     - 매출액, 수량, 점수 등
     - 실제로 계산(합계, 평균, 개수 등)되는 값
     - → 값(Value) 영역에 들어간다.

3. **정리**
   - 행/열 레이블: **속성 중에서도 “분류 기준이 되는 속성”**
   - 값 영역: **그 분류 기준에 따라 계산되는 데이터**

---

## 16-2. 텍스트·논리값 필드가 행 레이블로 가는 이유

1. **텍스트/논리값 필드의 특성**
   - 텍스트: 문자열(지역명, 상품명 등) → 합계, 평균 같은 산술 연산 불가
   - 논리값: TRUE/FALSE, 예/아니오 → 산술 데이터라기보다 조건/분류에 더 적합

2. **피벗의 자동 배치 규칙**
   - 숫자 필드: 기본적으로 “계산할 수 있는 값”으로 인식 → 값 영역
   - 텍스트/논리값 필드: “계산보다는 분류에 적합한 값”으로 인식 → 행 레이블(또는 열 레이블)

3. **의미**
   - “텍스트·논리값 필드를 선택하면 행 레이블 영역으로 옮겨진다”는 말은  
     → 피벗이 **데이터 타입을 보고 자동으로 분류 기준 영역에 넣는다**는 뜻이다.

---

## 16-3. 값 영역에 필드가 2개 이상일 때 “값 필드”의 위치와 방향

1. **값 필드가 여러 개일 때의 문제**
   - 예: 매출합계, 매출평균, 개수 3개를 모두 보고 싶은 상황
   - 피벗은 “이 여러 계산값을 어떻게 구분해서 보여줄까?”를 고민해야 한다.

2. **값 필드(Value 필드)의 축화**
   - 피벗은 “값”이라는 가상의 항목을 하나 만든다.
     - 값1 = 매출합계
     - 값2 = 매출평균
     - 값3 = 개수
   - 이 값 필드를 **행 레이블 또는 열 레이블 중 한 쪽에 배치**하여,
     - 행 방향 혹은 열 방향으로 여러 값을 나열한다.

3. **표시 방향의 결정 원리**
   - 값 필드가 **열 레이블에 있을 때**:
     - 각 값(합계, 평균, 개수)이 **열 방향(가로)** 으로 나열된다.
   - 값 필드가 **행 레이블에 있을 때**:
     - 각 값이 **행 방향(세로)** 로 아래로 펼쳐진다.

4. **정리 문장**
   - “행 레이블 또는 열 레이블에 표시된 값 필드가 값 영역에 추가된 필드의 표시 방향을 결정한다”
     → 값 필드를 어느 축에 둘지에 따라,  
       여러 계산값이 **가로로 펼쳐질지, 세로로 나열될지가 정해진다.**

---

# 📌 17. 데이터 레이블, 텍스트 방향, DBNum 형식, 유효성 검사 드롭다운

## 17-1. 데이터 레이블 서식의 각 옵션 의미

차트의 데이터 레이블에서 선택할 수 있는 옵션들은,  
각 시리즈/데이터가 무엇을 의미하는지 설명하는 정보 레이어이다.

1. **값(Value)**
   - 해당 데이터 포인트의 실제 숫자 값.
   - 예: 매출액 500 → “500”

2. **계열 이름(Series Name)**
   - 범례에 표시되는 시리즈 이름.
   - 예: “매출액”, “원가”, “이익률”

3. **범주 이름(Category Name)**
   - X축 항목 이름.
   - 예: “1월”, “2월”, “A상품”, “B상품”

4. **비율(%)**
   - 원형/도넛 차트 등에서 각 조각이 전체 중 몇 %인지 표시.

5. **버블 크기**
   - 버블 차트에서, 버블의 “크기를 결정하는 값”을 표시.

---

## 17-2. 맞춤 탭의 텍스트 방향에서 ‘텍스트 반대’가 비활성인 이유

1. **텍스트 방향 옵션의 목적**
   - 이 기능은 **문자열의 읽기 방향(LTR vs RTL)** 을 제어하는 기능이다.
   - LTR: Left-To-Right (왼쪽 → 오른쪽, 한국어/영어)
   - RTL: Right-To-Left (오른쪽 → 왼쪽, 아랍어/히브리어 등)

2. **OS 언어 설정 의존**
   - 엑셀은 OS의 언어/로캘 설정을 보고, RTL 언어가 활성화되어 있어야  
     “텍스트 반대(오른쪽→왼쪽)” 옵션을 사용할 수 있게 설계되어 있다.
   - 한국어/영어 환경에서는 기본이 LTR이므로,  
     **RTL 모드가 필요 없다고 판단 → 옵션 비활성**.

3. **결과**
   - 단순히 “글자를 뒤집어 쓰는” 기능이 아니라,
   - **문서의 기본 방향성 자체를 바꾸는 기능**이라  
     환경이 해당 언어권이 아닐 때는 막아놓은 것.

---

## 17-3. `[DBNum2]G/표준` 과 `[DBNum1]G/표준` 의 의미

1. **DBNum의 역할**
   - DBNum은 숫자를 **동아시아 언어권의 숫자 표기 방식**으로 변환하는 포맷 코드이다.
   - $[DBNum1]$, $[DBNum2]$ 등은 **서로 다른 스타일의 한자/한자어 숫자 표기**를 의미한다.

2. **대략적인 차이**
   - $[DBNum1]$ : “일, 이, 삼”처럼 **한자어 숫자(한국식 읽기)** 스타일
   - $[DBNum2]$ : “一, 二, 三” 같은 **한자 숫자(중국/일본식 표기)** 스타일에 가깝다.
   - 엑셀 내부 구현은 언어/버전마다 약간 차이가 있지만,  
     **서로 다른 지역 문화권의 숫자 표현을 제공하는 국제화 옵션**이라고 보면 된다.

3. **`G/표준` 의 의미**
   - 뒤의 `G/표준` 은 **Standard(표준) 형식**을 따른다는 뜻.
   - 앞의 `[DBNumX]` 가 숫자를 어떻게 표현할지를 결정하고,  
     뒤의 `G/표준` 이 나머지 전체 형식(자릿수, 일반 숫자 스타일 등)을 유지한다.

4. **정리**
   - `[DBNum1]G/표준` : 숫자를 한자어 스타일($\text{일, 이, 삼}$)로 표시 + 표준 형식
   - `[DBNum2]G/표준` : 숫자를 한자 숫자($\text{一, 二, 三}$ 등)로 표시 + 표준 형식  
   - 둘 다 **숫자를 다른 언어 문화권 스타일로 출력하기 위한 포맷 지정자**이다.

---

## 17-4. 데이터 유효성 검사 목록의 드롭다운 너비를 지정할 수 없는 이유

1. **유효성 검사 드롭다운의 정체**
   - 데이터 유효성 검사에서 “목록”을 설정하면 나오는 드롭다운은  
     **“임시 팝업 UI”** 이다.
   - 이는 폼 컨트롤의 콤보박스처럼 **독립된 컨트롤 객체**가 아니라,  
     **셀 UI 위에 잠깐 떠 있는 간단한 목록**이다.

2. **셀 기반 UI 철학**
   - 엑셀의 기본 단위는 “셀”이다.
   - 입력영역의 크기(폭, 높이)는 **셀의 너비/높이**에 의해 결정된다.
   - 드롭다운까지 따로 크기를 조절하게 만들면,
     - “셀 중심”이라는 일관된 UI 구조가 깨진다.

3. **설계 상 분리**
   - 간단한 입력 제한 → **데이터 유효성 검사 + 드롭다운**
   - 복잡한 UI(너비, 글꼴, 스타일 등 조절 가능) → **폼 컨트롤, ActiveX 컨트롤**
   - 이렇게 역할을 분리해서,  
     **경량 기능(유효성 목록)** 이 과도하게 복잡해지는 걸 막는다.

4. **정리**
   - 데이터 유효성 검사의 드롭다운은 **셀에 종속된 가벼운 팝업**이라  
     너비 조절 기능을 제공하지 않도록 설계되어 있다.

---

# 📌 18. 아날로그 컴퓨터, 인터페이스(SATA/PATA/USB), 메일 프로토콜, 바이러스, 팩/언팩, 누산기, OS 역할

## 18-1. 아날로그 컴퓨터가 연속 데이터(온도, 전압 등)에 강한 이유

1. **핵심 구조**
   - 아날로그 컴퓨터는 **전압, 전류, 회전각 같은 연속 물리량**을 그대로 계산에 사용한다.
   - 덧셈: 전압을 합산
   - 적분: RC 회로(저항+콘덴서)
   - 미분: 반대 구조의 회로  
   → 물리 회로가 곧 수학 연산을 구현한다.

2. **연속 데이터 처리 특성**
   - 온도가 변하면 → 센서 전압이 실시간으로 변하고  
   - 그 전압이 바로 **계산 회로의 상태**가 된다.
   - 별도의 표본화(sampling), 디지털 변환 없이 **연속 상태를 그대로 반영**한다.

3. **디지털 컴퓨터와 대비**
   - 디지털 컴퓨터:
     1. 아날로그 입력 → A/D 변환기로 이산 값으로 변환
     2. 이진수로 저장
     3. CPU에서 이산 연산 수행
   - 아날로그 컴퓨터:
     - 물리 상태 자체가 연산진행 상황이므로,  
       **연속값을 자연스럽게, 실시간으로 처리**한다.

---

## 18-2. SATA, PATA, EIDE 비교

1. **PATA (Parallel ATA)**
   - **병렬 전송 방식**
   - 넓은 리본 케이블(40/80가닥)을 사용해 여러 비트를 동시에 전송
   - 선이 많아 **신호 간섭, 노이즈, 속도 향상 한계** 발생

2. **EIDE (Enhanced IDE)**
   - 기존 IDE(ATA)를 확장한 규격
   - 더 큰 용량, 더 빠른 속도, ATAPI(광학 드라이브) 지원 등
   - 전기적/물리적으로는 여전히 **PATA 계열**이라고 볼 수 있다.

3. **SATA (Serial ATA)**
   - **직렬 전송 방식**
   - 얇은 케이블, 핫플러그 지원, 긴 케이블 길이 가능
   - 고속 직렬 통신 기술 덕분에 PATA보다 훨씬 높은 속도와 안정성 제공

4. **정리**
   - PATA/EIDE: 병렬, 리본 케이블, 구세대 방식
   - SATA: 직렬, 얇은 케이블, 현대 표준 인터페이스

---

## 18-3. POP3 vs SMTP (메일 프로토콜)

1. **SMTP (Simple Mail Transfer Protocol)**
   - 메일을 **보내는(send)** 용도의 프로토콜.
   - 발신자 메일 서버 → 수신자 메일 서버로 메일을 전달하는 “전달망” 역할.

2. **POP3 (Post Office Protocol v3)**
   - 메일을 **가져오는(receive)** 용도의 프로토콜.
   - 수신자 메일 서버에 도착해 있는 메일을  
     → 사용자의 메일 클라이언트(Outlook 등)로 다운로드.

3. **한 줄 정리**
   - SMTP = **보내는 길**
   - POP3 = **가져오는 길**

---

## 18-4. USB가 직렬·병렬을 통합했다는 말의 의미

1. **과거 PC 포트 구조**
   - 병렬 포트: 프린터
   - 직렬 포트(COM): 모뎀, 시리얼 장비
   - PS/2: 마우스, 키보드
   - 장치마다 포트 종류가 제각각이었다.

2. **USB의 역할**
   - USB = **Universal Serial Bus**
   - 하나의 직렬 버스로 **프린터, 마우스, 키보드, 외장스토리지 등 대부분의 주변기기를 수용**.
   - 과거 병렬/직렬 포트로 나뉘어 있던 주변장치 연결 방식을  
     **USB라는 하나의 표준으로 통합**했다는 의미.

3. **주의할 점**
   - 실제 신호방식은 “직렬”이지만,  
     과거에 직렬 포트와 병렬 포트로 나뉘어 있던 역할들을 **논리적으로 통합했다**는 뜻이다.

---

## 18-5. 바이러스에 감염된 파일을 삭제해도 용량 부족이 해결되지 않는 이유

1. **바이러스 코드의 크기**
   - 대부분의 바이러스/악성코드 자체는 **수 KB ~ 수 MB 수준**에 불과하다.
   - 감염 방식도 보통 기존 프로그램 파일에 **일부 코드가 붙거나 일부가 변조**되는 형태.

2. **디스크 용량을 많이 차지하는 것들**
   - 대형 게임/프로그램
   - 동영상, 고해상도 사진
   - 각종 캐시/임시파일 등  
   → 실제로 수 GB~수십 GB를 차지하는 건 이런 것들이다.

3. **따라서**
   - 감염된 파일을 모두 삭제해도:
     - 보안 측면에서는 도움이 되지만,
     - **용량 부족의 근본 원인(대용량 파일들)이 그대로 남아 있다면 공간 문제는 거의 해결되지 않는다.**

4. **정리**
   - 바이러스 삭제 = 보안·안정성 개선용
   - 디스크 정리 = 대용량 데이터/캐시 삭제  
   → 목적이 다르다.

---

## 18-6. 10진 연산을 위한 Pack / Unpack (BCD 기반)

1. **BCD(Binary Coded Decimal)의 개념**
   - 10진수 한 자리(0~9)를 $4$비트로 표현하는 방식.
   - 예: $45$ → 상위 $4$비트에 $4$, 하위 $4$비트에 $5$.

2. **Pack 연산**
   - 두 개의 10진수 숫자(각각 $4$비트)를 하나의 바이트($8$비트)에 “압축”해서 넣는 것.
   - 예: $4$와 $5$를 $0100 0101$ 처럼 한 바이트에 묶기.

3. **Unpack 연산**
   - 위처럼 묶여 있는 데이터를 다시  
     **각 자릿수마다 한 바이트씩 분리**하는 과정.
   - 계산을 쉽게 하기 위해, 각 자리수마다 독립된 바이트로 꺼내 쓰는 것.

4. **왜 필요한가**
   - CPU는 2진수 연산에 최적화되어 있지만,
   - 금융/회계 등에서는 사람 기준의 **10진 정밀도**가 중요하다.
   - BCD + 팩/언팩 구조를 활용하면,  
     **10진수 자릿수 단위로 정확한 연산**을 수행할 수 있다.

---

## 18-7. 누산기(Accumulator)의 기능

1. **정의**
   - 누산기(ACC)는 **ALU(산술논리연산장치)의 연산 결과를 저장하고, 다음 연산의 입력으로 재사용하는 레지스터**이다.

2. **동작 예**
   - ACC = $5$  
   - ACC = ACC + $3$   → ACC = $8$  
   - ACC = ACC + $10$  → ACC = $18$
   - 이런 식으로 **중간 결과를 계속 들고 다니며 연산을 누적**한다.

3. **역할**
   - “연산의 중심 작업대” 역할.
   - 고전적인 CPU에서는 대부분의 연산이  
     “ACC와 메모리/레지스터 값” 사이에서 이루어지며,
     결과는 다시 ACC에 저장된다.

---

## 18-8. 운영체제(OS)가 “바이러스 침입을 실시간 감시·방지한다”는 말이 틀린 이유

1. **OS의 본질적인 역할**
   - 하드웨어 자원 관리(CPU, 메모리, 디스크, I/O)
   - 프로세스/스레드 관리
   - 파일 시스템 관리
   - 기본적인 보안/권한 모델 제공 (사용자, 권한, 접근제어 등)

2. **바이러스 탐지/치료의 주체**
   - 악성코드 탐지, 실시간 감시, 패턴 매칭, 행위 기반 탐지 등은  
     **전문 보안 소프트웨어(안티바이러스 프로그램)** 의 역할이다.
   - OS는 이들이 동작할 수 있는 **플랫폼과 권한 구조**를 제공할 뿐이다.

3. **현대 OS에 내장된 보안 기능**
   - Windows Defender처럼 “OS에 포함된 보안 프로그램”이 있을 수 있지만,
   - 이것은 **OS의 핵심 역할이라기보다는 ‘번들된 보안 응용 프로그램’**에 가깝다.

4. **정리**
   - “운영체제는 시스템을 실시간 감시하여 바이러스 침입을 방지한다”  
     → OS의 역할과 안티바이러스의 역할을 혼동한 설명이므로 **틀린 문장**이다.
   - 정확하게는:
     - OS는 **기본 보안 메커니즘과 환경**을 제공하고,
     - **실제 바이러스 탐지는 보안 소프트웨어**가 수행한다.

