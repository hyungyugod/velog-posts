# 📌 1. Access 폼 구조와 설계 철학

## 1-1. 기본 폼(Main Form)과 하위 폼(Subform)의 관계

- **역할 구분**
  - 기본 폼: 상위 폼(parent). 보통 1쪽(One)에 해당하는 레코드를 표시한다.
  - 하위 폼: 하위 폼(child). 보통 N쪽(Many)에 해당하는 여러 레코드를 표시한다.
- **데이터 관계**
  - 1:N 관계를 화면에 시각화한 구조이다.
  - 예시  
    - 기본 폼: 학생 1명 정보  
    - 하위 폼: 그 학생이 수강한 과목 목록(여러 개)
- **연결 필드**
  - 기본 폼과 하위 폼은 **Link Master Fields / Link Child Fields** 를 통해 연결된다.
  - 기본 폼의 현재 레코드 값이 하위 폼의 필터 조건으로 전달되어, 관련된 레코드만 하위 폼에 표시된다.
- **설계 의도**
  - 데이터베이스의 관계(relationship)를 사용자 인터페이스(UI)에 그대로 반영하기 위한 구조이다.
  - 사용자는 “기본 폼에서 한 레코드 선택 → 그 레코드와 관련된 여러 레코드를 하위 폼에서 확인”하는 흐름으로 데이터를 직관적으로 이해할 수 있다.

## 1-2. 기본 폼을 연속폼으로 쓰기 어려운 이유

- **연속폼의 특성**
  - 연속폼은 한 화면에 여러 레코드를 “목록 형태”로 동시에 표시한다.
  - 화면에 여러 레코드가 동시에 보이기 때문에, **현재 레코드가 무엇인지 직관이 흐려지는 구조**이다.
- **하위 폼과의 충돌 지점**
  - 하위 폼은 항상 **기본 폼의 “현재 레코드”** 를 기준으로 데이터를 필터링한다.
  - 그런데 기본 폼이 연속폼이면:
    - 화면에는 여러 레코드가 보이고
    - 어떤 레코드를 기준으로 하위 폼을 채워야 하는지 모호해진다.
- **이벤트·기준점 문제**
  - Access의 많은 이벤트(Current, Dirty, BeforeUpdate 등)는 “단일 현재 레코드”를 전제로 설계되어 있다.
  - 기본 폼을 연속폼으로 쓰면 상위 폼의 기준점(anchor)이 애매해지고, 하위 폼과의 동기화·이벤트 흐름이 복잡해진다.
- **설계 철학 요약**
  - 기본 폼: “기준이 되는 하나의 레코드”를 확실하게 가리키는 구조를 선호한다.
  - 연속폼: “여러 레코드를 한 번에 보여주는 목록 뷰”로 설계되었다.
  - 이 둘을 상위/하위 구조에서 섞으면 **1:N 관계를 표현하는 핵심 철학(하나의 기준 레코드 → 여러 관련 레코드)** 이 깨지므로 권장되지 않는다.

---

# 📌 2. Access 도메인 함수: DCount와 DLookup의 내부 동작

## 2-1. DCount 함수의 구조와 동작

- **형식**
  - `DCount(필드이름, 도메인, 조건)`
  - 예: `DCount("[학번]", "[학생]", "[점수]>=60")`
- **내부 해석**
  - Access는 위 함수를 내부적으로 다음과 같은 SQL로 해석한다:
    - `SELECT COUNT(학번) FROM 학생 WHERE 점수 >= 60;`
- **동작 단계**
  1. 도메인(여기서는 "[학생]" 테이블)을 로드한다.
  2. 조건 문자열 `"[점수]>=60"` 을 WHERE 절처럼 파싱한다.
  3. 조건을 만족하는 레코드를 모두 스캔한다.
  4. 해당 레코드의 $[학번]$ 개수를 센다.
  5. 그 개수를 정수 값으로 반환한다.
- **의미**
  - DCount는 “조건을 만족하는 레코드가 몇 개인지”를 계산하는 **미니 SELECT COUNT 쿼리**라고 볼 수 있다.

## 2-2. DLookup 함수의 구조와 동작

- **형식**
  - `DLookup(필드이름, 도메인, 조건)`
  - 예: `DLookup("[학번]", "[학생]", "[점수]>=60")`
- **내부 해석**
  - Access는 이 함수를 내부적으로 다음과 같이 해석한다:
    - `SELECT TOP 1 학번 FROM 학생 WHERE 점수 >= 60;`
- **동작 단계**
  1. "[학생]" 테이블을 로드한다.
  2. 조건 문자열을 WHERE 절로 해석한다.
  3. 조건을 만족하는 첫 번째 레코드(Top 1)를 찾는다.
  4. 그 레코드의 $[학번]$ 값을 반환한다.
- **의미**
  - DLookup은 “조건을 만족하는 레코드 중 첫 번째 레코드의 특정 필드 값을 가져오는 함수”이다.
- **설계 철학**
  - Access의 도메인 함수들은 **“SQL을 못 쓰는 사용자도 간단한 조회/집계를 하도록 돕는 도우미 함수”**이다.
  - DCount, DLookup 등은 모두 “조건이 있는 작은 SELECT 쿼리를 자동 생성해서 실행하는 래퍼”로 이해할 수 있다.

---

# 📌 3. 엑셀 찾기 옵션: 전체 셀 내용 일치

## 3-1. 부분 일치와 전체 셀 내용 일치의 차이

- **부분 일치(기본)**  
  - “찾을 내용”이 셀 내용의 일부로 포함되기만 해도 찾는다.
  - 예: `찾을 내용 = "apple"`
    - "apple" → 찾음
    - "pineapple" → 찾음
    - "apple juice" → 찾음
- **전체 셀 내용 일치**
  - 셀 전체 문자열이 “찾을 내용”과 **완전히 동일**할 때만 찾는다.
  - 예: `찾을 내용 = "apple"`
    - "apple" → 찾음
    - "pineapple" → 찾지 않음
    - "apple juice" → 찾지 않음

## 3-2. “찾을 내용에 입력한 문자만 있는 셀”이라는 표현의 의미

- “전체 셀 내용 일치” 옵션은 다음 조건을 의미한다:
  - 셀의 내용 = 검색어
  - 셀 안에 검색어 외 다른 글자나 공백이 하나라도 섞이면 매칭되지 않는다.
- 그래서 설명서에서
  - “찾을 내용에 입력한 문자만 있는 셀을 찾으려면 ‘전체 셀 내용 일치’를 사용한다”
  - 라고 표현하는 것이다.
- 개념적으로 정리하면:
  - 부분 일치: “포함 여부 검사”
  - 전체 일치: “완전 동일(equal) 비교”

---

# 📌 4. 엑셀: 창 나누기와 틀 고정의 차이

## 4-1. 창 나누기(Split)의 성격

- **역할**
  - 화면을 여러 영역으로 나누어 서로 다른 부분을 동시에 보기 위한 **임시 레이아웃 도구**이다.
- **특징**
  - 마우스로 분할선을 드래그해 위치를 자유롭게 바꿀 수 있다.
  - 완전히 화면(UI) 레벨의 기능이다.
- **설계 의도**
  - 사용자가 임시로 뷰(view)를 조정하여 작업 편의를 높이도록 하는 기능이기 때문에, 마우스로 직관적으로 조작할 수 있게 설계되었다.

## 4-2. 틀 고정(Freeze Panes)의 성격

- **역할**
  - 스크롤을 내려도 특정 행/열을 항상 화면에 고정해 두는 기능.
  - 예: 1행 제목을 항상 보이게 유지.
- **특징**
  - “고정 기준점(anchor)”을 논리적으로 지정하는 기능이다.
  - 사용자가 마우스로 선을 직접 끌어 이동할 수 없고,
    - 반드시 “틀 고정 해제 → 다시 설정” 과정을 통해 위치를 바꿔야 한다.
- **설계 의도**
  - 틀 고정은 UI 장식이 아니라 **스크롤 엔진의 기준점 설정**이다.
  - 기준점은 임의로 드래그해서 바꾸는 것보다, 명령으로 명확하게 지정하는 쪽이 데이터 일관성·예측 가능성 측면에서 유리하다.
- **요약 비교**

  - 창 나누기: 뷰 분할(화면 레이아웃) → 마우스로 이동 가능  
  - 틀 고정: 기준점 고정(스크롤 로직) → 명령으로만 변경, 드래그 불가

---

# 📌 5. Access 외부 데이터 가져오기: 워드 vs 텍스트 파일

## 5-1. 왜 워드프로세서 파일(.doc, .docx)은 직접 가져오지 못하는가?

- **Access가 원하는 데이터 형태**
  - Access는 관계형 데이터베이스이므로 **행(row)과 열(column) 구조를 가진 “정형 데이터(Structured Data)”**를 원한다.
  - 예: Excel, CSV, 다른 DB 테이블 등.
- **Word 파일의 본질**
  - 문단, 문장, 글자(run), 스타일, 표, 그림, 텍스트 상자 등 **문서 표현을 위한 비정형 구조**를 가진다.
  - “어디까지가 하나의 레코드인지, 어떤 부분이 필드인지”를 정할 수 있는 공통 규칙이 없다.
  - 예:
    - 문단을 레코드로 볼 것인가?
    - 표가 여러 개면 어떤 표를 가져올 것인가?
    - 글머리표, 색, 글꼴 크기는 데이터인가, 디자인인가?
- **결론**
  - Word 문서에는 Access가 일반적으로 사용할 수 있는 일관된 “테이블 구조”가 정의되어 있지 않기 때문에, 외부 데이터 원본으로 직접 지원되지 않는다.
- **철학적 관점**
  - Word: “사람이 읽는 문서”를 위한 도구
  - Access: “구조화된 데이터 저장·관리”를 위한 도구
  - 마이크로소프트는 Word를 Access의 공식 데이터 원본으로 취급하지 않도록 설계했다.

## 5-2. 텍스트 파일(.txt)은 왜 가져올 수 있는가?

- **텍스트 파일의 최소 구조**
  - 텍스트 파일은 비정형처럼 보이지만, 항상 **줄(line)** 이라는 최소한의 구조가 존재한다.
  - 줄 단위로 데이터를 끊고, 구분자(쉼표, 탭, 세미콜론 등)를 기준으로 필드를 나누면 **행/열 구조로 변환 가능**하다.
- **Access의 동작 방식**
  - 텍스트 가져오기 마법사에서:
    - “구분 기호로 분리” 혹은 “고정 너비”를 선택하게 한다.
    - 각 열의 데이터 타입(숫자, 텍스트, 날짜 등)을 추론하거나 사용자가 지정한다.
  - 즉, Access는 텍스트 파일을 “정형 데이터로 바꿀 수 있는 원시 데이터(raw data)”로 보는 철학을 가지고 있다.
- **워드와의 본질적 차이**
  - 텍스트:
    - 줄과 구분자를 이용해 **규칙을 정해 정형 데이터로 변환 가능**.
  - 워드:
    - 문서 구조가 복잡하고, “어디까지가 행/열인지”를 일반화된 규칙으로 정의하기 어려움.
- **요약**
  - 텍스트 파일: 비정형이지만, 정형화할 수 있는 규칙을 만들기 쉬워서 Access가 지원.
  - 워드 파일: 비정형이며, 정형화 규칙을 일반적으로 정의하기 어려워서 Access에서 직접 지원하지 않음.

---

# 📌 6. 우편물 레이블과 우편 엽서의 차이

## 6-1. 우편 레이블(우편물 레이블, 송장 스티커 등)

- **정체**
  - 봉투, 상자, 소포 등에 붙이는 **정보표시용 스티커**이다.
- **포함 정보**
  - 수신자 주소
  - 발신자 주소
  - 우편번호
  - 바코드/QR 코드(추적용)
  - 우편요금(스탬프 대체 역할 등)
- **특징**
  - **레이블 자체는 우편물이 아니다.**
  - 항상 “어떤 우편물(봉투/상자)에 부착되는 부속품”이다.
  - 우체국은 “레이블이 붙은 봉투/상자”를 우편물로 취급한다.

## 6-2. 우편 엽서(Postcard)

- **정체**
  - 엽서 한 장 자체가 **독립적인 우편물**이다.
- **특징**
  - 별도의 봉투가 필요 없다.
  - 정해진 규격(크기, 두께, 무게)을 만족하면 그대로 우편으로 발송 가능하다.
  - 한쪽 면에 주소·우편번호, 다른 면에 메시지를 적는다.
- **법적/제도적 차이**
  - 우편법·우편 규정에서 엽서는 **하나의 공식 우편물 종류**로 취급된다.
  - 요금 체계도 일반 편지와 구분되는 경우가 많다.

## 6-3. 요약 비교

- 우편 레이블: 우편물은 아니고, 우편물에 부착되는 **정보 태그**.
- 우편 엽서: 종이 한 장 전체가 **우편물 그 자체**.

---

# 📌 7. 문자열 함수와 보조 개념들

## 7-1. LEFT 함수: 예시 해석

- 예: `LEFT("영동1단지", 3)`
- 문자열을 글자 단위로 나누면:
  - 1글자: "영"
  - 2글자: "동"
  - 3글자: "1"
  - 4글자: "단"
  - 5글자: "지"
- `LEFT(문자열, 3)` 은 **왼쪽부터 3글자**를 잘라서 반환하므로:
  - 결과: `"영동1"`
- 한글도 한 글자를 1문자로 취급한다는 점이 중요하다.

## 7-2. 범례표지의 역할

- **범례표지란?**
  - 문서, 도면, 지도 등에 사용된 **기호·색·약어의 의미를 정리해 놓은 안내표**이다.
- **하는 일**
  - 이 색은 무엇을 의미하는지
  - 이 기호는 무엇을 나타내는지
  - 특정 패턴·선·심벌이 어떤 규칙을 따르는지
  - 를 한 곳에 모아 보여준다.
- **예시**
  - 지도: ● = 도시, ★ = 수도, 파란색 면 = 바다, 검은 실선 = 도로 등
  - 설계도면: 각종 벽체, 재료, 전기·배관 라인, 장비 기호 등을 설명
- **설계 철학**
  - 기호는 공간 효율은 좋지만 의미가 추상적이다.
  - 범례표지는 그 추상적인 기호 체계를 **사람이 이해할 수 있는 언어로 풀어주는 번역기** 역할을 한다.

---

# 📌 8. CHOOSE 함수와 VALUE 함수

## 8-1. CHOOSE 함수

- **형식**
  - $\\text{CHOOSE}(\\text{index}, \\text{value1}, \\text{value2}, \\dots)$
- **역할**
  - index 값(1, 2, 3, …)에 따라, 뒤에 나열된 값 중 **index번째 값을 반환**한다.
- **예시**
  - $\\text{CHOOSE}(2, "A", "B", "C") \\Rightarrow "B"$
- **동작 원리**
  1. index를 정수로 해석한다.
  2. 인수 목록을 1번째, 2번째, 3번째…로 번호를 매긴다.
  3. index번째 요소를 그대로 반환한다.
- **활용 예**
  - 월 번호를 월 이름으로 바꾸기:
    - $\\text{CHOOSE}(A1, "Jan", "Feb", \\dots, "Dec")$
  - VLOOKUP과 조합해 “열 순서 뒤집기” 또는 “왼쪽 방향 조회” 등을 구현할 때 사용.

## 8-2. VALUE 함수

- **형식**
  - $\\text{VALUE}(\\text{text})$
- **역할**
  - “숫자처럼 보이는 문자열”을 실제 **숫자형 값**으로 변환한다.
- **예시**
  - $\\text{VALUE}("123") \\Rightarrow 123$
  - $\\text{VALUE}("3.14") \\Rightarrow 3.14$
- **동작 원리**
  1. 문자열을 입력받는다.
  2. 숫자로 해석 가능한지 검사한다.
  3. 통화 기호, 쉼표, 공백 등의 서식을 제거한다.
  4. 엑셀 내부의 숫자 형식(실수, 날짜 시리얼 등)으로 변환한다.
- **필요성**
  - 외부 데이터(웹, CSV, 텍스트)에서 숫자가 문자열로 들어왔을 때
  - 합계, 평균이 먹히지 않는 “숫자처럼 보이는 문자”를 실제 숫자로 강제 변환할 때 필수.
- **CHOOSE vs VALUE 요약**
  - CHOOSE: “목록에서 위치(index)로 값을 고르는 함수”
  - VALUE: “문자열을 실제 숫자 타입으로 바꾸는 함수”

---

# 📌 9. 시나리오 피벗 테이블 보고서에서 결과 셀이 필수인 이유

## 9-1. 시나리오 관리자 기본 구조

- 시나리오(Scenario)의 구성:
  - Changing Cells: 바뀌는 입력 셀들(할인율, 판매량, 단가 등)
  - Result Cells: 입력값이 변했을 때 영향을 받는 결과 셀(총이익, 매출액 등)
- 시나리오 보고서의 목적:
  - “시나리오별로 결과가 어떻게 달라지는지” 비교하는 것.

## 9-2. 왜 결과 셀이 없으면 안 되는가?

- 시나리오 피벗 테이블 보고서는 구조상:
  - 행 영역: 시나리오 이름
  - 값 영역(Values): 결과 셀 값
- 피벗 테이블은 **반드시 요약할 값(Values 영역)** 이 필요하다.
- 결과 셀이 없으면:
  - “시나리오별로 무엇을 비교해야 하는가?”라는 기준이 사라진다.
  - 피벗 테이블에 넣을 값이 없어 구조를 만들 수 없다.
- 결론:
  - 시나리오 보고서는 **“조건 조합(시나리오)” → “결과 변화”** 를 보여주는 도구이므로,
  - 결과 셀이 없으면 보고서를 만들 논리적 대상 자체가 존재하지 않는다.

---

# 📌 10. 음수 나머지: $-3$ 을 $2$ 로 나눌 때 나머지가 $1$ 인 이유

## 10-1. 나머지의 수학적 정의

- 정수 $a$ 를 양의 정수 $b$ 로 나눌 때,
  - 몫 $q$, 나머지 $r$ 는 다음 조건을 만족해야 한다:
    - $a = bq + r$
    - $0 \\le r < b$
- 여기서 $b = 2$ 이므로, 나머지 $r$ 이 될 수 있는 값은:
  - $0 \\le r < 2 \\Rightarrow r \\in \\{0, 1\\}$

## 10-2. $-3 \\div 2$ 를 정의에 따라 계산

- 식: $-3 = 2q + r$, 단 $r \\in \\{0, 1\\}$
- 경우 1: $r = 0$
  - $-3 = 2q$
  - $q = -1.5$ → 정수가 아니므로 불가능.
- 경우 2: $r = 1$
  - $-3 = 2q + 1$
  - $-4 = 2q$
  - $q = -2$ → 정수, 조건 만족.
- 따라서:
  - 몫 $q = -2$
  - 나머지 $r = 1$
- 즉,
  - $-3 \\div 2$ 의 몫과 나머지는
    - 몫 $= -2$, 나머지 $= 1$
    - $-3 = 2 \\times (-2) + 1$

## 10-3. 직관적 해석

- 수직선에서 $\\dots, -4, -3, -2, -1, 0, 1, 2, \\dots$ 를 생각하면:
  - $-4$ 는 $2$ 의 배수이다.
  - $-3$ 은 $-4$ 보다 1만큼 오른쪽에 있다.
  - 즉, $-3 = (-4) + 1 = 2 \\times (-2) + 1$
- 나머지는 항상 $0 \\le r < b$ 를 만족해야 하므로, **음수 나머지가 아니라 양수 $1$ 이 정답**이 된다.

---