# 📌 0. 리엑트 훅 2
### 📌 0-1. useReducer
- dispatch:  컴포넌트에서 발생한 이벤트를 “액션” 객체나 값으로 묶어 리듀서에 전달하고, 상태 업데이트를 요청한다.
- useReducer는 배열을 리턴하고 result[0] → 현재 상태(state), result[1] → 상태를 바꾸는 함수(dispatch)이다.
- 1번 요소: 상태 갱신 함수라고 부르며 이전까지 setter로 알고 있었던 항목이다.
- 즉 구조분해 할당을 통해 이름을 마음대로 변환할 수 있다.
- useState에서 setMyNumber → “이렇게 상태를 바꿔주세요(새 값)”
- useReducer에서 dispatch → “이 액션을 처리해서 상태를 바꿔주세요”
- useState, useReducer는 배열 반환형태이고 useMemo는 배열이 아닌 단일값을 반환한다.
- useEffect는 값을 컴포넌트에 전달하는 게 아니라, 외부 시스템과 상호작용만 담당 즉 랜더링이 끝나고 값이 바뀌면 함수를 실행한다.
- useMemo는 “이 계산 결과를 화면에 쓰겠다”는 목적이므로, 값을 반환해야 함 즉 랜더 중에 함수가 실행되고 계산된 결과를 다시 사용함.
```js
import React, {memo, useReducer} from "react";
import styled from "styled-components";

const MyReducerContainer = styled.div``;

function setCouterValue(state, action) {
    switch (action) {
        case "HELLO":
            return state + 1;
        case "WORLD":
            return state - 1;
        default:
            return 0;
    }
}  

const MyReducer = memo(() => {
    const [counter, dispatch] = (setCouterValue, 0);

    return (
        <MyReducerContainer>
            <h1>현재 카운트 값: {counter}</h1>
            <button onClick={() => dispatch("HELLO")}>증가</button>
            <button onClick={() => dispatch("WORLD")}>감소</button>
            <button onClick={() => dispatch("")}>초기화</button>
        </MyReducerContainer>
    );
});

export default MyReducer;
```

### 📌 0-2. useRef
- React에서 useRef를 const myDname = useRef(); 이렇게 선언하면, 렌더링 간에도 값이 유지되는 “참조 객체(reference object)”를 만드는 것과 같다.
- 주로 DOM 요소를 직접 가리키거나, 렌더링 사이에 값 보관(storage) 용도로 사용한다.
- useRef() 호출 → { current: undefined } 객체가 생성
- myDname에 할당 → 앞으로 myDname.current로 값 읽기/쓰기 가능
- useState는 setState 호출 → 컴포넌트 재렌더링이지만
- useRef는 .current 변경 → 렌더링 없음즉 렌더 간 유지해야 하지만 UI에 바로 반영 안 할 값을 의미한다.
- `<input type="text" ref={myDname} id="dname" />` 이렇게 참조하면 해당 `<input>` 요소의 실제 DOM 노드가 myDname.current에 저장된다.
- 정확한 작용은 React가 처음 이 `<input>`을 DOM에 마운트할 때, myDname.current = (해당 input의 DOM 노드)를 자동으로 수행하는 것이다.
- 이후 myDname.current.value로 입력된 값을 읽거나, myDname.current.focus()처럼 DOM API를 직접 호출할 수 있다.
```js
/**
 * useRef
 *
 * Vanilla Script에서 `document.getElementById(...)` 나 `document.querySelector(...)`로
 * DOM 객체를 취득하는 과정을 React 스타일로 표현한 것으로 이해할 수 있다.
 */
import React, {memo, useRef} from 'react';

import styled from 'styled-components';

import MyBox from "../MyBox";

const MyRefContainer = styled.div`
`;

const MyRef = memo(() => {
  // HTML 태그를 React안에서 참조할 수 있는 참조변수를 생성
  const myDname = useRef();
  const myLoc = useRef();
  const myResult = useRef();

  // 자식 컴포넌트에 설정하기 위한 참조변수를 생성
  const myBoxRef = useRef();

  return (
    <MyRefContainer>
      <h2>MyRef</h2>

      {/* 미리 준비한 컴포넌트 참조변수와 HTML 태그를 연결 */}
      <div>
        <label htmlFor="dname">학과명 : </label>
        <input type="text" ref={myDname} id="dname" />
      </div>

      <div>
        <label htmlFor="dname">학과위치 : </label>
        <input type="text" ref={myLoc} id="loc" />
      </div>

      <p>
        입력값 확인: <span ref={myResult} id='result'></span>
      </p>

      <button onClick={e => {
        // 기존의 Javascript 방식
        // React의 SPA 작동 특성상 특정 시점에 전역에서 id값이 고유해야 한다.
        // 이 방식은 사용하기 매우 어렵다.
        // const dname = document.querySelector("#dname").value;
        // const loc = document.querySelector("#loc").value;
        // document.querySelector("#result").innerHTML = dname + ", " + loc;

        // 컴포넌트 참조변수를 사용해서 다른 HTML 태그에 접근 가능
        // --> "참조변수.current" 해당 HTML을 의미하는 Javascript DOM 객체
        // --> myDname.current와 document.querySelector("#dname")이 동일한 DOM객체이다.
        console.log(myDname);
        console.log(myLoc);
        console.log(myResult);

        const dname = myDname.current.value;
        const loc = myLoc.current.value;
        myResult.current.innerHTML = dname + ", " + loc;
      }}>클릭</button>

      <hr />

      <h3>컴포넌트에 ref 적용하기</h3>

      <MyBox a={100} b={200} ref={myBoxRef}/>

      <button type="button" onClick={() => {
        // <MyBox>를 통해 myBoxRef를 주입받은 DOM에 접근하여 제어함.
        myBoxRef.current.style.backgroundColor = "#f00";
      }}>Red</button>

      <button type="button" onClick={() => {
        // <MyBox>를 통해 myBoxRef를 주입받은 DOM에 접근하여 제어함.
        myBoxRef.current.style.backgroundColor = "#00f";
      }}>Blue</button>

    </MyRefContainer>
  );
});

export default MyRef;
```
- 이때 사용자 정의 컴포넌트 `<MyBox a={100} b={200} ref={myBoxRef} />` 정확히 말해 함수형 컴포넌트는 전달 대상이 원래 아니므로 함수형 컴포넌트를 통째로 ref로 전달 가능하게 하려면 eact.forwardRef로 감싸야한다.
```js
import React, {forwardRef} from 'react';

import styled from 'styled-components';

const MyBoxContainer = styled.div`
  border: 3px solid #0066ff;
  text-align: center;
  width: 300px;
`;

// 부모로부터 전달받은 ref 참조변수를 받기 위해 "React.forwardRef" hook에 대한 콜백으로
// 컴포넌트를 구현한다.
// 이렇게 구현된 컴포넌트는 props와 부모로부터 전달받은 ref 참조변수를 파라미터로 주입받는다.
const MyBox = forwardRef(({a, b}, ref) => {
  return (
    // 부모로부터 전달받은 참조변수 연결
    <MyBoxContainer>
      <h2 ref={ref}>MyBox</h2>
      <p>a={a}, b={b}</p>
    </MyBoxContainer>
  );
});

export default MyBox;
```

### 📌 0-3. useCallback
- 메모리제이션 레벨별로 역할이 있다.
- 컴포넌트: React.memo -> 아래서 MyCallback 컴포넌트에 전달되는 props가 바뀌지 않으면 그대로 둔다.
- 함수: useCallback -> 의존성 기준(배열에 전달하는 값)으로 값이 안바뀌면 재랜더링하지 않음
- 값(데이터): useMemo -> 의존성 기준(배열에 전달하는 값)으로 값이 안바뀌면 재랜더링하지 않음
- 이벤트 핸들러 같은건 한번 정의해두고 계속 쓰는건데 화면 다시 랜더링할때마다 다시 정의할 필요가 없기때문에 useCallback을 활용하여 재랜더링을 방지한다.
- 즉 MyCallback 컴포넌트에 다른 값이 전달되더라도 이벤트 핸들러는 처음 정의한 대로 랜더링되게 된다.
- 이득을 보는 부분은 [] 의존성 배열 덕분에, useCallback은 마운트 시 한 번 함수 객체를 만들고, 이후 렌더링에서는 같은 객체를 반환한다. 즉 메모리에서 객체를 다시 생성하지 않고 기존의 메모리에 있던 객체를 다시 가져오게 되는것이다.
```js
/**
 * useCallback
 *
 * 렌더링 성능 최적화에 사용됨.
 * 이벤트 핸들러 함수를 필요한 경우에만 생성할 수 있다.
 */
import React, {memo, useState, useCallback} from 'react';

import styled from 'styled-components';

const MyCallbackContainer = styled.div`
`;

const MyCallback = memo(() => {
  const [myText, setMyText] = useState('Hello React');

  console.log("MyCallback 함수가 실행됨~!!");

  // useCallback은 함수형 컴포넌트가 화면 갱신을 위해 반복실행되는 과정에서
  // 이벤트 핸들러 함수 정의를 최초 1회만 수행할 수 있게 한다.
  // --> 결론: 모든 이벤트 핸들러는 무조건 "useCallback(이벤트핸들러, [])" 안에서 정의
  const onInputChange = useCallback((e) => {
    setMyText(e.currentTarget.value);
  }, []);

  return (
    <MyCallbackContainer>
      <h2>MyCallback</h2>
      <h2>{myText}</h2>

      <input type="text" placeholder="input ..." onChange={onInputChange} />
    </MyCallbackContainer>
  );
});

export default MyCallback;
```

### 📌 0-4. 사용자 정의 훅과 clean up 함수
- 리액트는 MyWidth 컴포넌트의 인스턴스마다 독립적으로 effect 목록을 관리한다. 즉 컴포넌트가 마운트될때 작성된 effect 목록을 가지고 언마운트 될때 다시 clean up을 실행한다.
- 컴포넌트가 화면에 그려진다. (마운트) -> 컴포넌트 인스턴스 생성 → useEffect 등록 콜백 실행
- 컴포넌트 인스턴스 제거 직전(언마운트) → useEffect가 반환한 cleanup 실행
```js
{
  create: effectCallback,    // 콜백 본문
  destroy: null,              // cleanup 함수가 저장될 자리
  deps: [...]                 // 의존성 배열
}

// 초기 마운트 로직 이후
for (const effect of effectList) {
  effect.destroy = effect.create();  // 등록 로직 실행 -> 리턴함수가 destroy에 저장된다.
}

// 언마운트시
for (const effect of fiber.effectList) {
  if (effect.destroy) effect.destroy();  // 해제 로직 실행 -> return했었던 함수가 실행된다.
}
```
- 상태 값을 정의해두고 특정 조건이 발생했을때 dispatcher를 호출하는 처리를 사용할때 간략하게 할 수 있다.
```js
import React, {useState, useEffect} from 'react';

/**
 * 사용자 정의 함수.
 * useState와 useEffect를 하나의 함수로 묶는 용도로 정의함.
 */
const useMyWidth = () => {
  // 브라우저의 넓이를 의미하는 상태값
  const [myWidth, setMyWidth] = useState(window.innerWidth);

  // 사용자 정의 함수.
  // HTML DOM에 연결되는 이벤트가 아니므로 useCallback을 사용할 수 없음.
  const onMyResize = () => setMyWidth(window.innerWidth);

  // 페이지 로드시에 이벤트 정의, 페이지 종료시에 이벤트 해제
  useEffect(() => {
    window.addEventListener('resize', onMyResize);
    return () => window.removeEventListener('resize', onMyResize);
  }, []);

  // 마지막에 상태값을 리턴한다.
  return myWidth;
};

export { useMyWidth };
```
- 함수 참조(Reference): const fn = useMyWidth;
- 함수 호출(Call): const myWidth = useMyWidth(); -> 리턴값 대입
```js
/**
 * 직접 Hook 함수 정의하기
 * --> 리액트 스타일의 모듈화
 */
import React, {memo} from 'react';

import { useMyWidth } from '../../hooks/MyHooks';

const MyWidth = memo(() => {

    const myWidth = useMyWidth();

    return (
        <div>
            <h2>MyWidth</h2>
            <h2>windowWidth: {myWidth}</h2>
        </div>
    );
});

export default MyWidth;
```