# 탐욕 알고리즘 (greedy strategy)
- 간단한 것이 장점이다.
- 국소 최적해를 구하다보면 이는 전역최적해가 된다.

- 1) 현재 상태에서 가장 최적의 선택(탐욕적인 선택)을 수행한다.
- 2) 선택한 결과를 반영하여 남은 문제를 해결한다.
- 3) 이 과정을 반복하며 전체 문제를 해결한다.
- 4) 최종적으로 구한 해가 최적해인지 확인한다. (탐욕 알고리즘이 항상 최적해를 보장하는 것은 아님!)

## 1. 수업 시간표 짜기 문제
-  겹치고 겹치는 여러 수업들을 최대한 많이 듣고싶다면 어떻게 해야할까
-  가장 빨리 시작하는 수업을 우선 찾는다. -> 그 수업이 끝나고 하는 수업들 중에 가장 빨리 끝나는 수업을 찾는다.
-  이렇게 순간순간 최적의 선택을 하면 결국 최선의 결과를 얻을 수 있는 것이다. 

## 2. 집합 커버링 문제를 탐욕 알고리즘으로 해결하기
- 미국엔 라디오 방송국이 여러개 있는데 이들은 각자 관할하는 구역이 다르다. 겹치기도 하며 포함되는 주의 개수도 다를 수 있다. 방송국들을 최대한 적게 선택하여 모든 미국 사람들이 라디오 방송을 들을 수 있도록 해야한다.
- 근사 알고리즘 사용: 아직 방송되지 않은 지역 중 가장 많은 지역을 커버하는 방송국을 선정 -> 끝날떄까지 반복
```python
while states_needed:        # 방송해야할 주가 남은 동안 이 알고리즘을 반복한다.
    best_station = None 
    state_covered = set()   # 아직 방송하지 않은 주 중에 아래에서 할당될 해당 방송국이 커버하는 주의 개수
    for station, states in station.itemes():  # 딕셔너리에서 방송국의 이름과 해당 방송국이 커버하는 주의 이름들을 꺼냄.
        covered = states_needed & states      # 이미 커버한 곳과 지금 할당된 방송국이 커버하는 주의 교집합, for이 돌때 마다 새로 할당되는 변수는 그냥 for문 안에 넣어버리기
        if len(covered) > len(states_covered):
            best_station = station            # 가장 많이 커버한 방송국을 최고의 방송국으로 지정정
            states_covered = covered

    states_needed -= states_covered
    final_stations.add(best_station)
    
    print(final_stations)
```
