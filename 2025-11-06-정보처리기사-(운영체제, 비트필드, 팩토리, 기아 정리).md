# 📌 1. 구조체 비트필드와 크기 계산

## 1-1. 비트필드의 기본 개념

비트필드(bit-field)는 구조체에서 **특정 멤버가 차지하는 비트 수를 지정**하는 문법이다.

```c
struct Example {
    unsigned int a : 3;
    unsigned int b : 5;
    unsigned int c : 8;
};
```

- $a$: 3비트 사용  
- $b$: 5비트 사용  
- $c$: 8비트 사용  
즉, 논리적으로는 $3 + 5 + 8 = 16$비트를 사용하는 것처럼 보이지만, 실제 메모리 크기를 결정하는 건 **비트 수가 아니라 기반 타입의 크기와 정렬 규칙**이다.

---

## 1-2. 저장 단위(Storage Unit)와 정렬(Alignment)

비트필드는 **기반 자료형의 크기 단위**로 묶여 저장된다.

```c
struct Bitfield1 {
    unsigned int a : 3;
    unsigned int b : 5;
    unsigned int c : 8;
};
```

- `unsigned int`는 보통 4바이트(32비트)
- $a$, $b$, $c$ 모두 같은 타입이므로 한 32비트 블록 안에 들어간다.
- 실제로는 총 16비트를 쓰고, 나머지 16비트는 빈 공간이다.
- `sizeof(struct Bitfield1)` 결과는 4바이트로 나온다.

즉,
- **논리적 크기:** 비트 단위
- **물리적 크기:** 정렬 규칙 및 패딩에 따라 기반 타입 크기 단위로 결정된다.

---

## 1-3. 서로 다른 기반 타입을 섞은 경우

```c
struct Bitfield2 {
    unsigned int a : 3;
    unsigned int b : 5;
    unsigned char c : 4;
    unsigned char d : 4;
};
```

- `a`, `b`: 같은 `unsigned int` → 4바이트 블록 공유  
- `c`, `d`: 새로운 `unsigned char` → 새로운 블록 시작 (1바이트 단위)

정렬 결과:
- 구조체는 **가장 큰 정렬 단위(4바이트)**를 기준으로 전체 크기를 맞춘다.
- 따라서 `sizeof(struct Bitfield2)`는 8바이트가 될 수 있다.

요약:
- 같은 타입의 비트필드는 같은 저장 단위 공유  
- 다른 타입이 나오면 새 저장 단위 시작  
- 정렬에 따라 구조체 크기가 확장될 수 있다.

---

## 1-4. 비트필드 vs 비트마스크

### (1) 비트필드 방식

```c
struct Flag {
    unsigned int a : 3;
    unsigned int b : 5;
};

struct Flag f;
f.a = 5;
f.b = 17;
```

- **장점:** 문법적으로 간단하고 가독성 좋음  
- **단점:** 비트 순서, 패딩 등이 **컴파일러마다 다름** → 구현 의존적

### (2) 비트마스크 방식

```c
struct Packet { unsigned int raw; };
#define A_MASK 0x00000007
#define B_MASK 0x000000F8

unsigned int get_a(struct Packet p) { return (p.raw & A_MASK); }
unsigned int get_b(struct Packet p) { return (p.raw & B_MASK) >> 3; }
```

- **장점:** 이식성 높고 비트 제어가 정확하다.
- **단점:** 코드가 다소 복잡하다.

---

# 📌 2. Simple Factory vs Factory Method 패턴

## 2-1. 코드 구조

```java
class NotificationFactory {
    Notification createNotification(String type) {
        if (type.equalsIgnoreCase("email")) return new EmailNotification();
        else if (type.equalsIgnoreCase("sms")) return new SMSNotification();
        else if (type.equalsIgnoreCase("push")) return new PushNotification();
        else return null;
    }
}
```

```java
interface Notification { void send(String to, String message); }
class EmailNotification implements Notification { ... }
class SMSNotification implements Notification { ... }
class PushNotification implements Notification { ... }
```

---

## 2-2. 구조 해석

| 구분 | 역할 | 설명 |
|------|------|------|
| `NotificationFactory` | 상위(팩토리) | 객체 생성 규칙(인터페이스)을 정의 |
| `Email/SMS/PushNotification` | 하위(구체 클래스) | 어떤 객체를 생성할지 실제 구현 |
| `Notification` | 인터페이스 | 공통 기능 정의 |
| `Main` | 클라이언트 | 구체 클래스는 모르고 팩토리만 사용 |

---

## 2-3. 현재 구조의 한계

현재 구조는 상위 클래스가 `if`로 직접 모든 객체를 생성하므로, 사실상 **Simple Factory**이다.

즉, “어떤 객체를 만들지 결정하는 일”을 상위 클래스가 전담한다.  
그래서 네가 말한 “상위 클래스가 결정하는 거 아닌가?”가 정확히 맞다.

---

## 2-4. Factory Method로 발전시킨 구조

```java
abstract class NotificationFactory {
    abstract Notification createNotification();
}

class EmailNotificationFactory extends NotificationFactory {
    Notification createNotification() { return new EmailNotification(); }
}

class SMSNotificationFactory extends NotificationFactory {
    Notification createNotification() { return new SMSNotification(); }
}

class PushNotificationFactory extends NotificationFactory {
    Notification createNotification() { return new PushNotification(); }
}
```

이제:
- 상위 클래스는 `createNotification()`이라는 **생성 틀**만 정의.
- 하위 클래스가 실제로 **어떤 객체를 만들지** 결정한다.

이게 “상위 클래스는 생성 인터페이스만, 하위 클래스는 구체 생성 책임”이라는 말의 진짜 의미다.

---

## 2-5. 차이 요약

| 구분 | Simple Factory | Factory Method |
|------|----------------|----------------|
| 객체 생성 주체 | 상위 클래스 | 하위 클래스 |
| 코드 구조 | 단일 팩토리 내부 `if` | 추상 팩토리 + 하위 팩토리 |
| 확장성 | 낮음 (기존 코드 수정 필요) | 높음 (새 팩토리 추가만 하면 됨) |
| 적용 원칙 | 변경에 열림 ❌ | 변경에 닫히고 확장에 열림 ⭕ |

---

# 📌 3. 오퍼랜드(Operand)

## 3-1. 기본 개념

- **연산자(operator)**: 연산을 수행하는 기호 (예: `+`, `-`, `*`)
- **오퍼랜드(operand)**: 연산의 대상(피연산자)

```c
int a = 5 + 3;
```
- `+` → 연산자  
- `5`, `3` → 오퍼랜드  
- `a` → 결과 저장 변수

즉, 연산자는 ‘행동’, 오퍼랜드는 ‘재료’이다.

---

## 3-2. 오퍼랜드 수에 따른 분류

| 연산자 종류 | 오퍼랜드 수 | 예시 |
|--------------|--------------|------|
| 단항(Unary) | 1 | `++a`, `-x`, `!flag` |
| 이항(Binary) | 2 | `a + b`, `x > y` |
| 삼항(Ternary) | 3 | `조건 ? 참 : 거짓` |

---

## 3-3. CPU 명령어 수준의 오퍼랜드

예시:

```
ADD R1, R2, R3
```
- 연산자: `ADD`  
- 오퍼랜드: `R1`, `R2`, `R3`

오퍼랜드의 형태:
1. **즉시값(Immediate)** → 명령어 내부에 값 포함 (`MOV AX, 10`)
2. **레지스터(Register)** → 레지스터 값 사용
3. **메모리(Memory)** → 메모리 주소 접근

---

# 📌 4. 페이지(Page)와 페이지 프레임(Page Frame)

## 4-1. 페이지(Page)

- 프로세스의 **가상 메모리 공간을 일정한 크기로 나눈 블록**.
- 보통 한 페이지는 4KB.
- 예: 1MB 프로그램 → $1MB / 4KB = 256$ 페이지.

프로세스는 연속된 메모리처럼 보이지만 실제로는 여러 페이지로 나뉘어 있다.

---

## 4-2. 페이지 프레임(Page Frame)

- **물리적 메모리(RAM)**를 같은 크기로 나눈 블록.
- 페이지와 페이지 프레임의 크기는 항상 동일.

즉, 가상 메모리의 “페이지”가 실제 메모리의 “페이지 프레임”에 올라간다.

---

## 4-3. 페이지 ↔ 프레임 매핑

| 항목 | 설명 |
|------|------|
| 페이지(Page) | 가상 메모리 단위 |
| 페이지 프레임(Page Frame) | 물리 메모리 단위 |
| 페이지 테이블(Page Table) | 페이지-프레임 매핑 관리 |

예: 가상주소 0x0000~0x0FFF (페이지 0) → 물리주소 0x1000~0x1FFF (프레임 1)

---

## 4-4. 페이지 교체

물리 메모리가 꽉 찼을 때, 새로운 페이지를 불러오려면 기존 페이지 중 하나를 내보내야 한다.  
이때 사용하는 것이 **페이지 교체 알고리즘**이다.  
대표 알고리즘: FIFO, LRU, LFU 등.

---

## 4-5. 비유

- 페이지 = 책의 쪽 번호 (논리적 위치)  
- 페이지 프레임 = 종이 한 장 (물리적 위치)  
- 페이지 테이블 = 목차표 (매핑 관계)

---

# 📌 5. 기아 현상(Starvation)

## 5-1. 정의

**기아 현상(starvation)**은 특정 프로세스가 필요한 자원을 **계속 할당받지 못해 무한 대기 상태에 빠지는 것**을 의미한다.  
> 즉, “기회를 영영 얻지 못하는 무한 대기 상태.”

---

## 5-2. 발생 사례

### (1) 우선순위 스케줄링

높은 우선순위 프로세스들이 계속 들어오면, 낮은 우선순위 프로세스는 영원히 실행되지 못한다.

### (2) 자원 할당

특정 프로세스가 계속 자원을 조금씩 점유하고 반납하면,  
다른 프로세스가 한꺼번에 필요한 자원을 확보하지 못하고 계속 대기한다.

---

## 5-3. 교착상태(Deadlock)와의 차이

| 구분 | 기아(Starvation) | 교착상태(Deadlock) |
|------|------------------|--------------------|
| 정의 | 자원을 계속 못 받는 상태 | 서로 자원을 점유하며 무한 대기 |
| 원인 | 우선순위 불균형, 비공정 스케줄링 | 순환적 자원 의존 관계 |
| 해결 가능성 | 공정 스케줄링으로 가능 | 외부 개입 없이는 불가 |
| 예시 | 낮은 우선순위 프로세스의 무한 대기 | A가 B의 자원을, B가 A의 자원을 기다림 |

요약:  
- 교착상태: 서로 잡고 막고 있는 상태  
- 기아: 기회조차 얻지 못하는 상태

---

## 5-4. 해결 방법

1. **에이징(Aging):** 오래 기다린 프로세스의 우선순위를 점점 높인다.  
2. **라운드 로빈:** 모든 프로세스에 시간 단위로 CPU를 공평하게 배분.  
3. **공정 스케줄링:** CPU 사용률을 모니터링하여 덜 받은 프로세스에 기회를 더 준다.

---

## 5-5. 비유

학교 급식 줄에서 “공부 잘하는 학생만 먼저 밥을 준다면”,  
공부 못하는 학생은 영원히 못 먹는다 → **기아 현상**  
“아직 밥 못 받은 학생 먼저 주자”라는 규칙이 **Aging**에 해당한다.

