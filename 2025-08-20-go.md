# 📌 0. 포인터
### 📌 0-1. 포인터 기본원리
- go에도 c언어에서와 마찬가지로 포인터가 있다.
- new 함수를 이용해서도 포인터를 반환할 수 있다. 이때 newInt := new(int) 일때 기본값을 할당한 메모리의 주소를 newInt에 반환한다.
- 이때 new(T)이므로 미리 정의된 구조체를 할당할 수도 있다. new(Player)
```go
package main
import "fmt"
// int 포인터를 인자로 받아 원본 int 값을 변경하는 함수
func incrementWithPointer(x *int) {
    *x++ // x가 가리키는 값(원본 변수)을 1 증가
    fmt.Println(" incrementWithPointer 함수 내부 *x:", *x)
}
// Player 구조체 포인터를 인자로 받아 원본 구조체 필드를 변경하는 함수
func levelUpWithPointer(p *Player) {
    p.Level++ // (*p).Level++ 와 동일 (Go가 자동으로 역참조)
    fmt.Println(" levelUpWithPointer 함수 내부 Player:", *p)
}
type Player struct {
    Name string
    Level int
}

func main() {
 // 3.1 기본 타입에 포인터 사용
    a := 5
    incrementWithPointer(&a) // a의 주소를 전달
   

    // 3.2 구조체에 포인터 사용
    p := Player{Name: "Warrior", Level: 10}
    levelUpWithPointer(&p) // p의 주소를 전달
    

 // 3.3 new 함수를 이용한 포인터 생성
 // new(T)는 T 타입의 제로 값으로 초기화된 변수를 할당하고 그 주소를 반환한다.
    newInt := new(int) // int 타입의 포인터 (*int) 반환, *newInt는 0으로 초기화
    *newInt = 123

    newPlayer := new(Player) // Player 타입의 포인터 (*Player) 반환, 필드는 제로 값으로 초기화

    newPlayer.Name = "Mage"
    newPlayer.Level = 5
}
```

### 📌 0-2. 메모리 관리 스택 vs. 힙
- Go는 개발자가 메모리를 직접 할당하고 해제할 필요가 없도록 가비지 컬렉터(GC)를 제공한다.
- 변수가 스택에 할당될지 힙에 할당될지는 컴파일러의 **이스케이프 분석(Escape Analysis)**에 의해 결정된다.
- 이스케이프 분석 (Escape Analysis): Go 컴파일러는 변수가 함수 범위를 벗어나(escape) 다른 곳에서 참조될 가능성이 있는지 분석한다
- 스택 할당: 변수가 함수 내부에서만 사용되고 함수 종료 후 더 이상 필요 없는 경우.
- 힙 할당: 변수가 함수 외부로 "이스케이프"하여 함수 종료 후에도 참조될 수 있는 경우 (예: 함수의 반환 값으로 포인터가 전달되거나, 전역 변수에 할당되는 경우).
```go
package main
import "fmt"
// 이 함수는 int 포인터를 반환하므로, x는 힙에 할당될 가능성이 높다 (이스케이프).
func createIntPointer() *int {
    x := 10 // x는 함수 내부에서 선언되었지만, 주소가 반환되므로 힙으로 이스케이프될 수 있다.
    fmt.Println(" createIntPointer 내부 - x의 주소:", &x)
    return &x
}
// 이 함수는 int 값을 반환하므로, y는 스택에 할당될 가능성이 높다.
func createIntValue() int {
    y := 20 // y는 함수 종료 후 더 이상 참조되지 않으므로 스택에 할당될 가능성이 높다.
    fmt.Println(" createIntValue 내부 - y의 주소 (개념적):", &y) // 실제 주소는 스택 프레임 내
    return y
}
// 큰 구조체를 값으로 반환하는 경우 (복사 비용 발생)
type LargeStruct struct {
    Data [1024]byte // 1KB 크기의 배열
}
func createLargeStructByValue() LargeStruct {
    var s LargeStruct
    // s에 데이터 채우기
    return s // s 전체가 복사되어 반환된다.
}
// 큰 구조체를 포인터로 반환하는 경우 (복사 비용 감소, 힙 할당 가능성 높음)
func createLargeStructByPointer() *LargeStruct {
    s := new(LargeStruct) // 힙에 할당될 가능성 높음
    // s에 데이터 채우기
    return s // 포인터 값만 복사되어 반환된다.
}
func main() {
 // 5.1 이스케이프 분석 예시
    fmt.Println("---", "5.1 이스케이프 분석 예시", "---")
    ptr := createIntPointer()
    fmt.Println("main 함수 - ptr이 가리키는 값:", *ptr) // 10
    *ptr = 15
    fmt.Println("main 함수 - ptr이 가리키는 값 변경 후:", *ptr) // 15
    val := createIntValue()
    fmt.Println("main 함수 - val:", val) // 20

    // 5.2 큰 데이터 구조 전달 방식에 따른 메모리 효율성 (개념적)
    fmt.Println("\n---", "5.2 큰 데이터 구조 전달 방식에 따른 메모리 효율성", "---")
    // 값으로 전달: LargeStruct 전체가 복사된다. (비용 높음)
    largeVal := createLargeStructByValue()
    fmt.Printf("LargeStruct (값): %p\n", &largeVal)
    // 포인터로 전달: 포인터 값만 복사된다. (비용 낮음)
    largePtr := createLargeStructByPointer()
    fmt.Printf("LargeStruct (포인터): %p\n", largePtr)
}
```

### 📌 0-3. 가비지 컬렉션 (Garbage Collection)
- 동시성 GC: Go의 GC는 대부분의 작업을 애플리케이션과 동시에 수행하여 프로그램 실행을 멈추는 시간(Stop-theWorld, STW)을 최소화한다. 이는 Java의 최신 GC(G1, ZGC 등)와 유사한 목표를 가진다.
- 마크-스윕(Mark-Sweep) 방식: Go의 GC는 기본적으로 마크-스윕 알고리즘을 사용한다.
Mark (표시): GC 루트(실행 중인 고루틴의 스택, 전역 변수 등)에서부터 도달 가능한 모든 객체를 표시한다.
- Sweep (청소): 표시되지 않은(도달 불가능한) 객체들을 메모리에서 해제한다.
- 튜닝 불필요: 대부분의 경우 Go의 GC는 별도의 튜닝 없이도 잘 동작하도록 설계되었다.
- 아래 명령어로 가비지 컬렉터를 강제로 호출할 수 있다.
```go
runtime.GC()
```
