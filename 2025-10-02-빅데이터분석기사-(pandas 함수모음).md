# 📌 1. pandas 기본 정리
### 📌 1-1. 데이터 프레임 만들기
- 범주형 데이터 타입이 있는것을 유의하자
- SQL에서 create를 하는 것과 비슷하다.
```py
pd.DataFrame({
    "실수" : pd.Series(dtype="float"),
    "정수" : pd.Series(dtype="int"),
    "문자열" : pd.Series(dtype="str"),
    "논리값" : pd.Series(dtype="bool"),
    "범주형" : pd.Series(dtype="category")
})
```

### 📌 1-2. 데이터 프레임 인덱싱 메서드
- 각 방법마다 다양한 기능이 있지만 혼선을 방지하기 위해 목적에 따라 해당 
1. [] → "열 이름 바로 뽑기 전용"
2. loc[] → 라벨(label) 기반: 행 라벨 + 열 라벨 조합
3. .iloc[] → 위치(position) 기반: 행 인덱스 + 열 인덱스
- 2, 3번에서 [행, 열] 조건이 들어가는데 열 기준을 생략하면 :이다.
```py
# [] : 열 뽑기
df["age"]

# loc : 라벨 기반
df.loc[101, "age"]          # 특정 값
df.loc[100:103, ["age"]]    # 여러 행 + 특정 열

# iloc : 위치 기반
df.iloc[0, 1]               # 1행 2열 값
df.iloc[0:3, 0:2]           # 1~3행, 1~2열
```
- isin() 함수: 해당 값이 포함된 속성값만 True로 마스킹한다. -> 나머지는 False 
- isin()의 내부는 무조건 리스트로 주어야한다.
- 맨 앞에 ~를 붙이면 반대로 마킹한다.
```py
df["inappeventcategory"].isin(["home.view"]) # inappeventcategory 열에서 속성값이 home.view인 곳만 True표시
~df["inappeventcategory"].isin(["home.view"]) # 위와 반대로 bollean 마킹
```

### 📌 1-3. 결측치 관련
- 보통 결측치를 판별할땐 아래처럼 한다. 결측치를 확인하고 싶은 열이 "isfirstactivity","sourcetype" 라면
1. df[["isfirstactivity","sourcetype"]]
→ 두 열만 잘라옴.

2. .isna()
→ 두 열의 모든 셀을 불리언(True/False)로 변환. (일일히 결측치인지 판별)

3. .sum()
→ 열 단위 합계 → 결측치 개수만 남음.
- 잘쓰진 않지만 완전히 결측치를 삭제한 데이터프레임을 얻고 싶으면 dropna를 하면 된다.
```py
df[["isfirstactivity","sourcetype"]].isna().sum()
``` 

### 📌 1-4. concat과 merge
- concat의 join: 열 구조 맞춤 (형식적 합집합/교집합)
- merge: 데이터 값 기반 매칭 (진짜 SQL JOIN)
- concat은 두 데이터를 합치는 것으로 union all과 같다.
- 이때 join 값을 inner로 주면 교집합인 열만 병합하게 된다.

| 옵션                   | 기본값       | 설명                                                  | 예시                                             |
| -------------------- | --------- | --------------------------------------------------- | ---------------------------------------------- |
| **objs**             | 필수        | 합칠 DataFrame이나 Series 리스트/딕셔너리                      | `pd.concat([df1, df2])`                        |
| **axis**             | `0`       | 합칠 축 지정. <br> `0`: 행 방향(위아래), `1`: 열 방향(좌우)         | `pd.concat([df1, df2], axis=1)`                |
| **join**             | `'outer'` | 인덱스/열이 다를 때 맞추는 방식. <br> `outer`: 합집합, `inner`: 교집합 | `pd.concat([df1, df2], join='inner')`          |
| **ignore_index**     | `False`   | `axis=0`일 때 기존 인덱스 무시하고 새로 0부터 번호 붙임                | `pd.concat([df1, df2], ignore_index=True)`     |
| **keys**             | `None`    | 합친 결과에 상위 레벨 인덱스를 부여 (계층적 인덱스 MultiIndex 생성)        | `pd.concat([df1, df2], keys=['A','B'])`        |
| **levels**           | `None`    | `keys`와 함께 사용. 계층적 인덱스의 레벨 값 지정                     | 잘 안 쓰이지만 멀티인덱스 직접 제어 가능                        |
| **names**            | `None`    | `keys`와 함께 사용. 계층적 인덱스 레벨 이름 지정                     | `names=["dataset"]`                            |
| **verify_integrity** | `False`   | 중복 인덱스가 생기면 에러 발생시킴                                 | `pd.concat([df1, df2], verify_integrity=True)` |
| **sort**             | `False`   | `join='outer'`일 때, 합칠 때 열/행을 정렬할지 여부                | `pd.concat([df1, df2], sort=True)`             |
| **copy**             | `True`    | 원본 객체 복사 여부. `False`로 하면 메모리 절약 가능하지만 주의 필요         | 보통 기본값 유지                                      |

```py
df1 = pd.DataFrame({"A": [1, 2], "B": [3, 4]})
df2 = pd.DataFrame({"A": [5, 6], "B": [7, 8]})
df3 = pd.DataFrame({"B": [9, 10], "C": [11, 12]})

# 1. 기본 concat (행 방향, axis=0)
print(pd.concat([df1, df2]))

# 2. 열 방향 concat (axis=1)
print(pd.concat([df1, df2], axis=1))

# 3. 인덱스 무시 (ignore_index=True)
print(pd.concat([df1, df2], ignore_index=True))

# 4. 서로 다른 열 합치기 (join 옵션)
print(pd.concat([df1, df3], join="outer"))   # 기본 outer → A,B,C 다 포함
print(pd.concat([df1, df3], join="inner"))   # inner → 공통 열(B)만 포함

# 5. keys 옵션으로 멀티인덱스 생성
print(pd.concat([df1, df2], keys=["first", "second"]))

# 6. verify_integrity (중복 인덱스 에러 발생)
try:
    print(pd.concat([df1, df2], verify_integrity=True))
except Exception as e:
    print("에러 발생:", e)
```
- 반면 merge는 진짜 sql join문처럼 on으로 합칠 기준이될 열(key)을 정하고 join의 형태를 명시해준다.
- inner는 합칠 두 열에 모두 존재하는 key값에 대해 병합하고 outer는 하나에만 존재하는 key여도 일단 병합하고 빈셀은 nan으로 채운다.
```py
df3 = pd.DataFrame({"id": [1, 2, 3], "score": [10, 20, 30]})
df4 = pd.DataFrame({"id": [2, 3, 4], "grade": ["A", "B", "C"]})

print(pd.merge(df3, df4, on="id", how="inner"))
```


# 📌 2. pandas 데이터 프레임 객체의 기본 메서드
- info, describe, head, tail같은 쉬운 메서드와 apply, astype, rename등 많이 써왔던 함수는 제외하였다.
- 또 assign은 굳이 []로 열을 생성하는 것과 같은 역할로 굳이 필요성을 느끼지 못해 적어두지 않았다.
### 📌 2-1. sort_values
- 데이터를 특정 열의 데이터를 기준으로 정렬하는데 sql의 order by 처럼 첫번째 열이름으로 우선 정렬하고 같으면 다음 열 이름으로 정렬한다. 
- accending 즉 오름차순이 기본이므로 내림차순으로 바꾸려면 옵션을 아래처럼 바꾸어주어야한다.
```py
df.sort_values(by=["column1","column2"], ascending=False)
```

### 📌 2-2. idxmax와 idxmin
- 주어진 컬럼에서 최솟값 혹은 최댓값을 갖는 행의 인덱스를 열별로 추출한다.
```py
import pandas as pd

# 데이터 생성
s = pd.Series([10, 25, 7, 30, 18], index=["a", "b", "c", "d", "e"])
print(s)

# 최대값, 최소값의 인덱스 구하기
print("idxmax:", s.idxmax())  # 값이 가장 큰 위치 → 'd'
print("idxmin:", s.idxmin())  # 값이 가장 작은 위치 → 'c'
```

### 📌 2-3. groupby
- Sql의 groupby와 같은 기능이나 기본으로 해당 열을 인덱스로 만들어버린다. 그래서 as_index 옵션을 False로 주면 아예 sql처럼 만들 수 있다.
```py
import pandas as pd

# 예제 데이터
df = pd.DataFrame({
    "team": ["A", "A", "B", "B", "C"],
    "score": [10, 20, 15, 25, 30]
})

# 1. as_index=True (기본값)
print("\n기본 groupby (as_index=True):")
print(df.groupby("team")["score"].mean())

# 2. as_index=False
print("\nas_index=False:")
print(df.groupby("team", as_index=False)["score"].mean())
```

### 📌 2-4. 데이터 재구조화 관련 메서드 (melt와 pivot_table)
- pd.melt는 한 열을 기준으로 나머지 열을 녹여서 variable 속성값으로 만들고 그에 해당하는 원래 속성값을 value로 만든다.
- 즉 한 열만 남겼을 경우 총 열은 3개로 줄어든다. 
```py
# wide 형태 데이터
df = pd.DataFrame({
    "student": ["A", "B", "C"],
    "math": [90, 80, 70],
    "english": [85, 95, 75]
})
print("원본 DataFrame:")
print(df)

# melt 적용
melted = pd.melt(df, id_vars=["student"], value_vars=["math", "english"],
                 var_name="subject", value_name="score")
print("\nMelt 결과:")
print(melted)
```
```lua
원본 DataFrame:
  student  math  english
0       A    90       85
1       B    80       95
2       C    70       75

Melt 결과:
  student  subject  score
0       A     math     90
1       B     math     80
2       C     math     70
3       A  english     85
4       B  english     95
5       C  english     75
```
- pivot_table은 groupby와 같은데 이 melt된 형태를 남겼던 열을 기준으로 다시 병합한다.
```py
# melt된 데이터 (long 형태)
melted = pd.DataFrame({
    "student": ["A","B","C","A","B","C"],
    "subject": ["math","math","math","english","english","english"],
    "score": [90,80,70,85,95,75]
})
print("Melted DataFrame:")
print(melted)

# pivot_table로 wide 형태 복원
pivoted = melted.pivot_table(
    index="student",       # 행 인덱스 → 학생
    columns="subject",     # 열 → 과목
    values="score",        # 값 → 점수
    aggfunc="mean"         # 중복값 있을 때 집계 함수
)

# 인덱스를 열로 돌리기 (원래 형태처럼 보기)
pivoted = pivoted.reset_index()

print("\nPivot 결과:")
print(pivoted)
```
```lua
Melted DataFrame:
  student  subject  score
0       A     math     90
1       B     math     80
2       C     math     70
3       A  english     85
4       B  english     95
5       C  english     75

Pivot 결과:
subject student  english  math
0             A       85    90
1             B       95    80
2             C       75    70
```

### 📌 2-5. select_dtypes()
- 특정 데이터타입을 가진 열만 선택할때 사용한다.
- []로 찝는 대신 특정 데이터 타입의 열만 보고 싶을때 이를 사용하면 된다.
```py
df.select_dtypes(include=["int64"])      # 정수형 열만 선택
df.select_dtypes(include=["float"])      # 실수형 열만 선택
df.select_dtypes(include=["object"])     # 문자열(object) 열만 선택
df.select_dtypes(exclude=["number"])     # 숫자형 빼고 선택
```

### 📌 2-6. 칼럼명 패턴활용하여 선택하기
- str.startswith()
- 특정 접두사로 시작하는 문자열 여부(True/False)를 보여준다.
```py
df["col"].str.startswith("pre")
```
- str.endswith()
- 특정 접미사로 끝나는 문자열 여부(True/False)를 보여준다.
```py
df["col"].str.endswith(".com")
```
- str.contains()
- 부분 문자열(패턴) 포함 여부(True/False)를 보여준다.
```py
df["col"].str.contains("apple")
df["col"].str.contains("^A", regex=True)   # 정규식 사용 (A로 시작)
```

| 메서드                        | 설명                            | 예시                                   |
| -------------------------- | ----------------------------- | ------------------------------------ |
| `str.lower()`              | 모든 문자를 소문자로 변환                | `"Apple" → "apple"`                  |
| `str.upper()`              | 모든 문자를 대문자로 변환                | `"Apple" → "APPLE"`                  |
| `str.title()`              | 단어별 첫 글자를 대문자로 변환             | `"hello world" → "Hello World"`      |
| `str.strip()`              | 문자열 양쪽 공백 제거                  | `"  data  " → "data"`                |
| `str.lstrip()`             | 왼쪽 공백 제거                      | `"  data" → "data"`                  |
| `str.rstrip()`             | 오른쪽 공백 제거                     | `"data  " → "data"`                  |
| `str.replace(a, b)`        | 특정 문자열 교체                     | `"apple".replace("a","A") → "Apple"` |
| `str.contains("패턴")`       | 특정 문자열/정규식 포함 여부 (True/False) | `"apple" → True`                     |
| `str.startswith("패턴")`     | 특정 접두사 여부 (True/False)        | `"apple".startswith("a") → True`     |
| `str.endswith("패턴")`       | 특정 접미사 여부 (True/False)        | `"apple".endswith("e") → True`       |
| `str.len()`                | 문자열 길이 반환                     | `"apple" → 5`                        |
| `str.slice(start, end)`    | 문자열 슬라이싱                      | `"apple".slice(0,3) → "app"`         |
| `str.cat(sep="-")`         | 문자열 합치기                       | `["a","b"].cat(sep="-") → "a-b"`     |
| `str.split("구분자")`         | 문자열 나누기 (리스트 반환)              | `"a,b,c" → ["a","b","c"]`            |
| `str.get(i)`               | split된 리스트에서 i번째 원소 추출        | `"a,b,c".split(",").get(0) → "a"`    |
| `str.pad(width, fillchar)` | 고정 길이 맞추기 (패딩 추가)             | `"7".pad(3,"0") → "007"`             |
| `str.zfill(width)`         | 숫자형 문자열을 0으로 채워 고정 길이         | `"7".zfill(3) → "007"`               |


# 📌 3. pandas 활용 날짜 처리
### 📌 3-1. to_datetime
- datetime으로 자료형을 변환할 경우 날짜간 차이를 계산하거나 dt.으로 날짜를 조작할 수 있게된다.
```py
# 1. 기본 문자열 변환
print(pd.to_datetime("2025-10-02"))
# → Timestamp('2025-10-02 00:00:00')

# 2. 리스트/시리즈 변환
dates = ["2025-01-01", "2025-02-15", "2025-03-20"]
print(pd.to_datetime(dates))

# 3. 다른 포맷 지정 (format=)
print(pd.to_datetime("02-10-2025", format="%d-%m-%Y"))
# → Timestamp('2025-10-02 00:00:00')

# 4. 숫자를 날짜로 (정수 → 유닉스 타임스탬프: ns 단위)
print(pd.to_datetime([1609459200000], unit="ms"))  
# → DatetimeIndex(['2021-01-01'], dtype='datetime64[ns]', freq=None)

# 5. 잘못된 값 처리 (errors="coerce")
print(pd.to_datetime(["2025-01-01", "not_a_date"], errors="coerce"))
# → DatetimeIndex(['2025-01-01', 'NaT'], dtype='datetime64[ns]', freq=None)

# 6. 날짜 부분만 시리즈에서 변환
df = pd.DataFrame({"day": ["2025-01-01", "2025-01-02"], "value": [10, 20]})
df["day"] = pd.to_datetime(df["day"])
print(df.dtypes)
# → day      datetime64[ns]
#   value             int64
```

### 📌 3-2. 날짜 연산
```py
# -----------------------------------
# 1. 날짜 연산 (dt 접근자 활용)
# -----------------------------------
dates = pd.to_datetime(["2025-01-01", "2025-02-15", "2025-03-20"])
s = pd.Series(dates)

print("원본 날짜:")
print(s)

# 날짜에서 연도, 월, 일, 요일 추출
print("\n연도:", s.dt.year.values)
print("월:", s.dt.month.values)
print("일:", s.dt.day.values)
print("요일(월=0):", s.dt.weekday.values)

# 날짜 연산 (timedelta)
print("\n+7일:", s + pd.Timedelta(days=7))
print("-2개월:", s - pd.DateOffset(months=2))

# 두 날짜 차이
print("\n날짜 차이:")
print(s - pd.to_datetime("2025-01-01"))

# -----------------------------------
# 2. 날짜 범위 생성 (date_range)
# -----------------------------------
# 매일 증가
rng_day = pd.date_range(start="2025-01-01", end="2025-01-10", freq="D")
print("\n날짜 범위 (일 단위):")
print(rng_day)

# 매월 1일
rng_month = pd.date_range(start="2025-01-01", periods=6, freq="MS")
print("\n날짜 범위 (월 단위):")
print(rng_month)

# 영업일만
rng_biz = pd.date_range(start="2025-01-01", periods=5, freq="B")
print("\n날짜 범위 (영업일):")
print(rng_biz)

# -----------------------------------
# 3. 날짜 합치기 (combine, to_period 등)
# -----------------------------------
df = pd.DataFrame({
    "year": [2023, 2024, 2025],
    "month": [1, 6, 12],
    "day": [15, 20, 31]
})

# 연, 월, 일을 합쳐 날짜로 만들기
df["date"] = pd.to_datetime(df[["year", "month", "day"]])
print("\n연월일 합치기:")
print(df)

# period로 변환 (연/월 기준)
print("\n연월(period):")
print(df["date"].dt.to_period("M"))
```
- pd.date_range() 같은 날짜 범위 생성 함수에서 **freq**는 **frequency(빈도)**의 줄임말이고, "날짜를 몇 간격으로 늘려갈지"를 정하는 옵션이다.
- periods는 pd.date_range()에서 생성할 날짜 개수를 정하는 옵션으로
- start, freq와 함께 쓰면 “시작일부터 일정 간격(freq)으로 몇 개(periods)를 만들지” 결정하며
- 반대로 start + end를 쓰면, periods 대신 날짜 범위를 끝까지 자동 생성한다.

| 코드           | 의미                     | 예시                                              |
| ------------ | ---------------------- | ----------------------------------------------- |
| `D`          | Day, 매일                | `2025-01-01, 2025-01-02, ...`                   |
| `B`          | Business day, 평일(영업일)만 | `2025-01-01(수), 2025-01-02(목), ...`             |
| `W`          | Weekly, 주 단위           | `2025-01-05, 2025-01-12, ...`                   |
| `M`          | Month end, 매월 말일       | `2025-01-31, 2025-02-28, ...`                   |
| `MS`         | Month start, 매월 1일     | `2025-01-01, 2025-02-01, ...`                   |
| `Q`          | Quarter end, 분기 마지막 날  | `2025-03-31, 2025-06-30, ...`                   |
| `QS`         | Quarter start, 분기 시작일  | `2025-01-01, 2025-04-01, ...`                   |
| `A` or `Y`   | Year end, 연말           | `2025-12-31, 2026-12-31, ...`                   |
| `AS` or `YS` | Year start, 연초         | `2025-01-01, 2026-01-01, ...`                   |
| `H`          | Hour, 매시간              | `2025-01-01 00:00, 2025-01-01 01:00, ...`       |
| `T` or `min` | Minute, 분 단위           | `2025-01-01 00:00, 2025-01-01 00:01, ...`       |
| `S`          | Second, 초 단위           | `2025-01-01 00:00:00, 2025-01-01 00:00:01, ...` |

# 📌 4. 정규표현식
### 📌 4-1. 자주 사용하는 정규표현식과 정규표현식 함수
- 자주사용하는 정규표현식 패턴

| 패턴                                               | 의미               | 예시 매칭                          |
| ------------------------------------------------ | ---------------- | ------------------------------ |
| `\d+`                                            | 숫자(0–9, 한 자리 이상) | `123`, `42`                    |
| `\d{4}`                                          | 정확히 4자리 숫자       | `2025`                         |
| `\d{2,3}-\d{3,4}-\d{4}`                          | 한국 전화번호 형식       | `010-1234-5678`, `02-123-4567` |
| `[A-Za-z]+`                                      | 영어 알파벳 단어        | `Apple`, `data`                |
| `[가-힣]+`                                         | 한글 연속            | `데이터`, `분석`                    |
| `\w+`                                            | 단어 문자(영문/숫자/_)   | `var_1`, `A9`                  |
| `\s+`                                            | 공백(스페이스, 탭)      | `"   "`                        |
| `^abc`                                           | `abc`로 시작하는 문자열  | `abc123`                       |
| `xyz$`                                           | `xyz`로 끝나는 문자열   | `endxyz`                       |
| `.`                                              | 임의의 문자 1개        | `a`, `1`, `!`                  |
| `.*`                                             | 임의의 문자 0개 이상     | `hello world` (전체)             |
| `[0-9]{2}/[0-9]{2}/[0-9]{4}`                     | 날짜(MM/DD/YYYY)   | `12/31/2025`                   |
| `[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}` | 이메일 주소           | `user@mail.com`                |
| `https?://\S+`                                   | URL (http/https) | `https://example.com`          |

- 자주 사용하는 정규표현식 함수

| 함수                                        | 설명                                       | 자주 쓰는 패턴 예시                                |
| ----------------------------------------- | ---------------------------------------- | ------------------------------------------ |
| `str.contains(pat, regex=True, na=False)` | 특정 패턴이 포함된 행을 `True/False`로 반환           | `s.str.contains(r"\d+")` → 숫자 포함 여부        |
| `str.extract(pat, expand=True)`           | 첫 번째 매칭된 패턴을 새로운 열(Series/DataFrame)로 반환 | `s.str.extract(r"(\d{4})")` → 4자리 숫자 추출    |
| `str.findall(pat)`                        | 패턴에 맞는 모든 매칭 결과를 리스트로 반환                 | `s.str.findall(r"[가-힣]+")` → 한글 단어들 리스트    |
| `str.replace(pat, repl, regex=True)`      | 정규표현식 패턴에 맞는 부분을 교체                      | `s.str.replace(r"\d+", "NUM", regex=True)` |
| `str.match(pat)`                          | 문자열 전체가 패턴과 매칭되는지 검사 (`^...$`와 유사)       | `s.str.match(r"^\d+$")` → 숫자로만 이루어진 행      |
| `str.split(pat)`                          | 패턴 기준으로 문자열 분할 (리스트 반환)                  | `s.str.split(r"\s+")` → 공백 기준 분리           |
