# 📌 0. go언어 기초
### 📌 0-1. Go 언어의 주요 특징
1. 간결하고 읽기 쉬움
문법이 단순해서 초보자도 배우기 좋다.
예: 세미콜론(;)도 대부분 자동으로 처리된다.

2. 빠른 실행 속도
Go는 컴파일 언어라서 C 언어처럼 기계어로 바뀌어 실행된다.
그래서 Python이나 JavaScript보다 빠른 편이다.

3. 병렬 처리(동시성)에 강함
goroutine이라는 가벼운 스레드(thread) 기능을 제공해서, 여러 작업을 동시에 실행하기 쉽다.
이게 Go 언어의 가장 큰 장점 중 하나이다.

4. 자동 메모리 관리(Garbage Collection)
C 언어처럼 메모리를 직접 해제할 필요가 없다.
Java나 Python처럼 필요 없는 메모리는 자동으로 정리된다.

5. 표준 라이브러리 풍부
기본 제공되는 라이브러리(패키지)만으로도 웹 서버, 파일 처리, 암호화 등 많은 걸 할 수 있다.

### 0-2. go언어 기본 코딩
- go언어는 ;을 자동으로 파악해서 붙여준다.
- c언어에서 처럼 main 함수에서 프로그램을 시작한다.
- 사용하지 않은 import는 에러로 처리한다.
```go
package main

import "fmt"

func main() {
	fmt.Println("Hello, go!")
}
```
- 접근제어자 표현은 따로 없고 메서드의 먄 앞글자가 대문자면 공개 소문자면 비공개이다. 
- go에서는 변수를 선언할때 var a int = 10이렇게 쓰고 타입을 자동으로 추론하게 하려면 var a = 10 으로 쓰면 된다.
- 이때 짧은 선언 (:=)을 사용하면 이 타입추론을 자동으로 한다. 하지만 이는 함수 내부에서만 사용할 수 있다. (a:=10)
```go
package main
import "fmt"
func main() {
	// 1.1 `var` 키워드를 사용한 변수 선언 및 초기화
	// Java: `String characterName = "Hossam";`와 유사. Go는 타입이 뒤에 온다.
	var characterName string = "Hossam"
	// Java: `int characterLevel = 99;`와 유사.
	var characterLevel int = 99
	// 1.2 `var` 키워드와 타입 추론을 사용한 변수 선언
	// 초기화 값으로 타입을 추론한다. Java 10+의 `var exp = 85.5;`와 유사.
	var exp = 85.5
	// 1.3 짧은 선언(`:=`)을 사용한 변수 선언 및 초기화
	// 함수 내부에서만 사용 가능하며, `var` 키워드와 타입 지정을 생략한다.
	// Go에서 가장 흔하게 사용되는 변수 선언 방식이다.
	isAlive := true
	// 1.4 변수 값 출력
	// `fmt.Println` 함수는 인자들을 공백으로 구분하여 출력하고 줄바꿈한다.
	fmt.Println("캐릭터 이름:", characterName)
	fmt.Println("레벨:", characterLevel)
	fmt.Println("경험치:", exp)
	fmt.Println("생존 여부:", isAlive)
}
```

### 📌 0-3. 상수값 
- 상수값은 const로 선언한다. js의 const와 같고 java의 final과 같다.
- iota는 **그리스 알파벳 소문자 ι(요타)**에서 온 말로 요타 = 가장 작은 알파벳 → 그래서 영어에서는 “아주 작은 양, 극히 적은 부분” 이라는 의미로 쓰인다.
- 알파벳으로는 i인데 시각적으로 가장 작아보인다.
- 즉, 아주 작고 기본적인 단위라는 의미가 있다.
- iota는 **상수(constant) 열거(enumeration)**를 만들 때 사용된다. 즉, 0부터 시작해서 자동으로 1씩 증가하는 값을 의미한다.
```go
package main
import "fmt"
// 2.1 단일 상수 선언
// `const` 키워드를 사용하여 상수를 선언한다. Java의 `final` 키워드와 유사하다.
const MAX_LEVEL = 100
const SERVER_IP = "127.0.0.1"
// 2.2 `iota`를 사용한 그룹 상수 선언
// `iota`는 0부터 시작하여 `const` 블록 내에서 선언된 상수마다 1씩 자동으로 증가하는
특별한 상수 생성기이다.
// Java의 `enum`과 유사하게 열거형 상수를 정의할 때 유용하다.
const (
 STATE_IDLE = iota // 첫 번째 `iota`는 0. STATE_IDLE = 0
 STATE_WALK // `iota`가 1 증가하여 STATE_WALK = 1
 STATE_RUN // `iota`가 1 증가하여 STATE_RUN = 2
 STATE_JUMP // `iota`가 1 증가하여 STATE_JUMP = 3
)
func main() {
 // 2.3 상수 값 출력
 fmt.Println("최대 레벨:", MAX_LEVEL)
 fmt.Println("서버 IP:", SERVER_IP)
 fmt.Println("캐릭터 상태 - 대기:", STATE_IDLE)
 fmt.Println("캐릭터 상태 - 점프:", STATE_JUMP)
}
```

### 📌 0-4. 데이터타입
- go는 타입에 매우 엄격하므로 암시적 형 변환이 불가능하고 반드시 int64(변수)와 같은 형태로 명시적으로 형변환해야한다.
- rune은 고대 북유럽과 게르만족이 쓰던 **룬 문자(Runic alphabet)**에서 나온 말로 특정한 문자, 글자 하나를 뜻할 때 사용한다.

| Go 타입                                         | 설명                        | Java 대응 타입                            |
| --------------------------------------------- | ------------------------- | ------------------------------------- |
| `bool`                                        | 논리값 (`true` / `false`)    | `boolean`                             |
| `string`                                      | 문자열                       | `String`                              |
| `int`, `int8`, `int16`, `int32`, `int64`      | 부호 있는 정수                  | `int`, `byte`, `short`, `int`, `long` |
| `uint`, `uint8`, `uint16`, `uint32`, `uint64` | 부호 없는 정수                  | 해당 없음                                 |
| `float32`, `float64`                          | 부동소수점 숫자                  | `float`, `double`                     |
| `rune`                                        | 유니코드 문자 (실제로는 `int32` 별칭) | `char`                                |
| `byte`                                        | `uint8`의 별칭, 바이트 데이터 처리용  | `byte`                                |

```go
package main

import "fmt"

func main() {
	var level int = 10
	var monsterCount int64 = 100

	fmt.Println(int64(level) + monsterCount)

	var attackPower float32 = 35.5
	var defensePower float64 = 52.8

	fmt.Println(float64(attackPower) * defensePower)

	var message string = "Hello, World"
	var firstChar rune = 'H'

	fmt.Println(message)
	fmt.Print(string(firstChar))
}

```

### 📌 0-5. 제로값

| 타입                          | 제로 값         |
| --------------------------- | ------------ |
| 숫자 (`int`, `float` 등)       | `0`          |
| `bool`                      | `false`      |
| `string`                    | `""` (빈 문자열) |
| 포인터, 함수, 인터페이스, 슬라이스, 맵, 채널 | `nil`        |

### 📌 0-6. if-else문
- Go의 `if` 조건문에는 소괄호 `()`를 사용하지 않는다. 중괄호 `{}`는 필수이다.
- `if` 문 내에서만 유효한 변수를 선언하고 초기화할 수 있다. `exp` 변수는 `if`
블록 내에서만 사용 가능하다.
```go
package main
import "fmt"
func main() {
 characterLevel := 99 // 캐릭터 레벨 변수 선언 및 초기화
 // 5.1 기본 if-else 문
 // Go의 `if` 조건문에는 소괄호 `()`를 사용하지 않는다. 중괄호 `{}`는 필수이다.
 // Java의 `if (characterLevel >= 100)`와 유사하다.
 if characterLevel >= 100 {
    fmt.Println("만렙 달성!")
 } else { // `else`는 `if`의 닫는 중괄호 `}`와 같은 줄에 와야 한다.
    fmt.Println("아직 만렙이 아님.")
 }
 // 5.2 `if` 문 내에서 변수 선언 및 사용 (if-short statement)
 // `if` 문 내에서만 유효한 변수를 선언하고 초기화할 수 있다. `exp` 변수는 `if` 블록 내에서만 사용 가능하다.
 // 이는 Java에는 없는 Go의 특징적인 문법이다.
 if exp := 85.5; exp > 90.0 {
    fmt.Println("경험치 충분, 레벨 업 가능!")
 } else {
    fmt.Println("경험치가 부족함.")
 }
}
```

### 📌 0-7. for문
- Go에는 for문만 존재하며, Java의 for, while, for-each를 모두 대체함.

| 사용 방식              | Go                                     | Java                               |
| ------------------ | -------------------------------------- | ---------------------------------- |
| 기본 for문            | `for i := 0; i < 5; i++`               | `for (int i = 0; i < 5; i++)`      |
| while처럼 사용         | `for 조건 {}`                            | `while (조건) {}`                    |
| 무한 루프              | `for {}`                               | `for (;;) {}` 또는 `while (true) {}` |
| for-range (컬렉션 순회) | `for index, value := range collection` | `for (Type value : collection)`    |

```go
package main
import "fmt"
func main() {

 // 6.1 기본 for문 (Java의 `for (int i = 0; i < 3; i++)`와 동일)
 fmt.Println("--- 기본 for문 ---")
 for i := 0; i < 3; i++ { // 초기화; 조건; 증감문
    fmt.Println(i)
 }
 // 6.2 `while`문처럼 사용 (Java의 `while (count < 3)`와 동일)
 // Go에는 별도의 `while` 키워드가 없으며, `for` 조건문만 사용하여 `while` 루프를 구현한다.
 fmt.Println("--- while처럼 사용 ---")
 count := 0
 for count < 3 { // 조건문만 사용
    fmt.Println(count)
    count++
 }
 // 6.3 `for-range`문 (Java의 향상된 for문 `for (Type item : collection)`과유사)
 // 배열, 슬라이스, 맵, 문자열, 채널 등을 순회할 때 사용한다.
 // 슬라이스/배열/문자열의 경우 `index`와 `value`를 반환한다.
 fmt.Println("--- for-range문 ---")
 items := []string{"물약", "검", "방패"} // 문자열 슬라이스 선언
 for index, item := range items { // `index`는 요소의 인덱스, `item`은 요소의 값
    fmt.Printf("%d: %s\n", index, item)
 }
 // 6.4 무한 루프 (Java의 `while (true)` 또는 `for (;;)`)와 동일
 // `for {}` 형태로 사용한다.
 // for {
 // fmt.Println("무한 루프!")
 // time.Sleep(time.Second) // 1초 대기
 // }
}
```

### 📌 0-8. switch문
- Go의 switch문은 Java보다 더 유연하다.
- break를 명시하지 않아도 각 case가 끝나면 자동으로 멈춘다. 여러 조건을 한 번에 처리하거나, 조건식 자
체를 쓸 수 있다.
```go
package main
import "fmt"
func main() {
 state := "idle" // 캐릭터 상태 변수 선언
 // 7.1 기본 switch 문
 // Go의 `switch` 문은 Java의 `switch`와 유사하지만, `break`를 명시하지 않아도 m각 `case`가 끝나면 자동으로 멈춘다.
 // Java의 `switch`는 `break`가 없으면 다음 `case`로 넘어간다 (fallthrough).
 switch state {
    case "idle": // `state`가 "idle"인 경우
        fmt.Println("캐릭터가 쉬고 있음.")
    case "walk", "run": // 여러 조건을 콤마(,)로 구분하여 한 번에 처리할 수 있다.
        fmt.Println("캐릭터가 이동 중임.")
    default: // 모든 `case`에 해당하지 않는 경우 (Java의 `default`와 동일)
        fmt.Println("알 수 없는 상태임.")
 }
 // 7.2 조건식을 사용한 switch (Java의 `if-else if` 체인과 유사)
 // `switch` 뒤에 변수 없이 `case`에 직접 조건식을 사용할 수 있다.
 level := 45 // 캐릭터 레벨 변수 선언
 switch { // 조건식 없이 `switch` 키워드만 사용
    case level < 30: // `level`이 30 미만인 경우
        fmt.Println("초보자 레벨임.")
    case level >= 30 && level < 50: // `level`이 30 이상 50 미만인 경우
        fmt.Println("중급자 레벨임.")
    default: // 위 조건들에 모두 해당하지 않는 경우
        fmt.Println("고수 레벨임!")
 }
}
```

### 📌 0-9. 구조체 (Structs)
- Go에는 클래스가 없지만, struct를 사용하여 관련 있는 데이터 필드를 묶어 사용자 정의 타입을 만들 수 있
다. 이는 Java의 클래스나 데이터 객체와 유사하다.
- p1 := Player{Name: "Hero", Level: 10, HP: 100}처럼 선언하고 할당하여 사용한다.
```go
package main
import "fmt"
type Player struct {
 Name string
 Level int
 HP int
}
func main() {
 // 8-1. 구조체 선언 및 초기화
 p1 := Player{Name: "Hero", Level: 10, HP: 100}
 fmt.Println("플레이어 이름:", p1.Name)
 // 8-2. 필드 값 변경
 p1.Level = 11
 fmt.Println("플레이어 레벨:", p1.Level)
}
```

### 📌 0-10. 함수 (Functions) & 메서드

| 구분    | Go                          | Java                    |
| ----- | --------------------------- | ----------------------- |
| 기본 구조 | `func name(p type) retType` | `retType name(type p)`  |
| 다중 반환 | `func name() (int, string)` | (별도 클래스, 배열, 컬렉션 등이 필요) |

```go
package main
import "fmt"
// 9.1 함수 정의 및 다중 반환 값
// `func` 키워드로 함수를 정의한다. 매개변수와 반환 타입이 명시된다.
// Go 함수는 여러 개의 반환 값을 가질 수 있다. (Java는 단일 값만 반환 가능)
// 입력: `name` (string), `level` (int), `exp` (float64)
// 반환: `summary` (string), `canLevelUp` (bool)
func getCharacterSummary(name string, level int, exp float64) (string, bool) {
 // 함수 내부에서 상수 선언
 const MAX_LEVEL = 100
 const EXP_REQUIRED_FOR_LEVEL_UP = 90.0
 // `fmt.Sprintf`는 포맷팅된 문자열을 반환한다. Java의 `String.format()`과 유사
하다.
 summary := fmt.Sprintf("이름: %s, 레벨: %d, 경험치: %.1f", name, level, exp)
 // 레벨업 가능 여부를 판단하는 논리식
 canLevelUp := level < MAX_LEVEL && exp >= EXP_REQUIRED_FOR_LEVEL_UP
 // 두 개의 값을 반환한다.
 return summary, canLevelUp
}
func main() {
 // 9.2 함수 호출 및 다중 반환 값 받기
 // `summary`와 `canLevelUp` 변수에 각각 반환 값을 할당한다.
 summary, canLevelUp := getCharacterSummary("Hossam", 99, 85.5)
 fmt.Println(summary)
 // 9.3 반환된 `canLevelUp` 값을 이용한 조건문 처리
 if canLevelUp { // `canLevelUp`이 `true`이면 실행
    fmt.Println("레벨 업이 가능함!")
 } else { // `canLevelUp`이 `false`이면 실행
    fmt.Println("레벨 업까지 경험치가 더 필요함.")
 }
 // 9.4 다른 인자로 함수를 한 번 더 호출
 summary2, canLevelUp2 := getCharacterSummary("Alice", 80, 95.1)
 fmt.Println(summary2)
 if canLevelUp2 {
    fmt.Println("레벨 업이 가능함!")
 } else {
    fmt.Println("레벨 업까지 경험치가 더 필요함.")
 }
}
```

### 📌 0-11. 에러처리방식
- 함수 자체에서 에러를 리턴하도록 해야함
```go
package main
import "fmt"
func divide(a, b int) (int, error) {
 if b == 0 {
 return 0, fmt.Errorf("0으로 나눌 수 없음")
 }
 return a / b, nil
}
func main() {
 result, err := divide(10, 0)
 if err != nil {
 fmt.Println("에러 발생:", err)
 } else {
 fmt.Println("결과:", result)
 }
}
```

# 📌 1. go 언어 코딩테스트

### 📌 1-1. 나머지 구하기
- 암묵적 형변환이 안되므로 소수점을 살리고 싶으면 모두 실수로 바꾸고 진행해야한다.
```go
func solution(num1 int, num2 int) int {
    return int(float32(num1) / float32(num2) * 1000)
}
```

### 📌 1-2. go는 else를 무조건 붙여써야한다.
- else를 띄워서 쓰면 세미콜론을 붙이고 내려온 것으로 착각해서 무조건 if에 엔터를 치지않고 스페이스바만으로 붙여써야한다.
```go
func solution(angle int) int {
    if 0 < angle && angle < 90 {
        return 1
    } else if angle == 90 {
        return 2
    } else if angle == 180 {
        return 4
    } else {
        return 3
    }
}
```

### 📌 1-3. math.pow는 실수자료형으로 받고 실수자료형을 리턴한다.
- sq := int(math.Sqrt(float64(n)))도 이렇게 써야한다.
```go
func solution(n int, t int) int {
    return int(math.Pow(2, float64(t))) * n
}
```

### 📌 1-4. break도 똑같이 사용 가능하다
```go
func solution(n int) int {
    answer := 0
    
    for i := 1; i <= n; i++{
        if 6 * i % n == 0{
            answer = i
            break
        }
                            
    }
    return answer
}
```

