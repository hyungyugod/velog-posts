# 📌 1. 인덱스와 OLE / 첨부필드 인덱싱 불가

## 1-1. 인덱스(Index)의 전제 조건

- 인덱스는 **정렬·비교가 가능한 데이터**를 전제로 한다.
- 인덱스가 성립하려면:
  - 값들 사이에 **순서 관계**가 있어야 한다.
  - 예: 숫자, 텍스트, 날짜/시간, Yes/No 등
- 엑세스에서 인덱스가 가능한 대표 타입:
  - Short Text, Long Integer, Date/Time, Yes/No 등

정렬과 비교가 가능해야 $<$, $>$, 범위 검색, 중복 체크 등이 가능하므로 인덱스를 만들 수 있다.

## 1-2. OLE 개체 필드가 인덱스를 사용할 수 없는 이유

- OLE(Object Linking and Embedding) 필드는
  - Word 문서, Excel, 이미지, PDF 등 **비정형 데이터(Blob)** 를 저장한다.
- 엑세스 입장에서는 “큰 바이트 덩어리”일 뿐:
  - 문서 A $<$ 문서 B 이런 비교 개념이 없다.
  - 정렬 기준이 없으므로 인덱스의 수학적 전제가 깨진다.
- 또한:
  - 크기도 크고 비교 비용이 매우 크기 때문에
  - 성능상으로도 인덱스를 허용하면 폭발적인 비효율이 난다.
- 그래서 설계적으로:
  - **의미적으로 정렬 불가능 + 성능상 비합리** → 인덱스 금지

## 1-3. 첨부파일(Attachment) 필드 역시 인덱스 불가

- 첨부파일도 내부적으로 여러 파일(이미지, PDF)을 포함하는 복합 타입이다.
- 마찬가지로 비교·정렬 기준이 없기 때문에 인덱스를 만들 수 없다.
- 이들은 “데이터 저장용 필드”이지, 검색/정렬 최적화용 필드가 아니다.

---

# 📌 2. 입력 마스크 `>L???` 의 의미

## 2-1. 입력 마스크의 역할

- 입력 마스크(Input Mask)는 **입력 단계에서 형식을 강제하는 규칙**이다.
  - “대문자만 허용”, “숫자만 허용”, “자리수 고정” 같은 제약을 **입력 시점에** 걸어 데이터 무결성을 높인다.
- 필드 타입만으로는 제어하기 어려운 형식을 세밀하게 제약하는 도구다.

## 2-2. `>L???` 구성 요소 해석

- `>` : 이후 입력되는 **문자를 모두 대문자로 강제**
- `L` : **문자 1개 필수 입력**
  - 문자만 허용, 숫자·공백 불가
- `?` : **문자 1개 선택 입력**
  - 문자 허용, 숫자 불가, 입력 안 해도 됨
- `???` 이므로 $0 \sim 3$ 개 문자가 추가로 올 수 있다.

### 전체 의미

- 첫 글자: 반드시 문자 1개 (대문자로 강제)
- 그 뒤: 최대 3글자까지 **대문자 문자**를 선택적으로 입력 가능
- 허용 예: `A`, `AB`, `ABC`, `ABCD`
- 불가 예: `1BCD`, `A1C`, 공백 등

즉, **대문자 1~4자리 코드**를 입력하도록 강제하는 마스크이다.

---

# 📌 3. DateDiff에서 `"yyyy"` 와 `"yy"` 의 차이

## 3-1. `DateDiff("yyyy", ...)` 의 의미

- 두 날짜의 **연도 숫자 차이**를 단순히 계산한다.
- 공식 형태:
  - $ \text{EndYear} - \text{StartYear} $
- 월·일은 고려하지 않는다.
  - 예: 2023-06-15 ~ 2024-06-14 → `yyyy` 결과는 1

## 3-2. `DateDiff("yy", ...)` 의 의미

- 두 날짜 사이에 **연도 경계가 몇 번 바뀌었는지**를 센다.
- 즉, 캘린더 상에서 연도가 $2023 \to 2024$ 로 바뀌면 1회로 센다.
- 실제 경과 날짜(정확히 1년이 지났는가)와는 다를 수 있지만,  
  “연도가 넘어간 횟수”를 기준으로 한다.

## 3-3. 공통점과 차이

- 많은 경우 결과가 같지만, 의미는 다르다.
  - `yyyy` : 단순 연도 숫자 차이
  - `yy` : 연도 경계 변화 횟수
- 실무에서 나이 계산 등에는 단순 `yyyy`만 쓰면 실제 나이와 어긋날 수 있고,  
  정확한 나이는 월·일을 추가로 비교해야 한다.

---

# 📌 4. DoCmd, 매크로 함수, OpenReport / GoToRecord / RunCode

## 4-1. DoCmd의 정체

- `DoCmd` = **Do Command**
- 엑세스 내부의 **매크로 액션(Action)** 을 VBA에서도 호출할 수 있도록 만든 **명령 집합 객체**이다.
- 설계 철학:
  - “매크로에서 할 수 있는 동작은 VBA에서도 `DoCmd`로 그대로 할 수 있게 하자.”

## 4-2. 매크로 액션 vs VBA DoCmd 관계

- 매크로에서:
  - `OpenReport`, `GoToRecord`, `RunCode` 등의 “액션 이름”으로 사용
- VBA에서:
  - `DoCmd.OpenReport`, `DoCmd.GoToRecord`, `DoCmd.RunCode` 등으로 사용
- 내부적으로는 **같은 엔진(매크로 액션 엔진)** 을 호출한다.
  - UI(매크로 대화상자)로 쓰느냐
  - 코드(VBA + DoCmd)로 쓰느냐의 차이일 뿐

## 4-3. RunCode의 의미

- 매크로에서 `RunCode` 액션은 **VBA 함수 호출**을 의미한다.
- VBA에서 `DoCmd.RunCode "MyFunction()"` 처럼 호출하면  
  매크로 입장에서는 동일한 “코드 실행 액션”으로 인식된다.
- 즉, **매크로 ↔ VBA를 잇는 다리 역할**을 한다.

---

# 📌 5. 3차원 차트와 오차막대를 표시할 수 없는 이유

## 5-1. 3D 차트의 구조적 한계

- 3D 차트는 보기엔 화려하지만:
  - 깊이($z$축) 때문에 실제 값이 왜곡
  - 앞뒤 막대가 가려짐
  - 시점(rotation)에 따라 막대 높이가 다르게 보임
- **정확한 수치 해석에는 부적합한 구조**이다.

## 5-2. 오차막대의 목적과 충돌

- 오차막대(Error Bars)는:
  - 평균 주변의 신뢰구간, 표준편차, 표준오차 등  
    **불확실성(오차 범위)을 정확히 시각화**하는 도구이다.
- 이를 위해서는:
  - 기준 축(위/아래 방향)이 명확해야 하고
  - 길이를 비교 가능해야 한다.

3D에서는:
- 기준면이 기울어져 있고
- $x$, $y$, $z$ 중 어느 방향으로 오차막대를 표현할지 모호하며
- 가림(occlusion) 때문에 막대와 오차막대를 구분하기 어렵다.

그래서:
- **“정확성을 표현해야 하는 도구(오차막대)”와  
  “보기는 화려하지만 왜곡이 큰 도구(3D 차트)”의 철학이 충돌**한다.
- 엑셀은 기능적으로도, 철학적으로도 3D 차트에 오차막대를 지원하지 않는다.

---

# 📌 6. 시트 보호와 시트 이름 변경

## 6-1. 시트 보호(Protect Sheet)가 담당하는 범위

- 시트 내부에 대한 보호:
  - 셀 편집, 셀 서식, 행/열 삽입·삭제, 정렬, 필터 등
- 즉 **“시트 안의 내용물”** 을 제어하는 기능이다.

## 6-2. 시트 이름 바꾸기가 시트 보호 옵션에 없는 이유

- 시트 이름 변경, 시트 추가/삭제/이동/숨기기 등은
  - 워크북 구조(Workbook Structure)를 변경하는 작업이다.
- 이는 시트 내부 데이터가 아니라 **파일 전체 구조에 대한 작업**이므로
  - 시트 보호가 아니라 **워크북 보호(Protect Workbook)** 의 영역이다.
- 엑셀 보호 모델은 두 층으로 명확히 나뉜다:
  - **시트 보호**: 데이터 보호
  - **워크북 보호**: 구조 보호

---

# 📌 7. SUMPRODUCT / SUBTOTAL / 데이터표 / 목표값 찾기 / 부분합 위치

## 7-1. `=SUMPRODUCT((A1:A100=C1)*(B1:B100=D1))` 의미

1. `(A1:A100 = C1)`  
   - 조건 비교 결과: TRUE/FALSE 배열  
   - 내부적으로 TRUE→$1$, FALSE→$0$
2. `(B1:B100 = D1)`  
   - 마찬가지로 $1$/$0$ 배열 생성
3. 곱셈 `(조건1 * 조건2)`:
   - $1 \times 1 = 1$ → 두 조건 모두 참
   - 나머지는 $0$ → 하나라도 거짓
   - 즉, **AND 조건**을 벡터 곱으로 표현
4. `SUMPRODUCT(...)`:
   - 배열의 합 = 두 조건을 동시에 만족하는 행의 개수

→ **“A열이 C1이고 AND B열이 D1인 행의 개수”**를 구하는 수식이다.

## 7-2. SUBTOTAL 함수의 특징

- 구문: `SUBTOTAL(function_num, range)`
- 중요한 특징:
  1. **필터로 숨겨진 행을 포함할지/제외할지 선택 가능**
     - 9 : SUM (숨겨진 행 포함)
     - 109 : SUM (숨겨진 행 제외)
     - 1xx(100번대) → 숨김 제외 모드
  2. 다른 SUBTOTAL 결과 셀을 다시 합할 때 **중복 합산하지 않음**
     - 요약값을 여러 번 합쳐도 이중 계산 방지

- 설계 철학:
  - “필터 환경에서 사용자가 보고 있는 값만 요약하고 싶다”
  - 일반 SUM/AVERAGE는 필터를 모르기 때문에 이 한계를 보완하기 위해 만들어졌다.

## 7-3. 데이터표와 목표값 찾기의 쓰임새·차이

### 목표값 찾기(Goal Seek)
- 목적: **원하는 결과를 만들 입력값 하나를 역으로 찾기**
- 구조:
  - 결과 셀을 목표값으로 지정
  - 한 개의 입력 셀만 조정
- 예: 이익이 300만원이 되려면 “판매가격”을 얼마로 해야 하는가?

### 데이터표(Data Table)
- 목적: **입력값이 여러 값으로 바뀔 때 결과가 어떻게 변하는지 한 번에 보는 것**
- 1변수 또는 2변수 가능
- 민감도 분석, 시나리오 분석에 적합
- 예: 이자율을 1%~10%로 바꿔가며 월 납입액 변화를 표로 확인

### 차이 요약

- Goal Seek: **역산, 해 하나 찾기**
- Data Table: **여러 경우의 결과를 비교하는 표**

## 7-4. 부분합(Subtotal) 실행 결과에서 나중에 구한 함수가 위에 위치하는 이유

- 부분합 기능은:
  - 그룹화 + 요약값 삽입 + 아웃라인(접기/펼치기) 구조를 만든다.
- 엑셀은 기본적으로 **“요약을 그룹 위쪽에 표시”** 하도록 설계되어 있다.
  - 그룹을 접었을 때 헤더(요약)가 먼저 보여야 어떤 그룹인지 직관적으로 알 수 있기 때문.
- 두 번째, 세 번째 부분합을 추가할 때:
  - 새 부분합이 기존 부분합을 감싸는 **상위 그룹 요약**으로 추가된다.
  - 그래서 “나중에 만든 부분합이 위쪽 계층에 위치”하게 보인다.
- 옵션에서 “요약을 아래쪽에 표시”로 바꿀 수도 있지만, 기본 철학은  
  **“접으면 요약부터 보이게”** 이다.

---

# 📌 8. 윗주(위첨자)와 셀 이동(Enter / Shift+Enter / Ctrl+Enter)

## 8-1. 왜 데이터가 없는 셀에는 윗주를 적용할 수 없는가

- 윗주(위첨자, Superscript)는 **글꼴 서식(Font Formatting)** 이다.
- 서식은 항상 “어떤 문자 데이터 위에” 얹힌다.
  - 빈 셀은 문자/숫자가 없으므로 **서식을 적용할 대상 자체가 없다.**
- 따라서 **내용이 없는 셀에는 윗주/아랫주를 적용할 수 없다**는 구조가 자연스럽다.

## 8-2. 숫자가 입력된 셀에도 윗주는 표시된다

- 숫자 셀에 대해서도:
  - 수식 입력줄에서 특정 숫자만 드래그 → 서식 → 윗주 적용 → 화면에 정상적으로 위첨자로 표시된다.
- “숫자 셀에는 윗주가 표시되지 않는다”는 말은 현재 기준으로 **틀린 설명**이다.
- 다만:
  - 전체를 텍스트로 바꾸는 등 서식을 과하게 섞으면 숫자 취급이 안 되어 계산에 문제가 생길 수 있다.
  - 엑셀은 **값(숫자)와 서식(표현)을 분리**하려는 철학을 가지므로,  
    계산 가능성을 유지하려는 방향에서 동작한다.

## 8-3. 범위 선택 후 Enter, Shift+Enter, Ctrl+Enter 의 이동 규칙

### Enter

- 단일 셀 선택:
  - 값 입력 후 Enter → 아래로 이동
- 복수 범위 선택:
  - 범위 안에서 순서대로 이동
  - 마지막 셀까지 입력 후 다시 범위 첫 셀로 **순환 이동**

예: A1:C2 선택 시 순서  
$A1 \to B1 \to C1 \to A2 \to B2 \to C2 \to A1 \to \dots$

### Shift+Enter

- Enter의 반대 방향:
  - 위로 이동
  - 범위 선택 시에도 **역방향 순환**

### Ctrl+Enter

- 선택된 범위 전체에 **동일한 값/수식 한 번에 입력**
- 입력 후 **이동하지 않고 현재 선택 범위를 유지**한다.

---

# 📌 9. 찾기에서 `*`, `?`, `~` 와 Draft(간단하게 인쇄)

## 9-1. `*`, `?` 를 찾을 때 `~` 를 붙이는 이유

- 엑셀에서 `*`, `?` 는 **와일드카드(wildcard)** 이다.
  - `*` : 임의의 문자 0개 이상
  - `?` : 임의의 문자 1개
- 이들을 **문자 그대로** 찾고 싶을 때는 이스케이프가 필요하다.
- `~` 가 엑셀에서의 이스케이프 문자 역할:
  - `~*` : 별표 문자 자체를 검색
  - `~?` : 물음표 문자 자체 검색
  - `~~` : 틸드 문자 자체 검색

즉, `~` 는 “**뒤에 오는 문자를 특수문자로 보지 말고, 그냥 문자로 취급해라**”라는 의미이다.

## 9-2. 페이지 설정 → 시트 탭 → ‘간단하게 인쇄’ 옵션의 의미

- ‘간단하게 인쇄(Draft Quality)’ 는:
  - 프린터에 **저품질·고속 인쇄 모드**를 요청하는 옵션이다.
- 특징:
  - 텍스트 위주로 출력
  - 테두리, 색상, 채우기, 도형, 그림, 차트, 조건부 서식 등을 대부분 무시
- 목적:
  - 잉크 절약, 속도 향상, **내용만 빠르게 확인하는 임시 출력 용도**
- 그래서 “텍스트만 출력된다”는 식의 설명이 붙는다.

---

# 📌 10. `$` 가 워크시트 이름으로 가능한 이유 / IoT의 주체 / 레지스트리 편집 명령

## 10-1. `$`가 워크시트 이름으로 허용되는 이유

- 엑셀에서 시트 이름에 사용할 수 없는 특수문자:
  - `:`, `\`, `/`, `?`, `*`, `[`, `]`
- 이들은:
  - 파일 경로, 와일드카드, 범위 참조 등 내부 문법과 충돌하는 위험이 있어서 금지.
- `$` 는:
  - 윈도우 파일 시스템, 엑셀 수식 문법과 **직접적인 충돌이 없다.**
  - 셀 주소에서 $는 고정 참조(absolute reference)용이지만,  
    시트 이름은 `'Sheet$'!A1` 처럼 따옴표로 구분되므로 구분 가능하다.
- 따라서 설계상 금지할 필요가 없어 **허용**된다.

## 10-2. 사물인터넷(IoT)의 주체가 사람인 이유

- IoT의 목적:
  - 사물이 인터넷에 연결되는 것 자체가 목적이 아니라  
    **사람의 삶·행동·의사결정을 지원하기 위한 것**이다.
- 센서와 기기는 데이터를 모으고 자동으로 동작하지만:
  - 어떤 서비스를 쓸지 결정하는 주체
  - 데이터 활용·보안·윤리적 기준을 정하는 주체
  - 경제적·법적 책임을 지는 주체는 **사람**이다.
- 따라서 기술적 행위자는 “사물”일 수 있어도,  
  **사회적·철학적 주체는 사람**이므로  
  “사물인터넷의 주체는 사람”이라고 말한다.

## 10-3. 레지스트리 편집을 위한 명령

- GUI 기반 편집기:
  - 실행 창 또는 명령줄에서 `regedit`
- 명령줄 기반 조작:
  - `reg add`, `reg delete`, `reg query`, `reg import`, `reg export` 등
- 일반적으로:
  - 직접 편집: `regedit`
  - 스크립트/자동화: `reg` 명령 세트

---

# 📌 11. LPWA와 Nimda / Love / Melissa 및 “보기만 해도 실행” 이슈

## 11-1. LPWA(Low Power Wide Area)

- 의미: **저전력·광역 통신** 기술군
- 특징:
  - 매우 적은 전력으로 수 km~수십 km까지 데이터 전송
  - 속도는 낮지만, 배터리 수년 유지 + 장거리 커버리지
- 용도:
  - IoT 센서 네트워크 (온도, 습도, 계량기 등)
- 대표 기술:
  - LoRaWAN, Sigfox, NB-IoT, LTE-M 등

핵심 철학: **“작은 데이터, 먼 거리, 저전력”에 최적화된 IoT 통신**

## 11-2. Nimda / Love(ILOVEYOU) / Melissa: 어원과 특징

- **Nimda**
  - 어원: `"admin"` 을 뒤집은 것
  - 특징: 이메일, IIS 서버 취약점, 공유 폴더 등 **다중 전파 벡터**를 사용하는 웜
- **Love Letter (ILOVEYOU)**
  - 어원: 메일 제목 `"ILOVEYOU"`
  - 특징: 사용자의 감정을 노리는 **사회공학 공격** + VBS 스크립트
- **Melissa**
  - 어원: 제작자가 붙인 여성 이름(스트리퍼 이름 설 등)
  - 특징: Word 매크로 + Outlook 주소록 이용하는 매크로 웜

공통점:
- 사람 심리를 이용(호기심, 사랑, 신뢰)
- 이메일·문서·매크로 등 사용자가 평소 쓰는 길을 따라 침투

## 11-3. Nimda가 “메일을 보기만 해도 실행”된 이유

- 당시 Outlook은 메일을 **HTML 페이지처럼 렌더링**했고,
  - 내부적으로 Internet Explorer(IE) 엔진을 사용했다.
- IE의 **MIME 타입 처리 취약점** 때문에:
  - 메일 내용 표시(미리보기) 과정에서  
    HTML 안의 스크립트/코드가 **자동 실행**될 수 있었다.
- 즉,
  - 사용자가 첨부파일을 클릭하지 않아도
  - “메일을 보기만 해도” 악성 코드가 동작하는 상황이 발생했다.
- 이후:
  - Outlook/IE 렌더링 구조 개선
  - 스크립트 차단, 시스템 보안 강화  
  → 같은 방식의 공격은 현재 구조상 거의 불가능.

---

# 📌 12. 보수, 보수기, 가산기, 프로그램 카운터, 캐시, SVC와 인터럽트

## 12-1. 보수(Complement)의 개념

- 보수는 **뺄셈을 덧셈으로 바꾸기 위해 사용하는 수 표현 방식**이다.
- 대표:
  - 1의 보수: 모든 비트 반전
  - 2의 보수: 1의 보수 + $1$
- 컴퓨터가 음수를 2의 보수로 쓰는 이유:
  - 덧셈기만으로 뺄셈 처리 가능
  - $+0$ 과 $-0$ 이 따로 존재하지 않게 됨
  - 오버플로 검사가 단순해짐

## 12-2. 보수기(Complementer)와 가산기(Adder)

- **보수기**:
  - 주어진 이진수를 보수 형태로 바꾸는 회로
  - 예: 비트 반전 + 1 더하기
- **가산기(Adder)**:
  - 이진수 덧셈 수행 회로
  - Half Adder: 자리 하나 덧셈 (Carry 입력 없음)
  - Full Adder: Carry 입력 포함 → 여러 개 연결하여 다비트 덧셈 처리
- ALU에서:
  - 가산기 + 보수기 조합으로 **뺄셈까지 모두 처리**한다.

## 12-3. 프로그램 카운터(PC, Program Counter)

- **다음에 실행할 명령어의 주소**를 저장하는 레지스터.
- 기본 실행 흐름:
  1. PC에 있는 주소의 명령어를 가져온다.
  2. 실행한다.
  3. PC를 다음 명령 주소로 갱신한다.
- 분기/점프 명령이 PC를 새로운 주소로 바꾸면서 프로그램 흐름이 변경된다.
- 한마디로: **프로그램의 시간 흐름을 정의하는 핵심 레지스터.**

## 12-4. 캐시 메모리가 휘발성인 이유

- 캐시 메모리는 보통 **SRAM**으로 구현된다.
- SRAM은:
  - 속도는 매우 빠르지만
  - 전원이 끊어지면 저장된 상태를 유지할 수 없다.
- 이유:
  - 플립플롭 기반 회로 구조가 **지속적인 전원 공급**을 전제로 동작
- CPU 클록에 맞추려면 DRAM보다 빠른 SRAM을 써야 하고,
  - 그 대가로 **휘발성(Volatile)** 을 감수하는 구조이다.

## 12-5. SVC 명령(Supervisor Call)과 소프트웨어 인터럽트

- SVC:
  - 운영체제 커널에게 **서비스를 요청하는 명령**
  - 시스템 콜(System Call) 개념과 동일.
- 역할:
  - 사용자 프로그램이 입출력, 프로세스 제어, 메모리 요청 등  
    **특권 작업이 필요할 때 커널 모드로 전환** 요청.
- 동작:
  1. 사용자 프로그램이 SVC 실행
  2. CPU가 **소프트웨어 인터럽트** 발생 상태로 전환
  3. 인터럽트 벡터를 통해 OS 커널의 서비스 루틴으로 점프
  4. 서비스 수행 후, 다시 사용자 프로그램으로 복귀

따라서 **SVC 실행 후 인터럽트가 발생하는 것은 설계된 정상 동작**이며,  
SVC 자체가 “소프트웨어 인터럽트 트리거”라고 보면 된다.

---

# 📌 13. OLED: 백라이트, 두께, 휘어짐, 저전력·고휘도

## 13-1. “백라이트가 없으므로 얇고, 그래서 휘어진다”가 왜 틀린 설명인가

- OLED는 백라이트가 없으므로 LCD보다 구조가 단순하고 **얇게 만들 수 있는 것**은 맞다.
- 그러나:
  - 얇다고 해서 자동으로 “휘어지는” 것은 아니다.
  - 유리 기판이면 아무리 얇아도 **부러질 뿐**이다.
- 플렉시블 OLED에서 휘어짐을 가능하게 하는 것은:
  1. **유연한 기판(PI, Polyimide 플라스틱)** 사용
  2. **유연한 봉지막(Encapsulation, TFE)** 기술
  3. 휘어져도 회로가 끊어지지 않는 **TFT 설계**
- 즉,
  - “백라이트 없음 → 얇다” 는 맞지만
  - “얇다 → 휘어진다”는 잘못된 인과관계이다.
- 휘어짐의 진짜 원인은 **재료의 물성(기판·봉지·회로 구조)** 이다.

## 13-2. “저전력으로 높은 휘도”의 의미

- OLED는 **자발광(Self-emissive)** 소자:
  - 각 픽셀이 직접 빛을 낸다.
  - 필요한 픽셀만 켜고, 필요 없으면 완전 OFF.
- LCD는:
  - 항상 백라이트 전체를 켜고
  - 액정이 그 빛을 막거나 통과시키는 구조 → 손실이 큼.
- “저전력으로 높은 휘도”의 의미:
  1. 전류 대비 광출력(전기 → 빛 변환 효율)이 높다.
  2. 백라이트를 통과하는 여러 층에서 생기는 손실이 없다.
  3. 어두운 화면에서는 픽셀을 끄기 때문에 소비 전력이 극도로 낮아진다.
- 단, 완전 흰색 화면(풀화이트)에서는 많은 픽셀이 동시에 켜지므로  
  전력 소모가 증가할 수 있다.
- 그래도 구조적으로:
  - **필요할 때만 켜는 자발광 구조 → 같은 휘도 기준에서 에너지 효율이 좋다**는 의미다.

---

# 📌 14. 연결형 바이러스(Companion Virus)

## 14-1. 정의

- 연결형 바이러스 = **정상 프로그램을 직접 감염·변조하지 않고,  
  같은 이름의 다른 실행 파일을 만들어 먼저 실행되도록 하는 악성코드**.
- 운영체제의 “실행 파일 우선순위 규칙”을 악용한다.

## 14-2. 동작 원리

- 예:
  - 원래 정상 프로그램: `APP.EXE`
  - 바이러스가 생성: `APP.COM`
- DOS/초기 Windows에서는:
  - 이름이 같을 때 `.COM` → `.EXE` 순으로 실행
- 사용자가 `APP` 을 실행하면:
  1. 먼저 `APP.COM` (바이러스)이 실행된다.
  2. 이후 정상 `APP.EXE` 를 호출하여 사용자는 이상을 못 느낄 수 있다.
- 원본 파일을 건드리지 않고 **옆에서 동반(companion) 실행**되므로  
  “연결형/동반 바이러스”라고 부른다.

## 14-3. 특징과 현재 상황

- 장점(공격자 입장):
  - 원본 파일 변경이 없으므로 탐지 어렵다.
  - 실행 흐름을 자연스럽게 가로챌 수 있다.
- 현대 Windows에서는:
  - 실행 우선순위/보안 모델 변경
  - 확장자 숨김 방지, 디지털 서명 검증, 실시간 백신 등으로
  - 이 방식이 통하기 어려운 환경이 되었다.

---

# 📌 15. 엑세스 모달 폼(Modal Form)

## 15-1. 모달 폼의 의미

- **모달(Modal)** 의 어원: 라틴어 *modus* (방식, 양식) →  
  UI 세계에서는 **“사용자의 흐름을 한 지점에 묶는 창”** 이라는 의미로 발전.
- 엑세스에서 **모달 폼**은  
  해당 폼이 열려 있는 동안 **다른 폼·개체로 포커스를 이동할 수 없도록 하는 동작 속성**이다.
- 즉, 폼 자체를 만드는 기술이 아니라  
  **“그 폼이 어떻게 사용자 입력을 강제할 것인지”를 결정하는 동작(Behavior) 속성**이다.

## 15-2. 모달 속성의 위치와 의미

- 폼 디자인 보기 → 속성 시트 → **Modal**: `예/아니오`
- `예`로 설정 시:
  - 그 폼이 닫히기 전까지 다른 폼과 상호작용 불가
  - 사용자는 해당 폼에서 요구하는 작업을 반드시 처리해야 함
- 설계 의도:
  - 중요한 확인/입력(경고, 인증, 필수정보 입력 등)을 **반드시 처리하게 만들기 위한 강제 장치**


# 📌 16. 텍스트 상자 이름 변경 & 조회 마법사

## 16-1. 텍스트 상자 컨트롤 이름 변경의 의미

- 폼 위의 **텍스트 상자(Text Box)** 는 하나의 **컨트롤 객체**이다.
- 기본 생성 시 이름 예:
  - `Text0`, `Text12` 등 의미 없는 자동 이름
- “텍스트 상자 컨트롤의 이름을 변경한다”  
  → **VBA나 매크로에서 다루기 쉬운 의미 있는 이름으로 바꾼다** 는 뜻.

### 16-1-1. 이름 변경 방법

1. 폼을 **디자인 보기**로 연다.
2. 텍스트 상자를 클릭.
3. 오른쪽 **속성 시트**에서 **이름(Name)** 속성 변경.
   - 예: `Text12` → `txtCustomerName`
4. 이후 VBA에서:
   - `Me.txtCustomerName = "홍길동"` 처럼 명확하게 참조 가능.

- 설계 철학:
  - “화면 요소에 의미 있는 이름을 부여해 코드 가독성과 유지보수성을 높인다.”


## 16-2. 조회 마법사(Lookup Wizard)의 의미

- 조회 마법사는 **테이블의 특정 필드가 값을 입력받는 방식**을 바꿔 주는 기능.
- 핵심 정의:
  - **필드에 값을 직접 타이핑하는 대신, 다른 테이블/쿼리의 값 목록에서 선택하도록 만드는 기능**.

### 16-2-1. 예시 상황

- `부서(Dept)` 테이블:
  - `DeptID`, `DeptName`
- `직원(Employee)` 테이블:
  - `EmployeeID`, `EmployeeName`, `DeptID`

→ `Employee.DeptID` 필드에 **조회 마법사**를 설정하면:
- 사용자는 폼에서 `영업부`, `총무부`, `인사부` 같은 **문자 목록을 선택**.
- 실제 테이블에 저장되는 값은 내부 키인 `DeptID`(예: 1, 2, 3).

### 16-2-2. 조회 마법사 사용 방법

1. 테이블 **디자인 보기**에서 필드 선택.
2. 데이터 형식에서 **조회 마법사** 선택.
3. “다른 테이블 또는 쿼리에서 값 가져오기” 선택.
4. 표시할 필드를 선택하고, 정렬·표시 형식 지정.
5. 완료하면 해당 필드는 폼·데이터시트에서 **콤보 상자처럼 동작**.

- 설계 의도:
  - 오타·중복·표기 차이 등을 줄여 **데이터 무결성**을 지키기 위한 입력 레이어.


# 📌 17. FREQUENCY 함수와 날짜 자동 채우기(주 단위 없음)

## 17-1. FREQUENCY 함수의 구조

- 형식:  
  $$
  \text{FREQUENCY}(\text{data\_array},\ \text{bins\_array})
  $$
- 역할: **데이터를 구간별로 나누어 각 구간에 속하는 데이터 개수(빈도)를 계산**.

### 17-1-1. 인수 1: data_array

- 의미: **실제 측정된 데이터 값들의 집합**.
- 예: 시험 점수, 나이, 판매량 등.
- 철학적 의미:
  - “세상을 있는 그대로 측정한 관측값 집합.”

### 17-1-2. 인수 2: bins_array

- 의미: **각 구간의 상한값을 모아둔 배열**.
- 예:  
  - 점수 구간 상한: $\{59, 69, 79, 89\}$
- 구간 해석:
  - $59$ 이하
  - $60 \sim 69$
  - $70 \sim 79$
  - $80 \sim 89$
  - $90$ 이상 (마지막 구간은 자동 생성)
- 철학:
  - 사람이 **분류 기준(경계)** 를 정하면,  
    기계는 그 기준에 따라 빈도를 자동 집계한다.

### 17-1-3. 반환 결과

- 결과는 **배열**로, `bins_array`의 길이 + 1 개의 구간 빈도.
- 각 원소는 “해당 구간에 속하는 data_array 값의 개수”.


## 17-2. 날짜 자동 채우기에 주 단위(Week)가 없는 이유

- 엑셀은 날짜를 **시리얼 번호(정수)** 로 관리:
  - 예: 특정 날짜 = 1900-01-01 기준 $n$일째
- 자동 채우기 설계의 기본 단위:
  - **일(day)**, **월(month)**, **연(year)** 등 **전 세계적으로 규칙이 비교적 표준화된 주기**.

### 17-2-1. 주(week)의 애매함

- 한 주는 $7$일이지만:
  - 월을 가로질러 넘어감.
  - 연도를 넘어갈 수 있음.
  - 국가/문화마다 **주 시작 요일** 다름:
    - 어떤 곳은 일요일, 어떤 곳은 월요일.
- 엑셀 입장:
  - “주 단위를 자동 옵션으로 정해두면, 어느 기준을 따라야 하는가?”라는 문제가 발생.

### 17-2-2. 설계 선택

- 월/연 단위는 모두에게 비교적 공통된 개념이라 자동 옵션에 포함.
- 주 단위는 문화·규칙 차이가 커서 **자동 옵션에서 제외**.
- 대신:
  - 사용자가 직접 날짜 + 7을 하거나,
  - 함수(WEEKNUM, WORKDAY 등)를 통해 주 단위를 구현.

- 설계 철학:
  - “가장 널리 합의된 자연 주기(일, 월, 년)만 기본 제공하되,  
    그 외 주기는 함수와 수식으로 사용자가 명시적으로 표현하게 한다.”


# 📌 18. 메모 인쇄 옵션과 ‘시트 끝에 인쇄’

## 18-1. 메모 인쇄 기본 동작

- 엑셀에서 **메모/주석**은 기본적으로 **인쇄되지 않는다.**
- 이유:
  - 메모는 **데이터 보조 정보**로 취급.
  - 기본 인쇄물은 **셀 값 중심**의 보고서이며, 메모는 선택적이다.

## 18-2. 메모 인쇄 옵션

- [페이지 설정] → [시트] 탭 → **메모 인쇄** 옵션:
  1. 인쇄 안 함 (기본값)
  2. 화면에 표시된 대로 인쇄
  3. **시트 끝에 인쇄**

### 18-2-1. “시트 끝에 인쇄”의 의미

- 모든 메모를 **마지막 페이지에 모아서 목록 형태로 인쇄**.
- 데이터와 설명/주석을 분리해서 보고 싶은 경우에 사용.

- 정리:
  - 별도 선택을 하지 않으면 **메모는 기본적으로 인쇄되지 않는다**.


# 📌 19. 차트 축 옵션: 가로축 교차(최대값) vs 값 거꾸로

## 19-1. 가로축 교차를 ‘축의 최대값’에서

- 의미:
  - **세로축(y축)이 가로축(x축)과 만나는 위치**를 결정하는 옵션.
- 기본값:
  - y축이 **x축의 최소값 쪽(보통 왼쪽)** 에서 교차.
- “축의 최대값에서 교차” 선택 시:
  - y축이 **x축 오른쪽 끝으로 이동**.

- 핵심:
  - **축의 교차 위치만 바뀔 뿐, 데이터의 진행 방향은 변하지 않는다.**

## 19-2. ‘값을 거꾸로’ 옵션

- 의미:
  - 축의 **값 나열 순서를 반대로 뒤집는 옵션**.
- 예:
  - 원래: $1, 2, 3, 4, 5$
  - 거꾸로: $5, 4, 3, 2, 1$
- 결과:
  - 데이터의 시각적 진행 방향이 좌→우에서 우→좌로 바뀌는 효과.

## 19-3. 두 옵션의 차이 정리

| 옵션 | 바꾸는 대상 | 축 위치 변경 | 값(진행 방향) 변경 |
|------|-------------|-------------|--------------------|
| 가로축 교차(최대값) | y축이 x축 어디에서 만나는지 | O | X |
| 값 거꾸로 | 축 위의 값 배치 순서 | X | O |

- 핵심:
  - **축의 “위치”를 바꾸는 것** vs **축의 “방향”을 바꾸는 것**.


# 📌 20. 인쇄 미리보기에서 행 높이 vs 열 너비

## 20-1. 인쇄 미리보기와 편집 모드 분리

- 엑셀은 **편집 레이아웃(시트)** 과 **인쇄 레이아웃(프린트 렌더링)** 을 분리 설계.
- 일반 원칙:
  - 편집 관련 작업(행 높이, 셀 병합 등)은 시트에서 수행.
  - 인쇄 미리보기는 **결과 확인용**.

## 20-2. 열 너비 변경은 가능한 이유

- **열 너비**는 페이지의 **가로 폭**과 직접 연결:
  - 한 페이지에 몇 열이 들어가는지
  - 수직 페이지 나누기 위치
- 인쇄 미리보기에서 열 너비를 바꿔도:
  - 수평 레이아웃만 재계산하면 되므로, 구조적 부담이 상대적으로 적다.
- 그래서 인쇄 미리보기에서도 **열 너비 조정 허용**.

## 20-3. 행 높이 변경은 불가능한 이유

- **행 높이 변경은 수직 구조 전체에 영향**:
  - 각 페이지에 들어가는 행 수
  - 수평 페이지 나누기 위치
  - 머리글/바닥글 위치, 스케일링 등 재계산 필요
- 인쇄 미리보기에서 행 높이를 허용하면:
  - 인쇄 렌더링과 편집 구조가 복잡하게 엮여 성능·일관성 문제 발생.
- 그래서:
  - **행 높이 조정은 시트 편집 모드에서만 허용**,  
  - 인쇄 미리보기에서는 불가.

- 정리:
  - 열 너비: **출력 폭 조정** → 인쇄에서 허용.
  - 행 높이: **시트 구조 조정** → 편집 화면에서만 허용.


# 📌 21. 채우기 핸들 더블클릭과 자동 채우기

## 21-1. 수식 셀의 채우기 핸들 더블클릭 동작

- 정의:
  - 수식이 들어 있는 셀의 오른쪽 아래 모서리(채우기 핸들)를 더블클릭 시:
    - **상대참조 규칙을 유지한 채, 인접 열의 데이터가 있는 범위까지만 수식을 자동 채움.**
- 동작 원리:
  1. 현재 셀의 수식을 복사.
  2. 바로 왼쪽(또는 오른쪽)에 있는 열의 **데이터가 끊기는 지점까지** 아래로 확장.
  3. 이때 수식 안의 상대참조는 각 행에 맞게 자동 변경.

### 21-1-1. 특징

- “아래 빈칸을 끝까지 전부 다 채우는” 기능이 아니다.
- 기준이 되는 인접 열이 비어 있으면 더블클릭해도 아무 일도 안 일어날 수 있다.
- 빈칸까지 강제로 끝까지 채우고 싶으면:
  - 더블클릭이 아니라 **마우스로 드래그** 해야 한다.

## 21-2. 상대/절대 참조와의 관계

- 수식 예: `=$A$1 * B2`
  - 더블클릭 시:
    - `$A$1` 은 그대로 유지(절대참조).
    - `B2` 는 `B3`, `B4`, …로 행 번호만 변경(상대참조).


# 📌 22. 상대참조의 본질: 위치 기반(오프셋 기반)

## 22-1. 상대참조는 “주소”가 아니라 “거리”를 기억

- 예: 셀에 `=B2` 라는 수식이 있을 때,
  - 엑셀 내부 표현:
    - “현재 셀에서 **오른쪽으로 1칸, 위/아래로 0칸** 떨어진 셀”
- 이 수식을 한 칸 아래로 복사하면:
  - 현재 위치: A3
  - 규칙: 오른쪽으로 1칸
  - 결과: `=B3`

→ 주소는 바뀌지만 **상대적 위치(오프셋)** 는 그대로 유지.

## 22-2. 위치 기반의 증명 예시

- 원래: C5에 `=A1`
- 이걸 D6으로 복사했다고 하자.
- C5에서 A1까지의 오프셋:
  - 열: $A \to C$ 이므로 $+2$  
  - 행: $1 \to 5$ 이므로 $+4$
- 이 규칙을 D6에도 적용:
  - D6에서 왼쪽으로 2칸, 위로 4칸 → B2
- 실제로 수식은 `=B2` 가 됨.

→ 상대참조는 **“벡터(오프셋)”** 로 저장된다고 볼 수 있다.

## 22-3. 절대/혼합 참조와의 대비

- 절대참조: `$A$1`
  - **주소 자체를 고정**.
  - 위치 이동 시에도 변하지 않음.
- 혼합참조:
  - `$A1`: 열 고정, 행은 위치 기반.
  - `A$1`: 행 고정, 열은 위치 기반.

- 정리:
  - 상대참조: 위치(오프셋) 기반
  - 절대참조: 절대 좌표 기반
  - 혼합참조: 둘의 결합


# 📌 23. 2진수 1010의 보수

## 23-1. 1의 보수(One’s Complement)

- 정의:
  - **모든 비트를 반전(0 ↔ 1)하는 것.**
- 예: $1010$ 의 1의 보수
  - $1 \to 0$
  - $0 \to 1$
  - $1 \to 0$
  - $0 \to 1$
  - 결과: $0101$

→ **$1010$ 의 1의 보수 = $0101$**

## 23-2. 2의 보수(Two’s Complement)

- 정의:
  - **1의 보수를 취한 뒤, 그 값에 1을 더한 것.**
- 공식:
  - $2\text{의 보수} = (\text{1의 보수}) + 1$
- 예: $1010$ 의 2의 보수
  1. 1의 보수: $0101$
  2. $0101 + 0001 = 0110$
- 결과:
  - **$1010$ 의 2의 보수 = $0110$ (4비트 기준)**

- 설계 의도:
  - 음수 처리를 위해 뺄셈을 **덧셈 + 보수**로 통일해  
    하드웨어 연산 회로를 단순하게 만들기 위함.


# 📌 24. 즐겨찾기 아이콘과 바탕화면 아이콘 설정

## 24-1. 바탕화면 아이콘 설정이 다루는 대상

- Windows의 **“바탕화면 아이콘 설정”** 은 **특정 시스템 아이콘만** 대상으로 한다:
  - 내 PC
  - 휴지통
  - 네트워크
  - 제어판
  - 사용자 폴더 등
- 이들은 OS 내부에서 **특수한 Shell 객체**로 취급되며  
  전용 설정 메뉴에서 아이콘 변경이 허용된다.

## 24-2. 즐겨찾기(Favorites) 아이콘이 대상이 아닌 이유

- 즐겨찾기 폴더는:
  - 단순한 **사용자 폴더**일 뿐,
  - Windows가 특별 취급하는 “시스템 아이콘”이 아님.
- 따라서:
  - **바탕화면 아이콘 설정 목록에 나오지 않음**.
  - 아이콘 변경은 일반 폴더와 동일하게:
    - 폴더 우클릭 → 속성 → 사용자 지정 → 아이콘 변경  
      방식으로만 가능.

- 정리:
  - 바탕화면 아이콘 설정은 **특수 시스템 아이콘만 관리**.
  - 즐겨찾기는 그 범주가 아니라 일반 폴더 취급이라서 **설정 대상에 포함되지 않는다.**


# 📌 25. 니블·바이트·워드·레코드의 정보량 & PnP

## 25-1. 비트 단위별 표현 가능 상태 수

### 25-1-1. 기본 공식

- 비트 수가 $n$일 때 표현 가능한 상태 개수:
  - $2^n$

### 25-1-2. 니블(Nibble)

- 크기: $4$비트
- 표현 가능 정보 수: $2^4 = 16$ 가지
- 예: 한 자리 16진수 ($0 \sim F$)

### 25-1-3. 바이트(Byte)

- 크기: $8$비트
- 표현 가능 정보 수: $2^8 = 256$ 가지
- 예: 아스키 문자 하나, $0 \sim 255$ 범위 정수 등

### 25-1-4. 워드(Word)

- 의미: **CPU가 한 번에 처리하는 기본 비트 폭**.
- 전통적 기준:
  - 16비트 워드: $2^16 = 65{,}536$ 가지
- 아키텍처에 따라:
  - 32비트 워드: $2^{32}$ 가지
  - 64비트 워드: $2^{64}$ 가지
- 설계 철학:
  - 워드 크기가 클수록 한 번에 처리할 수 있는 수의 범위와 주소 공간이 커진다.

### 25-1-5. 레코드(Record)

- 정의:
  - 여러 필드(이름, 나이, 주소, …)를 하나로 묶은 **논리적 데이터 단위**.
- 특징:
  - 고정된 비트 길이 개념이 아님.
  - 각 필드 길이와 타입에 따라 **전체 표현 가능한 상태 수가 달라진다.**
- 예:
  - 학생 레코드:
    - 이름 20바이트 + 나이 1바이트 + 성별 1바이트 + 학번 4바이트 등.
- 결론:
  - 레코드는 “저장 구조의 묶음”이지 **단일 비트 단위로 상태 수를 특정할 수 있는 개념이 아니다.**


## 25-2. PnP (Plug and Play)

### 25-2-1. 정의

- **Plug and Play**:
  - “장치를 꽂으면(Plug) 즉시 사용할 수 있게(Play) 하는 자동 구성 기술.”
- 예:
  - USB 마우스, 키보드, 프린터 등을 꽂으면 즉시 인식되는 것.

### 25-2-2. 등장 배경

- 과거:
  - 장치 연결 시:
    - IRQ, I/O 주소, DMA 채널 수동 설정
    - 드라이버 일일이 설치
    - 자원 충돌(Conflict) 잦음
- PnP 이후:
  - OS가 장치 ID를 읽고:
    - 적절한 드라이버 자동 로드
    - 시스템 자원(IRQ, 메모리 주소 등) 자동 할당
    - 사용자는 “연결”만 하면 바로 사용 가능.

- 설계 의도:
  - **하드웨어 사용의 진입 장벽을 낮추고,  
    일반 사용자도 복잡한 하드웨어 설정 없이 장치를 활용할 수 있도록 하기 위함.**
