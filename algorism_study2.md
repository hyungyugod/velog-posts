# 재귀
## 1. 재귀(recursion)
- 재귀는 함수가 자기 자신을 다시 호출하는 것을 의미한다.
- 상자 속에 상자가 있는 여러 상자들 중 키를 찾는 과정은 재귀가 간편하다. 아래는 이이를 표현한 의사코드이다.
```python
def look_for_key(box):
    for item in box:                # 모든 박스를 조사
        if item.is_a_box():
            look_for_key(item)      # 첫번째 함수로 조사하던 박스에서 다른 박스가 나오면 그 박스에 대해 이 함수를 사용  
                                    # -> 이런 예외 상황에  while 문이나 for문을 여러번 쓰면서 가면 복잡함. 
        elif item.is_a_key():
            print("열쇠를 찾았어요")
```
## 2. 기본 단계와 재귀단계
- 재귀 함수가 언제 끝날지 정해주기 위해 기본단계와 재귀단계의 두가지 단계가 있다.
- 기본단계: 재귀 호출이 끝나는 기본적인 종료조건
- 재귀단계: 지속적으로 함수를 호출하여 반복하는 단계
```python
def factorial(n):
    if n == 1:  # 기본 단계(Base Case): 종료 조건
        return 1
    return n * factorial(n - 1)  # 재귀 단계(Recursive Case)
```

## 3. 스택
- 스택: 여러 메모지를 쌓아 올려둔 것 같은 형태로 위에서 push나 pop만 할 수 있다.
- 즉 한쪽 끝에서만 삽입, 제거가 가능하다.

### 3-1. 호출스택
- 함수들의 흐름을 스택처럼 관리함.
- LIFO (후입선출) 형식으로 제일 나중에 실행된 함수가 먼저 종료되고 마지막에 실행한 순으로 돌아가면서 함수가 종료됨.
- 함수 안에서 차례로 여러 함수를 호출했을 때 마지막게 해결돼야 다른 것들도 해결되므로 재귀함수에서도 호출스택을 사용.
```python
def factorial(n):  # n이 5일때
    if n == 1:  
        return 1
    return n * factorial(n - 1)  # f(4) - f(3) - f(2) -f(1) 까지 가서 기본조건에 의해 f(1)이 종료되면 역순으로로 다른 값들도 하나씩 결정되기 시작함.
```
- 호출 스택은 내가 상자를 널부러뜨리고 일일히 확인하지 않아도 정해진 대로 쌓아두고 보면 되므로 편하다.
- 하지만 다 쌓아놔야 하므로 한번에 메모리를 많이 잡아먹는다.

# 퀵 정렬
## 1. 분할정복 (Divide and Conquer)
- 가장 유명한 재귀적 기술(재귀를 활용하여 많이 구현함.)
- 먼저 큰 문제를 작은 문제들로 분할하고 이를 각각 좀 더 쉽게 해결하여 나중에 합치는 방법임.
- 정사각형 토지를 나누는 방법: 기본 단계 (한 변이 다른 변의 배수- 딱 몇개로 자르면 끝) - 재귀단계(현재 해결할 수 있는 가장 큰 기본모양을 찾고 나머지에 대해 다시 이 함수를 적용해 나감.)
- 위 문제는 단순한 재귀 호출이 아니라, 문제를 점점 작은 문제로 "나누면서 해결"하는 분할 정복의 구조를 갖고 있음.

## 2. 퀵정렬 (quicksort)
- 분할정복 전략 중 많이 쓰이는 것
- 문제의 기준을 정하고 기준을 기준으로 하위 배열들을 만듬 -> 이 과정을 기본단계까지 수행 후 차근차근 반복해감.
```python
def quicksort(array):
    if len(array < 2):   # 기본 상태: 정렬할 필요가 없음. 빈리스트이거나 원소가 한개인 경우.
        return array
    else:
        pivot = array[0]  # 기준점 설정정
        less = [i for i in array[1:] if i <= pivot] # 기준점 보다 작은 수들을 모음

        greater = [i for i in array[1:] if i > pivot] # 기준점 보다 큰 수들을 모음

        return quicksort(less) + [pivot] + quicksort(greater) # 이렇게 모은 수들에 이 함수를 다시 적용
```
- 퀵정렬은 기본적으로 O(n logn): 이진탐색처럼 나눠도(log n) 이들을 각각 다 비교해야하므로(n) n * logn이다.
- 퀵정렬은 병합정렬보다 작은 상수곱을 가져 더 빠르다. (pivot을 끝자리에 선택하는 최악의 경우가 아닌 경우)
- 병합 정렬은 추가적인 메모리 공간 O(n)이 필요함 (새로운 배열을 만들면서(나누면 새로운 배열 생성) 병합하기 때문).
- 퀵 정렬은 대부분의 경우 추가 메모리 없이 제자리 정렬(In-Place Sort)(그 자리에서 바로바로 바꿈)이 가능함.