# 📌 0. c코딩 테스트
### 📌 0-1. 배열 만들기 4
- 처음에 넉넉하게 최대크기로 배열을 만들어두고 논리적 배열인덱스인 count로 크기를 조절하다가 마지막에 count까지 배열 사이즈를 줄여버리기
```c
int* solution(int arr[], size_t arr_len) {
    int * answer = malloc(arr_len * sizeof(int));
    int i = 0;
    int count = 0;

    while (i < arr_len) {
        while (count > 0 && answer[count - 1] >= arr[i]) {
            count--;
        }

        answer[count++] = arr[i++];
    }

    answer = realloc(answer, count * sizeof(int));

    return answer;
}
```

### 📌 0-2. 배열 만들기 1
- 1부터 n까지 k의 배수는 n/k개 들어간다.
- malloc는 무조건 바이트 단위로 넣어주어야한다.
- 새로운 배열에서 삽입 위치를 계속 찍어주는 포인터가 필요하다.
- answer는 &answer[0]와 같고, answer[n]은 answer 주소에서 n * sizeof(요소타입) 바이트 떨어진 위치의 값을 의미한다.
```c
int* solution(int n, int k) {
    int count = n / k;
    int* answer = malloc(count * sizeof(int));
    int j = 0;
    for (int i = k; i < n + 1; i += k) {
        answer[j] = i;
        j++;
    }
    return answer;
}
```

### 📌 0-3. 접미사 배열
- 널 종단 덕분에 시작주소 하나만 있으면 문자열 길이/끝 위치를 따로 저장할 필요가 없다.
- 포인터 배열에 시작주소만 모아서 리턴해도, 그걸 %s로 출력하면 문자열로 나온다. -> 프로그래머스가 이런식
- 단, 원본문자열의 메모리가 살아있는 동안만 유효하다.
- answer는 malloc이 만든 배열의 첫 원소를 가리키는 포인터.
- *answer는 "포인터가 가리키는 대상의 타입".
- 런타임에 *answer 하면 "answer가 가리키는 메모리 안에 저장된 값"이 나온다. 하지만 컴파일러 입장에서 *answer를 보면 **"이 표현식의 타입은 char*"**임을 바로 알 수 있다.
- answer[i] = &my_string[i]; 과 answer[i] = mystring++는 답에서 처리는 같으나 my_string++는 원본 포인터 자체를 변경하므로 이후에 문자열 시작점에 접근이 불가하다.
- sizeof 연산자의 결과 타입이 size_t.
- size_t: 메모리 크기나 객체의 크기를 나타내는 부호 없는 정수 타입.
- 인덱스와 문자열 길이는 음수가 될 수 없음 → 부호 없는 타입 사용, 표준 함수(strlen, malloc)가 반환하는 타입과 맞춰서 형 변환 경고를 없앰.
- strcmp가 사전순 비교처럼 동작하는 이유는,
내부적으로 문자열을 아스키 코드 값을 기준으로 왼쪽에서 오른쪽으로 한 글자씩 비교하기 때문이다.
- 버블 정렬이 이렇게 도는 이유: 매 회전(j가 1씩 증가)할 때마다 제일 큰 원소가 뒤로 "거품처럼" 올라가서,
뒤쪽 j개 원소는 이미 정렬된 상태이므로 len - 1 - j까지만 비교하면 충분하다.
- 아래는 문자열을 직접 복사하는 버전으로 진짜 문자열을 채워서 배열을 반환한다.
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char** solution_copy(const char* my_string, size_t* out_len) {
    size_t len = strlen(my_string);
    char** answer = malloc(len * sizeof(*answer));
    if (!answer) return NULL;

    // 접미사 복사
    for (size_t i = 0; i < len; i++) {
        answer[i] = strdup(my_string + i); // strdup: 문자열 복사
    }

    // 버블 정렬
    for (size_t j = 0; j < len - 1; j++) {
        for (size_t n = 0; n < len - 1 - j; n++) {
            if (strcmp(answer[n], answer[n + 1]) > 0) {
                char* temp = answer[n];
                answer[n] = answer[n + 1];
                answer[n + 1] = temp;
            }
        }
    }

    if (out_len) *out_len = len;
    return answer;
}
```
- 아래는 접미사의 시작 주소만 모은 배열의 리턴하는 코드이다.
```c
const char** solution(const char* my_string) {
    size_t len = strlen(my_string);

    const char** answer = malloc((len) * sizeof *answer); // 접미사 len개

    for (size_t i = 0; i < len; i++) {
        answer[i] = &my_string[i];             // 시작 주소만 저장
    }

    const char* tmp;
    for (size_t i = 0; i < len - 1; i++) {
        for (size_t j = 0; j < len - 1 - i; j++) {
            if (strcmp(answer[j], answer[j + 1]) > 0) {
                tmp = answer[j];
                answer[j] = answer[j + 1];
                answer[j + 1] = tmp;
            }
        }
    }
    return answer;
}
```


