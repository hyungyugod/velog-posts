
# 📌 1. 엔터티 분류와 명명 규칙

## 1-1. 발생 시점에 따른 엔터티 분류

발생 시점 기준 엔터티는 **언제 생기고 언제 사라지는지**를 기준으로 나눈다.

- **기본/키 엔터티(Fundamental/Key Entity)**  
  - 다른 엔터티에 의존하지 않고 **독립적으로 먼저 발생**하는 엔터티.  
  - 예: 회원, 상품, 학생, 과목 등.
- **중심 엔터티(Main Entity)**  
  - 기본 엔터티들 간의 관계에서 파생되는, 업무의 **중심이 되는 엔터티**.  
  - 예: 주문(고객–상품), 수강(학생–과목) 등.
- **행위 엔터티(Active Entity)**  
  - 시간의 흐름에 따라 **상태가 계속 변하는 행위·이력 정보**를 담는 엔터티.  
  - 예: 주문 상태 이력, 로그인 로그, 배송 이력 등.

→ 이 세 가지가 **발생 시점 기준** 분류이다.

## 1-2. 성격/유무형에 따른 엔터티 분류 – Event Entity

- **Event Entity(사건 엔터티)**  
  - 사고, 이벤트, 장애 발생 등 **사건 자체를 기록**하는 엔터티.  
  - 예: 사고 이력, 이벤트 참여 기록, 장애 발생 기록.
- 이는 **유형/무형·성격** 기준 분류에 속하며,  
  - 발생 시점 기준(Fundamental/Main/Active)과는 다른 축이다.

| 기준             | 종류 예시                                      | 키워드                 |
|------------------|-----------------------------------------------|------------------------|
| 발생 시점 기준   | Fundamental, Main, Active                     | 언제 생기고 사라지는가 |
| 성격/유형 기준   | Event, 코드/참조 엔터티 등                    | 무엇을 표현하는가      |

## 1-3. 엔터티 명명 규칙

일반적인 엔터티 명명 원칙:

- **의미 있는 단어 사용**: 현실 세계 개념이 바로 떠오르게 작성.
- **현업(고객)에게 친숙한 용어 사용**: 개발자 편한 용어가 아니라, 서비스를 사용하는 **업무 사용자에게 자연스러운 용어** 사용.
- **단수형 명사**: Orders(X) → Order(O).
- **약어 사용 지양**: Dept(X) → Department(O)처럼 되도록 풀어서 작성.

→ 시험에서 자주 틀리는 보기는  
“개발자에게 친숙한 용어를 사용해야 개발 편의성이 향상된다” 같은 문장이다.

---

# 📌 2. 키 개념: Candidate Key, Primary Key, Alternative Key

## 2-1. Candidate Key(후보키)

- 한 행을 **유일하게 식별할 수 있는 모든 속성 조합**.
- 예: 학생 테이블에서 학번, 주민번호, 이메일이 모두 학생을 유일하게 구분할 수 있다면  
  → 이 세 개는 모두 Candidate Key.

## 2-2. Primary Key(기본키)

- 여러 Candidate Key 중에서 **대표로 선택된 키**.
- 물리적으로 인덱스를 만들고, 대부분의 참조 관계의 대상이 된다.

## 2-3. Alternative Key(대체키)

- Candidate Key 중 **Primary Key로 선택되지 않은 나머지 키들**.
- 예:  
  - Candidate Key = {학번, 주민번호, 이메일}  
  - Primary Key = 학번  
  - Alternative Key = 주민번호, 이메일

| 용어            | 의미                                      |
|-----------------|-------------------------------------------|
| Candidate Key   | 행을 유일 식별 가능한 모든 키 후보 집합  |
| Primary Key     | 후보키 중에서 선택된 대표키              |
| Alternative Key | PK가 되지 않은 나머지 후보키             |

---

# 📌 3. ERD 표기법: IE vs Barker

## 3-1. NULL 허용 여부 표현

- **IE 표기법**
  - 속성의 **NULL/NOT NULL 여부를 표기하지 않는다**고 보는 게 시험 관점.
- **Barker 표기법**
  - **NOT NULL 속성 앞에 `*` 기호**를 붙여서 표현.

## 3-2. 카디널리티(관계 차수) 표현

- IE, Barker **둘 다** 1:1, 1:N, N:M 등의 카디널리티 표현 가능.

## 3-3. 식별자(키) 표현 방식

- **Barker**
  - 식별자 속성 앞에 `#`를 붙여 Primary Key를 표현.
- **IE**
  - 엔터티 내부를 선으로 나누어  
    - 윗부분: 식별자 속성  
    - 아랫부분: 일반 속성  
    으로 구분.

| 구분                    | IE 표기법                                    | Barker 표기법                                   |
|-------------------------|----------------------------------------------|------------------------------------------------|
| NULL 여부 표현          | 지원하지 않는 것으로 본다                   | NOT NULL 속성 앞에 `*`                         |
| 카디널리티 표현         | 가능                                         | 가능                                           |
| 식별자 표시             | 엔터티 내부 선으로 구분                     | 속성 앞에 `#`                                  |

---

# 📌 4. PIVOT / UNPIVOT 와 INCLUDE NULLS / EXCLUDE NULLS

## 4-1. 기본 개념

UNPIVOT에서 측정값 컬럼에 대해 NULL을 어떻게 처리할지 결정하는 옵션:

- **EXCLUDE NULLS**
  - **측정값이 NULL인 행을 결과에서 제거**한다.
- **INCLUDE NULLS**
  - 측정값이 NULL이어도 **행을 유지하고 값만 NULL로 둔다.**

Oracle에서 UNPIVOT의 기본값은 **EXCLUDE NULLS**이다.

## 4-2. 예시 코드

```sql
CREATE TABLE sales (
    year    VARCHAR2(4),
    q1      NUMBER,
    q2      NUMBER,
    q3      NUMBER,
    q4      NUMBER
);

INSERT INTO sales VALUES ('2024', 100, 200, NULL, 400);
INSERT INTO sales VALUES ('2023', NULL, 300, NULL, 500);
COMMIT;
```

### (1) EXCLUDE NULLS (기본값)

```sql
SELECT *
FROM sales
UNPIVOT
    ( amount FOR quarter IN (q1, q2, q3, q4) );
    -- EXCLUDE NULLS 생략된 상태
```

결과:

| YEAR | QUARTER | AMOUNT |
|------|---------|--------|
| 2024 | Q1      | 100    |
| 2024 | Q2      | 200    |
| 2024 | Q4      | 400    |
| 2023 | Q2      | 300    |
| 2023 | Q4      | 500    |

→ NULL이었던 Q3, 2023년 Q1/Q3 행이 **완전히 제거**된다.

### (2) INCLUDE NULLS

```sql
SELECT *
FROM sales
UNPIVOT INCLUDE NULLS
    ( amount FOR quarter IN (q1, q2, q3, q4) );
```

결과:

| YEAR | QUARTER | AMOUNT |
|------|---------|--------|
| 2024 | Q1      | 100    |
| 2024 | Q2      | 200    |
| 2024 | Q3      | NULL   |
| 2024 | Q4      | 400    |
| 2023 | Q1      | NULL   |
| 2023 | Q2      | 300    |
| 2023 | Q3      | NULL   |
| 2023 | Q4      | 500    |

→ 행은 모두 유지되고, NULL은 그대로 보인다.

## 4-3. 요약 표

| 옵션           | 동작                                      | UNPIVOT 기본값 |
|----------------|-------------------------------------------|----------------|
| INCLUDE NULLS  | NULL 값도 결과에 포함                     | X              |
| EXCLUDE NULLS  | 측정값이 NULL인 행 자체를 결과에서 제거  | O              |

---

# 📌 5. 문자 정렬, LIKE, NULL 정렬

## 5-1. 문자형 정렬(VARCHAR) – 숫자처럼 보여도 **문자 사전순**

문자열 `'100'`, `'99'`, `'900'`, `'1000'`을 정렬하면  
숫자 크기가 아니라 **문자 하나씩 비교하는 사전순(lexical order)** 기준으로 정렬된다.

예를 들어 `ORDER BY COL2 DESC`에서:

- `'99'` vs `'900'`: 첫 글자 `'9'` 동일, 두 번째 `'9'` vs `'0'` → `'9'`가 크므로 `'99'`가 더 큼.
- `'100'` vs `'1000'`: 앞 세 글자는 같고, 더 긴 `'1000'`이 더 큰 문자열.

그래서 내림차순 결과는 `'99'`, `'900'`, `'1000'`, `'100'` 이 된다.  
숫자로 정렬하고 싶다면:

```sql
ORDER BY TO_NUMBER(COL2) DESC;
```

처럼 명시적으로 숫자로 변환해야 한다.

## 5-2. LIKE의 대소문자 구분

- Oracle 기본: LIKE 연산은 **대소문자 구분**.  
  - `WHERE LOC LIKE '%S%'`  
    - `SE0UL`, `BUSAN`은 매칭  
    - `seoul`은 매칭되지 않는다.
- SQL Server는 Collation에 따라 다르지만, 기본 Collation에서는 대소문자 구분을 하지 않는 경우가 많다.
- 또한 %S%는 앞에 와도되고 안와도 되고해서 어디든 있기만하면 된다.

## 5-3. NULLS FIRST / NULLS LAST

- **Oracle**
  - `ORDER BY amount DESC NULLS LAST` 처럼 NULL의 위치를 지정하는 문법을 지원한다.
- **SQL Server**
  - `NULLS LAST/FIRST` 문법이 없다.
  - 대신 CASE 식으로 우회:

```sql
ORDER BY
    CASE WHEN amount IS NULL THEN 1 ELSE 0 END,
    amount DESC;
```

| 기능        | Oracle | SQL Server |
|-------------|--------|-----------|
| NULLS FIRST | O      | X         |
| NULLS LAST  | O      | X         |

---

# 📌 6. 집합 연산자: UNION, UNION ALL, MINUS, NOT IN

## 6-1. UNION vs UNION ALL

- **UNION**
  - **중복 행 제거**.
  - NULL도 하나의 값으로 취급하므로, **중복된 NULL 행은 하나만 남는다.**
  - 정렬/중복 제거 작업이 있어 성능이 더 무겁다.

- **UNION ALL**
  - **중복을 제거하지 않음**.
  - NULL도 그대로 여러 번 출력.
  - 빠르다.

예:

```sql
SELECT NULL
UNION
SELECT NULL;
-- 결과: NULL 1개

SELECT NULL
UNION ALL
SELECT NULL;
-- 결과: NULL 2개
```

→ 시험에서 자주 나오는 오답:  
“UNION은 NULL 값을 제거한다” → 틀린 설명이다.  
UNION은 NULL이라서 제거하는 것이 아니라, **중복행이기 때문에 제거**한다.

## 6-2. MINUS와 NULL

Oracle에서 `A MINUS B`:

- A에만 존재하는 행을 반환(중복 제거).
- 비교 컬럼에 NULL이 있어도 연산 가능.  
  - 단, 같은 위치에 NULL이 있으면 “같은 행”으로 취급되어 제거.

## 6-3. NOT EXISTS / LEFT JOIN IS NULL / NOT IN

- `NOT EXISTS`  
  - 서브쿼리 결과에 값이 존재하는지 여부만 본다.  
  - 서브쿼리 결과에 NULL이 있어도 **안전**하다.
- `LEFT JOIN ... WHERE B.ID IS NULL`  
  - B에 매칭되지 않는 A를 찾는 전형적인 패턴.  
  - 마찬가지로 NULL 값에 잘 동작.
- `NOT IN (subquery)`  
  - **서브쿼리 결과에 NULL이 한 개라도 있으면 전체 결과가 0행이 되는 위험한 연산**.  
  - 예: `WHERE A.ID NOT IN (2,3,NULL)` 은 어떤 값도 TRUE가 되지 않는다.

| 연산                        | NULL 포함 시 | 특징                            |
|-----------------------------|--------------|---------------------------------|
| NOT EXISTS                  | 문제 없음    | 비교 시 가장 안전               |
| LEFT JOIN ... IS NULL       | 문제 없음    | 자주 사용하는 안티 조인 패턴    |
| MINUS                       | NULL도 비교  | A만 남기는 집합 연산            |
| NOT IN (subquery)           | NULL 있으면 전체 0행 | 실무/시험에서 주의해야 할 패턴 |

---

# 📌 7. DML vs DDL: DELETE, TRUNCATE, SQL Server 트랜잭션

## 7-1. DELETE vs TRUNCATE

| 구분        | DELETE                                  | TRUNCATE                                       |
|-------------|-----------------------------------------|-----------------------------------------------|
| 명령 종류   | DML                                    | DDL                                           |
| WHERE 절    | 사용 가능 (`DELETE FROM T WHERE ...`)  | 사용 불가 (`TRUNCATE TABLE T` 전체 삭제)     |
| 삭제 범위   | 조건에 맞는 일부 행만 삭제 가능        | 테이블의 모든 행 삭제(초기화)                |
| 롤백        | 일반적으로 트랜잭션 내에서 롤백 가능   | DB마다 다르지만, 구조 초기화 성격, 제한적    |

→ `DELETE ... WHERE COL1='A'` 와 `TRUNCATE TABLE ... WHERE ...` 는 애초에 문법부터 다르고, TRUNCATE에는 WHERE 절이 없다.

## 7-2. SQL Server에서 DDL과 트랜잭션

SQL Server는 **DDL(예: CREATE TABLE)** 도 트랜잭션에 포함시킬 수 있다.

```sql
BEGIN TRAN;
CREATE TABLE TAB (...);
INSERT ...
ROLLBACK;
```

- 마지막 `ROLLBACK` 이 실행되면  
  - INSERT된 데이터뿐 아니라  
  - **CREATE TABLE 자체도 롤백**되어 테이블이 사라진다.

시험 포인트:

- SQL Server 환경에서 `ROLLBACK` 하면  
  - 트랜잭션 안에서 수행된 DDL과 DML이 **모두 취소**될 수 있다.  
  - 따라서 마지막에 `SELECT COUNT(*) FROM TAB` 같은 문장은 **테이블이 없어 오류**가 된다.

---

# 📌 8. 윈도우 함수: RANGE vs ROWS, 누적합, LAG/LEAD

## 8-1. ROWS vs RANGE

### ROWS BETWEEN

- **행 번호 기반**으로 창(window)을 정한다.
- 예:

```sql
ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
```

→ 현재 행 기준 위 1행, 아래 1행(양옆 한 칸) 포함.

### RANGE BETWEEN

- `ORDER BY` 에 사용한 컬럼의 **값 범위**를 기준으로 창을 정한다.

```sql
SUM(amount) OVER (
  ORDER BY amount
  RANGE BETWEEN 100 PRECEDING AND 100 FOLLOWING
)
```

→ 현재 행의 amount 값에서 **$-100 \sim +100$ 범위**에 해당하는 행들의 amount를 모두 더한다.

문제 예시에서 amount = 100, 200, 200, 300, 400 일 때  
각 행의 범위마다 모든 값이 포함되어 결국 각 행의 합이 1200이 되었다.

| 옵션 | 기준        | 예시 해석                            |
|------|-------------|--------------------------------------|
| ROWS | 행 번호     | 위/아래 몇 행을 볼 것인지            |
| RANGE| 정렬 컬럼 값| 현재 값 기준 몇 범위 안의 값을 볼지  |

## 8-2. UNBOUNDED PRECEDING ~ CURRENT ROW

```sql
SUM(amount) OVER (
  ORDER BY amount
  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
)
```

- **UNBOUNDED PRECEDING**: 정렬 기준으로 **가장 처음 행부터**.
- **CURRENT ROW**: 현재 행의 값까지.

RANGE 기준으로, “처음 값 ~ 현재 값” 사이에 있는 모든 행의 합을 구하는 누적합(cumulative sum)을 만든다.

## 8-3. LAG, LEAD 의 기본형과 default 값

```sql
LAG(amount, 2, 100) OVER (ORDER BY id)  AS prev2
LEAD(amount, 2, 100) OVER (ORDER BY id) AS next2
```

- `LAG(expr, offset, default)`  
  - 현재 행 기준 **offset 행 이전**의 값을 가져오고  
  - 그 행이 없으면 `default` 값을 반환.
- `LEAD` 는 반대로 **offset 행 이후**의 값을 가져옴.

예: ID가 1~5, amount 500,400,300,200,100 인 테이블에서

- ID=1에서 `LAG(amount,2,100)` → 2행 이전이 없으므로 100(default)
- ID=3에서 `LAG(amount,2,100)` → ID=1의 amount = 500

---

# 📌 9. ROWNUM 의 동작 원리

## 9-1. 정의

- ROWNUM은 **SELECT 결과 집합으로 행이 반환될 때** 1부터 차례대로 부여되는 **가상 컬럼**이다.

## 9-2. 중요한 포인트 – ORDER BY 이전에 번호가 붙는다

실제 처리 순서는 대략:

1. 테이블에서 행을 읽어온다.
2. ROWNUM을 1,2,3,... 순으로 부여한다.
3. WHERE 조건을 평가한다.
4. 마지막에 ORDER BY로 정렬한다.

그래서:

- `WHERE ROWNUM <= 3` → 정상적으로 3행 반환.
- `WHERE ROWNUM >= 1` → 모든 행 반환.
- `WHERE ROWNUM >= 2` →  
  - 첫 번째 행에 ROWNUM=1이 부여되는데, 1 ≥ 2 조건을 만족하지 못해 필터링된다.  
  - Oracle은 이후 행에도 번호를 부여하지 않기 때문에 결과가 0행이 된다.

즉, “ROWNUM은 SELECT 결과에 부여되는 일련번호이다”라는 말은  
정의상 맞지만, **우리가 눈으로 보는 ORDER BY 이후 결과가 아니라 그 이전 단계**라는 점이 함정이다.

---

# 📌 10. 문자열 함수 REPLACE와 LENGTH

문제 예시:

```sql
SELECT LENGTH(REPLACE('SQL D', 'SQL', 'ABC')) FROM DUAL;
```

처리 순서:

1. `REPLACE('SQL D', 'SQL', 'ABC')`  
   → `'ABCD'`  
   (`'SQL D'` 에서 `'SQL'` 부분만 `'ABC'`로 치환, 공백은 그대로 유지되지만 여기서는 문자열 길이상 결과가 4)
2. `LENGTH('ABCD')` → 4

포인트:

- REPLACE는 **일치하는 부분 문자열만 치환**한다.
- 공백이 포함된 원본 문자열을 주의 깊게 읽어야 한다.

---

# 📌 11. NULL, 3값 논리, CASE WHEN

## 11-1. NULL 비교 결과는 $TRUE$, $FALSE$ 가 아니라 $UNKNOWN$

- NULL = NULL → $UNKNOWN$
- 1 = NULL → $UNKNOWN$
- NULL <> 1 → $UNKNOWN$

SQL은 $TRUE$, $FALSE$, $UNKNOWN$ 의 **3값 논리**를 사용한다.

## 11-2. CASE WHEN 의 동작

```sql
CASE
  WHEN 조건1 THEN 값1
  WHEN 조건2 THEN 값2
  ...
  ELSE 값N
END
```

- WHEN 절의 조건이 **$TRUE$일 때만** 해당 THEN 값이 선택된다.
- 조건이 $FALSE$ 이거나 $UNKNOWN$이면 **다음 WHEN으로 넘어가거나 ELSE로 이동**한다.

문제 40 예시:

```sql
SELECT CASE
         WHEN NULL = NULL THEN 'YES'
         ELSE 'NO'
       END
FROM DUAL;
```

- `NULL = NULL` 의 결과는 $UNKNOWN$.
- WHEN 절에서 $UNKNOWN$ 은 $TRUE$ 가 아니므로 THEN 분기 실행 안 됨.
- ELSE 분기로 가서 결과는 `'NO'`.

## 11-3. ELSE 를 생략하면?

```sql
CASE
  WHEN 조건 THEN 'A'
END
```

- ELSE를 쓰지 않으면 **`ELSE NULL`이 자동으로 붙은 것과 같다.**
- 즉, 조건이 $TRUE$가 아닐 때( $FALSE$ 또는 $UNKNOWN$ ) 결과는 NULL.

---

이 정리본을 기반으로 보면,  
ROWNUM, 윈도우 함수, 집합 연산자, NULL 처리, CASE, 트랜잭션과 DDL, ERD 표기법까지 한 번에 연결해서 복습할 수 있다.
