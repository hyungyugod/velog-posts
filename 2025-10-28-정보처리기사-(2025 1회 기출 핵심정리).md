# 📌 1. C의 for문·증감·break 동작
## 1-1. for문의 3구성
- 형식: `for(초기; 조건; 마지막)` → 실행 순서: 초기 → [조건 참] 본문 → 마지막 → 조건 재평가…
- `for(int i=0; i<9; ++i)`에서 시작값은 0이다. `++i`는 **증가한 값**을 다음 평가에 쓰고, `i++`은 **증가 전 값**을 쓰지만, **for문의 “마지막” 위치**에서는 두 표현 모두 “한 번 증가”로 동치.

## 1-2. break의 효과
- `break`를 만나면 **루프 본문을 즉시 종료**하고, for의 “마지막” 증감식도 **실행되지 않는다**.

---

# 📌 2. 배열·문자열 기본
## 2-1. 초기화되지 않은 원소
- 지역 배열을 `int a[5];`처럼만 선언하면 값은 **미정(garbage)**. 전역/정적이면 **0으로 초기화**.
- 문자배열도 동일. 다만 **문자열**은 마지막에 **종단문자 `'

# 📌 3. Java 상속·생성자·바인딩
## 3-1. 생성자 실행 순서(힙 구조 관점)
- 객체 메모리: `Parent` 부분이 먼저, 그 위에 `Child` 부분이 놓인다.
- 실행 흐름: **Child 생성자 진입 → (묵시적) `super()` → Parent 필드 초기화·Parent 생성자 수행 → Child 필드 초기화 → Child 생성자 본문**.

## 3-2. 동적 바인딩의 함정
- Parent 생성자 안에서 `show()` 호출 시 **실제 타입(Child)의 메서드**가 호출된다(가상 메서드 테이블).
- 이때 Child 필드는 아직 **기본값 상태**일 수 있어 “덜 초기화된 객체”에서 메서드가 실행될 수 있다.

---

# 📌 4. 테스트 커버리지
## 4-1. 종류 개관
- **문장(Statement)**: 모든 **문장**을 ≥1회 실행.
- **분기/결정(Branch/Decision)**: 각 분기의 **참/거짓**을 ≥1회씩.
- **조건(Condition)**: 복합 조건의 **원자 조건** 각각이 참/거짓.
- **MC/DC**: 각 원자 조건이 **독립적으로** 전체 결과에 영향.
- **경로(Path)**: 가능한 모든 경로.
- **루프**: 0회/1회/다회.

## 4-2. 예제 흐름(문장 vs 분기)
- 코드: `while(a<m || b[a]<x){ if(b[a]<0) b[a]=-b[a]; a++; }`
- **문장 커버리지 예 경로**: `1→2(참)→3(참)→4→5→2(거짓)→6`
- **분기 커버리지 100%**:  
  - `1→2(참)→3(참)→4→5→2(거짓)→6`  
  - `1→2(참)→3(거짓)→5→2(거짓)→6`  
  - `1→2(거짓)→6`

---

# 📌 5. 재귀 분할 호출 트리
## 5-1. 코드
```java
int func(int[] a, int st, int end){
  if(st>=end) return 0;
  int mid=(st+end)/2;
  return a[mid]+Math.max(func(a,st,mid), func(a,mid+1,end));
}
```

## 5-2. 계산 예(배열 {3,5,8,12,17})
- 호출 트리를 그려 아래에서 위로 합산.  
- 결과: **20** (`8 + max(8,12)`).

---

# 📌 6. struct 태그 vs typedef 별칭
## 6-1. 두 이름공간
- `struct student { ... };`의 **student**는 “태그(tag)”.
- `typedef struct student { ... } Student;`의 **Student**는 “별칭(alias)” 타입명.
- 컴파일러는 **태그**와 **typedef**를 **별도 네임스페이스**로 관리.

## 6-2. 자기참조·전방선언
- 자기 자신 포인터가 필요하면 태그가 유용함: `struct Node* next;`.
- 간단 용도는 익명 구조체 + typedef도 가능: `typedef struct { ... } Type;`.

---

# 📌 7. 구조체 크기와 패딩
## 7-1. 예: 
```c
typedef struct student {
  char* name;   // 8B (64-bit)
  int  score[3];// 12B
} Student;
```
- 정렬 단위는 최대 멤버 크기(8). 배치: 8+12=20 → **패딩 4B** → 총 **24B**(64-bit).  
- 32-bit라면 포인터 4B → 총 **16B**.

---

# 📌 8. 연결 리스트 조작 예제
## 8-1. insert(head,i)
- 새 노드 `new->next=head`로 **앞쪽 삽입** → 누적 시 역순: `5→4→3→2→1`.

## 8-2. reconnect(head, 3)
- 값이 3인 노드를 찾아 **앞으로 이동**:  
- 최종 리스트: `3→5→4→2→1`  
- 출력: **35421**

---

# 📌 9. 비트 AND와 16진-2진 변환
## 9-1. 핵심
- `&`는 **비트 AND**. 16진수는 **4비트씩 바로 매핑**.  
  예) `0xA5 = 1010 0101_2`.

## 9-2. 문제 계산 요약(마스크 0xA5)
- `0xA0&0xA5=0xA0(160)`, `0xA5&0xA5=0xA5(165)`,  
  `0xDB&0xA5=0x81(129)`, `0xED&0xA5=0xA5(165)`, `0x81&0xA5=0x81(129)`.
- 학생별 합: 454, 454 → 총 **908**.

## 9-3. 변환 팁
- 항상 **8비트 단위**로 본다: `0x81 = 1000 0001_2 = 128+1 = 129`.  
- 착각 포인트: `1000 0001_2`를 161로 읽는 오류 주의(그건 `0xA1`).

---

# 📌 10. CRC와 관련 용어 지도
## 10-1. CRC(Cyclic Redundancy Check)
- 데이터 비트를 **다항식**으로 보고 **생성다항식**으로 2진 나눗셈.  
- **나머지**를 데이터 뒤에 붙여 전송, 수신측에서 동일 다항식으로 나눠 **나머지 0이면 무오류**.  
- 예: 생성다항식 $x^3 + x + 1$.

## 10-2. 인접 개념
- **Parity**: 1의 개수를 짝/홀로 맞춰 1비트 추가(간단 검출).  
- **Checksum**: 합계를 붙여 비교(간단·빠름).  
- **Hamming Code**: **검출+1비트 정정** 가능.  
- **ARQ**: 오류 검출 시 **재전송**(Stop-and-Wait, Go-Back-N, Selective Repeat).  
- **FEC**: **재전송 없이** 정정(위성 등 고지연 환경 적합).  
- **Sliding Window**: 흐름 제어·전송 효율 향상.

---

# 📌 11. 관용적 변수명 쌍
## 11-1. 의미와 예
- `enc/dec`: encode/decode. 예) XOR 마스크로 부호화/복호화.
- `src/dst`: 원본/목적지. 예) `strcpy(dst, src)`.
- `ptr/ref`: 주소/참조값. 예) `int *ptr=&n; int ref=*ptr;`.
- `buf/len`: 버퍼/길이. 예) `strlen(buf)`.
- `idx/cnt`: 인덱스/개수. 예) `for(int idx=0; idx<cnt; idx++)`.
- `tmp/res`: 임시/결과. 예) `tmp=a*b; res=tmp+2`.
- `in/out`: 입력/출력. 예) `void f(int in,int* out)`.
