# 📌 1. VBA, 리본 메뉴, 매크로 개요

## 1-1. 리본 메뉴(Ribbon)의 개념과 설계 철학

- **리본 메뉴의 의미**
  - 리본(Ribbon)은 실제 리본처럼 **가로로 길게 펼쳐진 도구 모음**이라는 은유에서 나온 이름이다.
  - 기존의 깊은 드롭다운 메뉴 구조(파일 → 편집 → 보기 → … → 하위 메뉴…) 대신, **기능을 넓게 펼쳐 한눈에 보이게 하려는 UI 철학**이 반영되어 있다.

- **기존 메뉴의 문제**
  - 여러 단계의 서브 메뉴를 파고들어가야 기능을 찾을 수 있었다.
  - 사용자는 “기능이 있는지/어디 있는지”조차 알기 어려웠다.
  - 인지 과부하와 탐색 비용이 컸다.

- **리본 메뉴의 설계 방향**
  - 자주 쓰는 기능, 문맥에 따라 필요한 기능을 **탭과 그룹**으로 시각적으로 묶어서 제공.
  - 기능을 **숨기지 않고 노출**해, “발견 가능성(Discoverability)”을 높인다.
  - 예: 개체를 선택하면 관련 리본(그림 서식, 차트 도구 등)이 동적으로 나타난다.
  - UI 철학적으로는, **깊이(depth)를 줄이고 폭(width)을 늘리는 구조**라고 볼 수 있다.

---

## 1-2. 매크로의 설계 철학

- **핵심 철학**  
  엑셀 매크로는 **반복되는 인간의 행동을 기계가 대신 수행하도록 절차화하는 도구**이다.

- **주요 관점**
  1. **반복 작업을 ‘기록 가능한 패턴’으로 보는 관점**
     - 사람의 클릭, 입력, 정렬, 서식 변경 등 반복 행동을 $Procedure$로 보고, 이를 코드(VBA)로 치환한다.
  2. **UI 행동 ↔ 코드(함수 호출)의 1:1 대응**
     - 셀 선택 → $Range("A1").Select$
     - 값 입력 → $Range("A1").Value = 10$
     - 정렬 → $Selection.Sort$
     - 즉, “마우스로 하는 행동 = 객체에 메서드를 호출하는 것”이라는 객체 모델을 전제로 한다.
  3. **비전문가도 ‘무의식적으로 프로그래밍’을 할 수 있게 하는 철학**
     - 사용자는 단순히 “기록 시작 → 작업 → 기록 중지”만 해도 된다.
     - 엑셀이 그 과정을 자동으로 VBA 코드로 변환한다.
  4. **엑셀을 ‘업무 자동화 플랫폼’으로 확장**
     - 단순 계산 도구를 넘어서, 버튼/폼/로직을 포함한 **작은 애플리케이션**을 만들 수 있게 한다.
     - 보고서 생성, 데이터 처리, 파일 저장·메일 발송까지도 자동화 가능하다.

---

## 1-3. 매크로의 작동 원리

1. **행동 기록(Event Recording)**
   - 매크로 기록기를 켜면, 엑셀은 사용자의 동작을 이벤트로 캡처한다.
   - 예: 셀 선택, 값 입력, 서식 변경, 정렬 클릭 등.

2. **이벤트 → VBA 코드 변환**
   - 기록된 이벤트는 내부적으로 대응되는 VBA 호출로 변환된다.
   - 예:
     ```vba
     Range("A1").Select
     ActiveCell.Value = "10"
     ```

3. **Sub 프로시저로 저장**
   - 변환된 코드는 아래와 같이 $Sub$ 프로시저 안에 저장된다.
     ```vba
     Sub Macro1()
         Range("A1").Select
         ActiveCell.Value = "10"
     End Sub
     ```

4. **객체 모델 기반 실행**
   - 엑셀은 $Application \rightarrow Workbooks \rightarrow Worksheets \rightarrow Range$ 와 같은 계층 구조의 객체 모델 위에서, 이 코드를 한 줄씩 실행한다.

---

# 📌 2. VBA의 프로시저: Sub vs Function, JS와의 비교

## 2-1. Sub와 Function의 차이

- **Sub 프로시저**
  - “행동만 하는 절차”.
  - **반환값이 없다.**
  - 예:
    ```vba
    Sub SayHello()
        MsgBox "안녕하세요!"
    End Sub
    ```

- **Function 프로시저**
  - “계산을 수행하고 결과를 반환하는 절차”.
  - **반환값이 있다.**
  - 예:
    ```vba
    Function AddNumbers(a As Integer, b As Integer) As Integer
        AddNumbers = a + b
    End Function

    Sub TestAdd()
        Dim result As Integer
        result = AddNumbers(3, 5)
        MsgBox result    ' 8
    End Sub
    ```

- **엑셀 셀에서 사용 가능한 사용자 정의 함수(UDF)는 Function만 가능**  
  $Sub$는 셀에서 직접 호출할 수 없고, 버튼이나 매크로 실행으로만 호출된다.

---

## 2-2. 프로시저 개념과 JavaScript 함수 비교

- JS에는 “프로시저”라는 별도 키워드는 없다.
- 대신, **반환값이 없는 함수**가 사실상 프로시저 역할을 한다.

- 예 (JS):
  ```javascript
  function sayHello() {
      console.log("안녕하세요!");
  }
  ```
  - 반환값이 없으므로, 프로시저적 함수로 볼 수 있다.

- 대응 관계:
  - VBA $Sub$ ↔ JS에서 $return$ 없는 함수
  - VBA $Function$ ↔ JS에서 $return$으로 값을 반환하는 함수

- 설계 차이:
  - VBA: 전통적인 BASIC 계열 철학 → $Sub$ / $Function$을 문법적으로 명확히 분리.
  - JS: “함수 = 모든 절차의 기본 단위”라는 철학 → 하나의 $function$으로 모두 표현하고, $return$ 사용 여부로 의미가 달라진다.

---

# 📌 3. VBA의 언어적 정체성: Python, C, Java, JS와 비교

## 3-1. Python과 비교

- **공통점**
  - 스크립트 언어 느낌 (인터프리터 기반)
  - 자동화 작업에 강함

- **차이점**
  - Python: 범용 언어, 데이터 분석·웹·AI·스크립트 등 거의 모든 분야에서 사용.
  - VBA: **엑셀(Office) 자동화 전용**에 가깝다.
  - Python: 강한 라이브러리 생태계, 현대적인 OOP·함수형 등 지원.
  - VBA: 제한적인 OOP, 엑셀 객체 모델에 강하게 종속.

- 비유:  
  - Python = 만능 공구 상자.  
  - VBA = 엑셀을 다루는 특화 공구.

---

## 3-2. C와 비교

- C는 저수준, 하드웨어·메모리 제어 중심, 컴파일 언어.
- VBA는 고수준, 문서/객체 조작 중심, 인터프리터 언어.
- 철학적으로 거의 정반대:
  - C: “기계에 가깝게”.
  - VBA: “사용자 작업(엑셀)을 편하게”.

---

## 3-3. Java와 비교

- Java:
  - 강한 객체지향(OOP 100%), 클래스 기반, 범용 애플리케이션 개발.
- VBA:
  - 프로시저 중심 + 약한 OOP.
  - 클래스 사용은 가능하지만 상속 등 정통 OOP는 제한적.

- 비유:
  - Java = 공장에서 완제품 만드는 설계 언어.
  - VBA = 사무실 책상 위에서 자동화 작업을 돌리는 스크립트.

---

## 3-4. JavaScript와 비교

- 공통점:
  - 이벤트 기반 가능.
  - 스크립트 언어.
  - “객체 모델 조작”이 핵심 (DOM vs Excel Object Model).

- 차이점:
  - JS: 웹 브라우저를 지배하는 범용 언어.
  - VBA: 엑셀/오피스 환경 내부에 한정.
  - JS: 동적 객체, 함수형 스타일 등 현대적 특성.
  - VBA: BASIC 계열 문법의 전통적인 스타일.

- 비유:
  - JavaScript = 웹의 기계어.
  - VBA = 엑셀의 기계어.

---

# 📌 4. 변수명이 숫자로 시작할 수 없는 이유

## 4-1. 파서(Parser)의 관점

- 언어는 코드를 **토큰(Token)** 단위로 분리해서 읽는다.
  - $100$ → 숫자 리터럴
  - $abc$ → 식별자(변수명)
  - $x100$ → 식별자
  - $100x$ → 해석하기 애매한 구조

- 만약 변수명이 숫자로 시작 가능하다면:
  - $100a$ 가 “숫자 100에 a 곱하기”인지,
  - “변수 이름이 $100a$” 인지 문법적으로 모호해진다.

- 그래서 언어들은 대개:
  - “숫자로 시작하면 **무조건 숫자 리터럴**”  
  - “문자/언더스코어로 시작하면 **식별자**”
  라는 규칙을 채택한다.

---

## 4-2. 역사적·실용적 이유

- 초기 컴파일러·파서를 단순하게 구현하기 위해 이런 규칙이 자리 잡았다.
- 수십 년간 이어져 내려온 관습으로, C, Java, JS, Python 등 대부분의 언어가 수용했다.
- 사람 눈에도 가독성이 좋아진다:
  - $2sum$ vs $sum2$ → 후자가 훨씬 자연스럽게 “이름”처럼 읽힌다.

---

# 📌 5. Access의 모듈 구조: 폼/보고서/기본 모듈

## 5-1. 모듈(Module)과 모델(Model)의 혼동

- Access의 “모듈(Module)”은 **코드를 담는 파일** 단위이다.
- MVC에서의 “모델(Model)”과는 완전히 다른 개념이다.
- Access/VBA에서 모듈은 $Sub$, $Function$, 이벤트 핸들러 등이 들어 있는 **코드 저장소**이다.

---

## 5-2. 폼 모듈, 보고서 모듈, 기본 모듈의 차이

### 폼 모듈(Form Module)

- 특정 폼에 **종속**된 이벤트 코드 저장소.
- 예:
  - 버튼 클릭 시 실행될 코드.
  - 폼 로드/언로드 시 실행되는 초기화·정리 코드.
- 폼과 1:1로 연결되어 있으며, 폼이 삭제되면 모듈도 함께 사라진다.

### 보고서 모듈(Report Module)

- 특정 보고서에 종속된 코드.
- 보고서 출력 전/후, 섹션 포맷팅, 조건부 표시 등을 제어한다.
- 출력(View) 로직과 연결된 코드다.

### 기본 모듈(Standard Module)

- 특정 폼/보고서에 **종속되지 않는** 공용 코드 모듈.
- 여러 폼/보고서에서 함께 사용하는 유틸리티 함수, 공통 로직 등을 넣는다.
- 프로젝트 탐색기에서 **독립적으로 존재**하며, 전역 함수/프로시저를 정의한다.

---

## 5-3. 왜 “폼/보고서 모듈은 특정 폼/보고서에 관련된 기본 모듈”이라는 표현이 틀린가?

1. **종속성 관점**
   - 기본 모듈: 어떤 개체에도 종속되지 않고 독립적이다.
   - 폼/보고서 모듈: 특정 폼/보고서에 100% 종속된다.
   - 따라서 “종속된 기본 모듈”이라는 표현 자체가 모순이다.

2. **역할 차이**
   - 폼/보고서 모듈: 이벤트 처리(클릭, 로드 등) 중심 → UI에 붙은 컨트롤러 역할.
   - 기본 모듈: 재사용 가능한 계산/로직 함수 등 → 공용 유틸리티.

3. **구조 차이**
   - 폼/보고서 모듈은 개체 내부에 붙어 있고, 개체와 함께 관리된다.
   - 기본 모듈은 개체 밖에서 독립적으로 관리된다.

---

# 📌 6. VBA의 구문 구조: 들여쓰기, 세미콜론, 줄바꿈

## 6-1. 들여쓰기의 의미

- VBA에서 들여쓰기는 **문법적 의미가 없다.**
- 들여쓰기를 엉망으로 해도 코드는 실행된다.
- 블록 구조는 **키워드**로 구분한다.
  - $If \ldots Then$, $Else$, $End\ If$
  - $For \ldots Next$
  - $Sub \ldots End\ Sub$
  - $Function \ldots End\ Function$

- 반면, 파이썬은 들여쓰기가 곧 문법이기 때문에:
  - 들여쓰기를 잘못하면 SyntaxError가 발생한다.

---

## 6-2. 세미콜론(;) 대신 무엇이 쓰이는가?

- VBA는 명령문(statement)의 끝을 **줄바꿈(Line Break)** 으로 구분한다.
- 한 줄에 여러 명령을 쓰고 싶을 때는 **콜론(:)** 을 사용한다.
  ```vba
  MsgBox "A" : MsgBox "B"
  ```

- 요약:
  - 파이썬: 들여쓰기 = 블록 의미, 줄바꿈 = 명령 구분.
  - C/JS: 세미콜론 = 명령 구분.
  - VBA: 줄바꿈 = 명령 구분, **들여쓰기는 가독성을 위한 것뿐**.

---

# 📌 7. 엑셀 객체 모델과 컬렉션

## 7-1. 객체(Object, 개체)와 컬렉션(Collection)

- **객체(Object, 개체)**  
  - 상태(속성, Property)와 행동(메서드, Method)을 가진 단위.
  - 예: $Workbook$, $Worksheet$, $Range$ 등.

- **컬렉션(Collection)**  
  - 동일 타입의 객체들을 모아 관리하는 리스트/집합.
  - 예:
    - $Workbooks$: 열려 있는 모든 $Workbook$ 객체 모음.
    - $Worksheets$: 한 $Workbook$ 안의 모든 $Worksheet$ 모음.

- 다른 언어와 비교:
  - Python의 $list$, $dict$  
  - Java의 $ArrayList$, $HashMap$  
  와 비슷하지만, 엑셀에서는 주로 **“객체 관리자”** 역할을 한다.

---

## 7-2. Application–Workbook–Worksheet–Range 트리 구조

엑셀 객체 모델은 트리 구조를 가진다:

$$
Application \rightarrow Workbooks \rightarrow Workbook \rightarrow Worksheets \rightarrow Worksheet \rightarrow Range
$$

- $Application$: 엑셀 프로그램 전체.
- $Workbooks$: 현재 열려 있는 모든 통합 문서 컬렉션.
- $Workbook$: 파일 하나(예: Book1.xlsx).
- $Worksheets$: 해당 파일 안의 시트 컬렉션.
- $Worksheet$: 개별 시트.
- $Range$: 셀 또는 셀 범위.

이 구조는 웹의 DOM(Document Object Model)처럼,  
문서 구조를 그대로 객체 계층으로 표현한 것이다.

---

## 7-3. 주요 객체별 핵심 속성과 메서드

### (1) Application 개체

- **주요 속성**
  - $Workbooks$: 열린 통합 문서 컬렉션.
  - $ActiveWorkbook$: 현재 활성 Workbook.
  - $ActiveSheet$: 현재 활성 Worksheet.
  - $Calculation$: 계산 모드(자동/수동).
  - $ScreenUpdating$: 화면 새로고침 여부.

- **주요 메서드**
  - $Quit()$: 엑셀 종료.
  - $Calculate()$: 전체 계산 실행.
  - $Run()$: 매크로 실행.

---

### (2) Workbook 개체

- **주요 속성**
  - $Name$: 파일 이름.
  - $Path$: 파일 경로.
  - $FullName$: 전체 경로 포함 이름.
  - $Worksheets$: 시트 컬렉션.
  - $ReadOnly$: 읽기 전용 여부.

- **주요 메서드**
  - $Save()$, $SaveAs()$: 저장.
  - $Close()$: 닫기.
  - $Activate()$: 해당 통합 문서 활성화.

---

### (3) Worksheet 개체

- **주요 속성**
  - $Name$: 시트 이름.
  - $Cells$: 전체 셀.
  - $Range("A1")$: 특정 셀/범위.
  - $UsedRange$: 사용 중인 영역.
  - $Visible$: 표시/숨김.

- **주요 메서드**
  - $Activate()$: 시트 활성.
  - $Calculate()$: 시트 계산.
  - $Delete()$: 시트 삭제.

---

### (4) Range 개체

- **주요 속성**
  - $Value$: 실제 값.
  - $Text$: 셀에 표시되는 텍스트.
  - $Formula$: 수식 문자열.
  - $Row$, $Column$: 행/열 번호.
  - $Rows$, $Columns$: 범위 내 행/열 컬렉션.

- **주요 메서드**
  - $Select()$, $Copy()$, $Delete()$.
  - $Clear()$, $ClearContents()$.
  - $Resize()$: 범위 크기 조정.
  - $Offset()$: 기준 위치에서 상대 이동.
  - $Sort()$: 정렬.

---

# 📌 8. PageSetup, ActiveSheet, Columns, Offset 좌표계

## 8-1. ActiveSheet.PageSetup 의 의미

- $ActiveSheet$: 현재 활성화된 $Worksheet$ 객체.
- $PageSetup$: 해당 시트의 인쇄 설정을 담당하는 **하위 객체**.

따라서,
- $ActiveSheet.PageSetup$ 은  
  “현재 시트의 인쇄(페이지 설정) 프로필에 접근한다”는 의미이다.

- 제어할 수 있는 대표 속성:
  - $Orientation$: 가로/세로 인쇄 방향.
  - $LeftMargin$, $RightMargin$, $TopMargin$, $BottomMargin$: 여백.
  - $Zoom$: 확대/축소 비율.
  - $FitToPagesWide$, $FitToPagesTall$: 페이지에 맞춰 축소/확대.

설계 철학적으로:
- $Worksheet$ = 문서의 내용.
- $PageSetup$ = 이 문서를 어떻게 출력할지에 대한 정책/프로필.

---

## 8-2. ActiveSheet의 정체

- $ActiveSheet$ 는 **현재 선택된 Worksheet 객체 하나에 대한 참조**이다.
- 타입은 $Worksheet$ 이고, 다음과 같은 것과 같은 레벨이다:
  - $Worksheets(1)$
  - $Worksheets("Sheet1")$

- 차이점:
  - $Worksheets(index)$: 고정된 특정 시트를 지정.
  - $ActiveSheet$: 사용자가 현재 선택해 둔 시트를 동적으로 가리킴.

---

## 8-3. Worksheet.Columns 와 표(ListObject)의 차이

- $Worksheet.Columns$
  - 해당 시트에 존재하는 **모든 열** ($A \sim XFD$, 16{,}384$개$).
  - 표가 있든 없든 항상 존재하는 “시트의 구조”를 의미한다.

- $ListObjects("Table1").ListColumns$
  - $Ctrl+T$ 로 만든 “표(Table)” 내부의 열 컬렉션.
  - 시트 전체가 아니라, 특정 표 범위 안의 열만 다룬다.

따라서:
- “워크시트의 모든 열” = 시트 구조 전체($Columns$).
- “표의 열” = $ListObject$ 내부 열($ListColumns$).

---

## 8-4. Offset에서 아래쪽이 $+$ 인 이유

- 엑셀의 내부 좌표계는:
  - 행 번호가 **아래로 갈수록 증가**한다.
  - 열 번호가 **오른쪽으로 갈수록 증가**한다.

- $Range.Offset(rowOffset, columnOffset)$ 에서:
  - $rowOffset > 0$ → 아래로 이동.
  - $rowOffset < 0$ → 위로 이동.
  - $columnOffset > 0$ → 오른쪽으로 이동.
  - $columnOffset < 0$ → 왼쪽으로 이동.

- 이는 “문서/표의 자연스러운 흐름(위에서 아래로, 왼쪽에서 오른쪽으로)”을  
  좌표계의 양의 방향으로 채택한 결과이다.

- 수학 좌표계(위쪽이 $+$)와는 다르지만,
  문서·2D 그래픽(캔버스, 화면 좌표) 세계에서는 **위가 $0$, 아래로 갈수록 $+$**인 경우가 많다.

---

# 📌 9. DBMS와 Access, 백업·복구 설계 철학

## 9-1. DBMS 도입 시 백업·복구 시간이 늘어나는 이유

- DBMS는 단순 파일 복사가 아니라 **트랜잭션 단위**로 데이터를 관리한다.
- 백업 시 항상 **일관된 시점(consistent state)** 을 확보해야 하므로, 진행 중인 트랜잭션 처리와 로그(redo/undo) 반영이 필요하다.
- 백업 대상은 단순 데이터가 아니라 다음을 포함한다.
  - 데이터 페이지
  - 인덱스 페이지
  - 트랜잭션 로그(undo/redo 정보)
  - 시스템 카탈로그, 통계 정보 등
- 운영 중에는 서비스가 계속 돌아가므로, **서비스 중단 없이(snapshot, checkpoint, 로그 백업 등)** 백업·복구를 수행해야 한다.
- 복구 과정은 단순 “파일 복사”가 아니라
  1. Full Backup 복원
  2. Differential/Incremental 복원
  3. 트랜잭션 로그 재적용(redo)
  4. 필요한 경우 rollback(undo)
  의 과정을 거친다.
- 결론: DBMS는 **데이터를 시간축 전체에서 보존하는 구조**이기 때문에, 그만큼 백업/복구가 무겁고 시간이 많이 든다.

## 9-2. Access는 DBMS인가?

- Microsoft Access는 **파일 기반 DBMS + GUI 기반 개발 환경** 이 합쳐진 형태이다.
- 내부에:
  - 테이블, 쿼리, 인덱스, 무결성 제약(기본키, 참조 무결성)
  - SQL 질의 처리
  를 지원하므로 분명 DBMS 역할을 수행한다.
- 다만 Oracle, MySQL 같은 **서버형 DBMS** 와 달리:
  - 단일 파일(.accdb)에 데이터 저장
  - 다중 사용자, 고동시성 환경에 약함
  - 주 용도: 소규모/개인/부서용 데이터베이스
- 정리: Access는 **경량·파일 기반 DBMS** 이지만, 대규모 서버 DBMS와는 설계 목적과 스케일이 다르다.

---

# 📌 10. Yes/No 필드의 저장 구조와 의미

## 10-1. Yes/No 필드는 1비트가 아닌 1바이트에 가깝다

- Access의 Yes/No 필드는 논리적으로:
  - 0 또는 -1 (False/True) 형태의 **Boolean 값** 으로 취급된다.
- 그러나 CPU와 메모리는 기본적으로 **바이트 단위(8비트)** 로 읽고 쓰므로, 실제 저장 단위는 1비트가 아니라 **최소 1바이트 수준** 이다.
- Access는 2KB 페이지 단위로 데이터를 저장하며, 레코드 내부에서도 Boolean을 위한 최소 단위는 바이트이다.
- 정리:
  - 논리 표현: 0 / -1 형식의 논리값
  - 물리 저장: 1비트가 아니라 1바이트 단위에 포함되어 저장

---

# 📌 11. 입력 마스크 설계철학: L, ?, &, C

## 11-1. L, ? 기호의 의미

- **L**: Letter(문자)의 약자  
  - 유니코드 기준으로 "문자(letter)"로 분류되는 글자
  - 영문자뿐 아니라 한글, 기타 언어 문자까지 포함
  - “반드시 문자(필수)”를 의미
- **?**: Optional letter(선택적 문자)
  - 정규표현식, 프로그래밍 등에서 ? 는 "있어도 되고 없어도 되는" 요소를 의미하는 상징적 기호
  - Access에서도 이 상징을 가져와 **선택적 문자**로 사용

## 11-2. &, C 기호의 의미

- **&**: Required character(필수 임의 문자)
  - 문자(letter)뿐 아니라 숫자, 기호 등 **아무 문자나 허용하지만, 반드시 입력해야 하는 필드**
  - & 기호는 AND/연결의 의미가 있어 “무조건 값이 있어야 한다”는 느낌과 연결
- **C**: Optional character(선택적 임의 문자)
  - Character의 앞글자 C
  - 아무 문자나 허용하지만, **입력은 선택적**
- 전체 구조는 다음과 같은 2×2 분류를 이룬다.

| 구분 | 문자(letter) | 임의 문자(character) |
|------|--------------|----------------------|
| 필수 | L            | &                    |
| 선택 | ?            | C                    |

---

# 📌 12. 바운드 열(Bound Column)과 컨트롤 값(Control Value)

## 12-1. 바운드 열의 개념

- 콤보 상자나 목록 상자에 여러 열을 표시할 수 있을 때,
  - 사용자에게는 “이름, 설명” 등의 **표시용 열** 을 보여주면서
  - 실제로 DB 필드에 저장되는 값은 “코드값” 한 개만 필요하다.
- 이 때 “실제로 저장되는 값이 들어 있는 열”이 **바운드 열(Bound Column)** 이다.

## 12-2. 컨트롤 값(Control Value)의 의미

- 컨트롤이 최종적으로 갖는 값 = **컨트롤 값**
- 콤보박스의 경우:
  - 화면에 보이는 것은 “지역명”
  - 컨트롤 값은 “바운드 열의 값(지역코드)”

---

# 📌 13. 참조 무결성과 추가·삭제의 차이

## 13-1. 삭제 시 참조 무결성이 깨지지 않는 경우

- 자식 레코드는 삭제될 뿐, 남아 있는 FK가 없다.

## 13-2. 추가 시 참조 무결성이 깨질 수 있는 이유

- FK가 부모 테이블에 존재하지 않는 값을 참조하면 무결성 위반.

---

# 📌 14. 여러 레코드 동시 삽입 제한의 이유

- 관계형 데이터는 순서 기반이 아니라 **집합 모델**이므로 “중간 삽입” 개념이 없다.
- 다중 삽입은 PK 생성 충돌, FK 위험 등으로 인해 무결성 문제를 일으킬 수 있다.

---

# 📌 15. 연결 테이블에서 변경은 되고 삭제가 안 되는 이유

- UPDATE는 비교적 자유롭지만,
- DELETE는 반드시 PK 또는 고유 인덱스로 “단 하나의 행”을 식별해야 한다.
- 외부 DB가 이를 확인하지 못하면 삭제를 거부.

---

# 📌 16. Access가 PowerPoint를 연결할 수 없는 이유

- PowerPoint는 행/열 기반의 정형 데이터가 아니라, 시각적 요소 기반의 **비정형 데이터**.
- Access는 정형 데이터 원본만 연결/가져오기 지원.

---

# 📌 17. 문자열 함수: StrComp, String, StrConv

- StrComp: 문자열 비교(텍스트 비교 vs 이진 비교)
- String: 특정 문자 반복 생성
- StrConv: 문자열 변환(대/소문자, 전각/반각 등)

---

# 📌 18. DateDiff interval 옵션과 "y"

- `"y"`는 두 날짜의 “연중 날짜(day-of-year)”를 비교하는 개념.
- 실제 일수 차이("d")와 다르게, 두 날짜가 속한 "연도"는 무시함.

---

# 📌 19. InStr 대소문자 구별

- 기본적으로 **대소문자를 구별하지 않는 텍스트 비교**를 수행.
- 엄격한 비교는 `vbBinaryCompare` 지정 필요.

---

# 📌 20. 바운드/언바운드 폼과 보안성

- Bound Form: Record Source로 DB와 직접 연결.
- Unbound Form: 제어권이 전부 VBA/매크로에 있음.
- 폼을 통해 접근하게 하면 테이블 직접 접근을 차단하여 보안을 강화.

---

# 📌 21. 페이지 머리글이 폼에서 안 보이는 이유

- 폼은 “페이지 개념이 없는 화면 UI”.
- 페이지 헤더는 인쇄 페이지 전용.
- 인쇄 시에도 폼은 인쇄용이 아니므로 페이지 헤더가 표시되지 않음.

---

# 📌 22. Record Source vs Control Source

- Record Source: 폼 전체가 어떤 데이터 집합과 바운드될지 결정.
- Control Source: 그 데이터 집합 내부의 필드를 어떤 컨트롤이 표시할지 결정.
